<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","context.rs"],"content":"//! Document context and related types for template rendering\n\nuse crate::{DocumentType, MetisError, Result};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// Context for document creation containing all template variables\n#[derive(Debug, Clone, Serialize)]\npub struct DocumentContext {\n    // Core fields for all documents\n    pub title: String,\n    pub slug: String,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub updated_at: DateTime\u003cUtc\u003e,\n    pub parent_title: Option\u003cString\u003e,\n    pub blocked_by: Vec\u003cString\u003e,\n\n    // Document-type specific fields\n    pub risk_level: Option\u003cRiskLevel\u003e,        // Strategy\n    pub stakeholders: Vec\u003cString\u003e,            // Strategy, Vision\n    pub technical_lead: Option\u003cString\u003e,       // Initiative\n    pub complexity: Option\u003cComplexity\u003e,       // Initiative\n    pub decision_maker: Option\u003cString\u003e,       // ADR\n    pub decision_date: Option\u003cDateTime\u003cUtc\u003e\u003e, // ADR\n    pub number: Option\u003cu32\u003e,                  // ADR\n}\n\n/// Risk level for strategies\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum RiskLevel {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\n/// Complexity level for initiatives\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Complexity {\n    S,  // Small\n    M,  // Medium\n    L,  // Large\n    XL, // Extra Large\n}\n\nimpl DocumentContext {\n    /// Create a new DocumentContext with required fields\n    pub fn new(title: String) -\u003e Self {\n        let slug = Self::title_to_slug(\u0026title);\n        let now = Utc::now();\n\n        Self {\n            title,\n            slug,\n            created_at: now,\n            updated_at: now,\n            parent_title: None,\n            blocked_by: Vec::new(),\n            risk_level: None,\n            stakeholders: Vec::new(),\n            technical_lead: None,\n            complexity: None,\n            decision_maker: None,\n            decision_date: None,\n            number: None,\n        }\n    }\n\n    /// Validate context for a specific document type\n    pub fn validate_for_type(\u0026self, doc_type: \u0026DocumentType) -\u003e Result\u003c()\u003e {\n        match doc_type {\n            DocumentType::Strategy =\u003e {\n                if self.risk_level.is_none() {\n                    return Err(MetisError::MissingRequiredField {\n                        field: \"risk_level\".to_string(),\n                    });\n                }\n            }\n            DocumentType::Initiative =\u003e {\n                if self.complexity.is_none() {\n                    return Err(MetisError::MissingRequiredField {\n                        field: \"complexity\".to_string(),\n                    });\n                }\n            }\n            DocumentType::Adr =\u003e {\n                if self.decision_maker.is_none() {\n                    return Err(MetisError::MissingRequiredField {\n                        field: \"decision_maker\".to_string(),\n                    });\n                }\n                if self.number.is_none() {\n                    return Err(MetisError::MissingRequiredField {\n                        field: \"number\".to_string(),\n                    });\n                }\n            }\n            DocumentType::Vision | DocumentType::Task =\u003e {\n                // No additional required fields\n            }\n        }\n        Ok(())\n    }\n\n    /// Convert title to URL-friendly slug\n    pub fn title_to_slug(title: \u0026str) -\u003e String {\n        title\n            .to_lowercase()\n            .chars()\n            .map(|c| if c.is_alphanumeric() { c } else { '-' })\n            .collect::\u003cString\u003e()\n            .split('-')\n            .filter(|s| !s.is_empty())\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"-\")\n    }\n\n    /// Builder pattern methods for setting optional fields\n    pub fn with_parent(mut self, parent_title: String) -\u003e Self {\n        self.parent_title = Some(parent_title);\n        self\n    }\n\n    pub fn with_blocked_by(mut self, blocked_by: Vec\u003cString\u003e) -\u003e Self {\n        self.blocked_by = blocked_by;\n        self\n    }\n\n    pub fn with_risk_level(mut self, risk_level: RiskLevel) -\u003e Self {\n        self.risk_level = Some(risk_level);\n        self\n    }\n\n    pub fn with_stakeholders(mut self, stakeholders: Vec\u003cString\u003e) -\u003e Self {\n        self.stakeholders = stakeholders;\n        self\n    }\n\n    pub fn with_technical_lead(mut self, technical_lead: String) -\u003e Self {\n        self.technical_lead = Some(technical_lead);\n        self\n    }\n\n    pub fn with_complexity(mut self, complexity: Complexity) -\u003e Self {\n        self.complexity = Some(complexity);\n        self\n    }\n\n    pub fn with_decision_maker(mut self, decision_maker: String) -\u003e Self {\n        self.decision_maker = Some(decision_maker);\n        self\n    }\n\n    pub fn with_decision_date(mut self, decision_date: DateTime\u003cUtc\u003e) -\u003e Self {\n        self.decision_date = Some(decision_date);\n        self\n    }\n\n    pub fn with_number(mut self, number: u32) -\u003e Self {\n        self.number = Some(number);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::Utc;\n\n    #[test]\n    fn test_title_to_slug() {\n        assert_eq!(\n            DocumentContext::title_to_slug(\"Core Document Management Library\"),\n            \"core-document-management-library\"\n        );\n        assert_eq!(\n            DocumentContext::title_to_slug(\"ADR-001: Document Format\"),\n            \"adr-001-document-format\"\n        );\n        assert_eq!(\n            DocumentContext::title_to_slug(\"Storage \u0026 Indexing System\"),\n            \"storage-indexing-system\"\n        );\n    }\n\n    #[test]\n    fn test_new_context() {\n        let ctx = DocumentContext::new(\"Test Document\".to_string());\n        assert_eq!(ctx.title, \"Test Document\");\n        assert_eq!(ctx.slug, \"test-document\");\n        assert!(ctx.created_at \u003c= Utc::now());\n        assert!(ctx.updated_at \u003c= Utc::now());\n    }\n\n    #[test]\n    fn test_strategy_validation() {\n        let ctx = DocumentContext::new(\"Test Strategy\".to_string());\n\n        // Should fail without risk_level\n        assert!(ctx.validate_for_type(\u0026DocumentType::Strategy).is_err());\n\n        // Should pass with risk_level\n        let ctx_with_risk = ctx.with_risk_level(RiskLevel::Medium);\n        assert!(ctx_with_risk\n            .validate_for_type(\u0026DocumentType::Strategy)\n            .is_ok());\n    }\n\n    #[test]\n    fn test_initiative_validation() {\n        let ctx = DocumentContext::new(\"Test Initiative\".to_string());\n\n        // Should fail without complexity\n        assert!(ctx.validate_for_type(\u0026DocumentType::Initiative).is_err());\n\n        // Should pass with complexity\n        let ctx_with_complexity = ctx.with_complexity(Complexity::M);\n        assert!(ctx_with_complexity\n            .validate_for_type(\u0026DocumentType::Initiative)\n            .is_ok());\n    }\n\n    #[test]\n    fn test_adr_validation() {\n        let ctx = DocumentContext::new(\"Test ADR\".to_string());\n\n        // Should fail without decision_maker and number\n        assert!(ctx.validate_for_type(\u0026DocumentType::Adr).is_err());\n\n        // Should pass with required fields\n        let ctx_complete = ctx\n            .with_decision_maker(\"Engineering Team\".to_string())\n            .with_number(1);\n        assert!(ctx_complete.validate_for_type(\u0026DocumentType::Adr).is_ok());\n    }\n\n    #[test]\n    fn test_vision_and_task_validation() {\n        let ctx = DocumentContext::new(\"Test Document\".to_string());\n\n        // Vision and Task have no additional requirements\n        assert!(ctx.validate_for_type(\u0026DocumentType::Vision).is_ok());\n        assert!(ctx.validate_for_type(\u0026DocumentType::Task).is_ok());\n    }\n\n    #[test]\n    fn test_builder_pattern() {\n        let ctx = DocumentContext::new(\"Test Document\".to_string())\n            .with_parent(\"Parent Document\".to_string())\n            .with_blocked_by(vec![\"Blocker 1\".to_string(), \"Blocker 2\".to_string()])\n            .with_stakeholders(vec![\"Alice\".to_string(), \"Bob\".to_string()]);\n\n        assert_eq!(ctx.parent_title, Some(\"Parent Document\".to_string()));\n        assert_eq!(ctx.blocked_by.len(), 2);\n        assert_eq!(ctx.stakeholders.len(), 2);\n    }\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":52}},{"line":51,"address":[],"length":0,"stats":{"Line":52}},{"line":52,"address":[],"length":0,"stats":{"Line":52}},{"line":60,"address":[],"length":0,"stats":{"Line":52}},{"line":62,"address":[],"length":0,"stats":{"Line":52}},{"line":72,"address":[],"length":0,"stats":{"Line":67}},{"line":73,"address":[],"length":0,"stats":{"Line":67}},{"line":75,"address":[],"length":0,"stats":{"Line":15}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":28}},{"line":104,"address":[],"length":0,"stats":{"Line":60}},{"line":108,"address":[],"length":0,"stats":{"Line":67}},{"line":109,"address":[],"length":0,"stats":{"Line":67}},{"line":112,"address":[],"length":0,"stats":{"Line":3593}},{"line":115,"address":[],"length":0,"stats":{"Line":313}},{"line":121,"address":[],"length":0,"stats":{"Line":10}},{"line":122,"address":[],"length":0,"stats":{"Line":10}},{"line":123,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":6}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":7}},{"line":147,"address":[],"length":0,"stats":{"Line":7}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":151,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":4}}],"covered":47,"coverable":52},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","core.rs"],"content":"//! Core document management functions for the Metis methodology\n//!\n//! This module provides the main public API for document creation, validation,\n//! and rendering. It re-exports types and functions from specialized modules.\n\n// Re-export main types and functions\npub use crate::context::{Complexity, DocumentContext, RiskLevel};\npub use crate::exit_criteria::{\n    validate_exit_criteria, validate_exit_criteria_content, ExitCriteriaResult,\n};\npub use crate::phases::{can_transition_to_phase, transition_phase};\npub use crate::render::render;\npub use crate::template::TemplateEngine;\npub use crate::validation::{validate, validate_content, ValidationResult};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","database","mod.rs"],"content":"//! Database operations for document storage and retrieval\n\npub mod query;\n\nuse crate::{Document, DocumentType, MetisError, Result};\nuse chrono::{DateTime, Utc};\nuse gray_matter;\nuse sha2::{Digest, Sha256};\nuse sqlx::{migrate::MigrateDatabase, SqlitePool};\nuse std::fs;\nuse std::path::Path;\n\n// Re-export query types\npub use query::{QueryService, Relationship, RelationshipDirection, SearchResult};\n\n#[derive(Clone)]\npub struct DocumentStore {\n    pool: SqlitePool,\n}\n\nimpl DocumentStore {\n    /// Create a new DocumentStore with automatic database creation and migrations\n    pub async fn new(database_url: \u0026str) -\u003e Result\u003cSelf\u003e {\n        // Create database if it doesn't exist\n        if !sqlx::Sqlite::database_exists(database_url).await? {\n            sqlx::Sqlite::create_database(database_url).await?;\n        }\n\n        let pool = SqlitePool::connect(database_url).await?;\n\n        // Run migrations\n        sqlx::migrate!(\"./src/migrations\").run(\u0026pool).await?;\n\n        Ok(Self { pool })\n    }\n\n    /// Create a DocumentStore from an existing pool (useful for testing)\n    pub async fn from_pool(pool: SqlitePool) -\u003e Result\u003cSelf\u003e {\n        let store = Self { pool };\n\n        // Run migrations\n        sqlx::migrate!(\"./src/migrations\").run(\u0026store.pool).await?;\n\n        Ok(store)\n    }\n\n    /// Get the underlying database pool\n    pub fn pool(\u0026self) -\u003e \u0026SqlitePool {\n        \u0026self.pool\n    }\n\n    /// Create a QueryService using this DocumentStore's database pool\n    pub fn query_service(\u0026self) -\u003e QueryService {\n        QueryService::new(self.pool.clone())\n    }\n\n    /// Store a document by reading and parsing the file at the given path\n    pub async fn store_document(\u0026self, filepath: \u0026Path) -\u003e Result\u003cDocument\u003e {\n        // Read file contents\n        let raw_content = fs::read_to_string(filepath).map_err(MetisError::Io)?;\n\n        // Parse frontmatter and content\n        let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026raw_content);\n\n        // Extract frontmatter as JSON\n        let frontmatter: serde_json::Value = if let Some(data) = parsed.data {\n            // gray_matter returns a Pod which we need to convert to serde_json::Value\n            match data {\n                gray_matter::Pod::Hash(map) =\u003e {\n                    let mut json_map = serde_json::Map::new();\n                    for (key, value) in map {\n                        let json_value = match value {\n                            gray_matter::Pod::String(s) =\u003e serde_json::Value::String(s),\n                            gray_matter::Pod::Integer(i) =\u003e {\n                                serde_json::Value::Number(serde_json::Number::from(i))\n                            }\n                            gray_matter::Pod::Float(f) =\u003e serde_json::Value::Number(\n                                serde_json::Number::from_f64(f)\n                                    .unwrap_or(serde_json::Number::from(0)),\n                            ),\n                            gray_matter::Pod::Boolean(b) =\u003e serde_json::Value::Bool(b),\n                            gray_matter::Pod::Array(arr) =\u003e {\n                                let json_arr: Vec\u003cserde_json::Value\u003e = arr\n                                    .into_iter()\n                                    .map(|item| match item {\n                                        gray_matter::Pod::String(s) =\u003e serde_json::Value::String(s),\n                                        _ =\u003e serde_json::Value::String(format!(\"{:?}\", item)),\n                                    })\n                                    .collect();\n                                serde_json::Value::Array(json_arr)\n                            }\n                            _ =\u003e serde_json::Value::String(format!(\"{:?}\", value)),\n                        };\n                        json_map.insert(key, json_value);\n                    }\n                    serde_json::Value::Object(json_map)\n                }\n                _ =\u003e serde_json::Value::Object(serde_json::Map::new()),\n            }\n        } else {\n            serde_json::Value::Object(serde_json::Map::new())\n        };\n\n        // Calculate content hash\n        let mut hasher = Sha256::new();\n        hasher.update(raw_content.as_bytes());\n        let content_hash = format!(\"{:x}\", hasher.finalize());\n\n        // Extract document metadata from frontmatter\n        let id = frontmatter\n            .get(\"id\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| MetisError::MissingRequiredField {\n                field: \"id\".to_string(),\n            })?\n            .to_string();\n\n        let document_type_str = frontmatter\n            .get(\"level\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| MetisError::MissingRequiredField {\n                field: \"level\".to_string(),\n            })?;\n        let document_type: DocumentType = document_type_str.parse()?;\n\n        let status = frontmatter\n            .get(\"status\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| MetisError::MissingRequiredField {\n                field: \"status\".to_string(),\n            })?\n            .to_string();\n\n        // Force parent_id to None for vision and ADR documents since they can't have parents\n        let parent_id = if document_type_str == \"vision\" || document_type_str == \"adr\" {\n            None\n        } else {\n            frontmatter\n                .get(\"parent\")\n                .and_then(|v| if v.is_null() { None } else { v.as_str() })\n                .filter(|s| !s.trim().is_empty())\n                .map(|s| s.to_string())\n        };\n\n        let exit_criteria_met = frontmatter\n            .get(\"exit_criteria_met\")\n            .and_then(|v| v.as_bool())\n            .unwrap_or(false);\n\n        let created_at = frontmatter\n            .get(\"created_at\")\n            .and_then(|v| v.as_str())\n            .and_then(|s| DateTime::parse_from_rfc3339(s).ok())\n            .map(|dt| dt.with_timezone(\u0026Utc))\n            .unwrap_or_else(Utc::now);\n\n        let updated_at = frontmatter\n            .get(\"updated_at\")\n            .and_then(|v| v.as_str())\n            .and_then(|s| DateTime::parse_from_rfc3339(s).ok())\n            .map(|dt| dt.with_timezone(\u0026Utc))\n            .unwrap_or_else(Utc::now);\n\n        // Get file metadata for new fields\n        let metadata = std::fs::metadata(filepath).map_err(MetisError::Io)?;\n        let file_size = metadata.len() as i64;\n        let file_modified_at = metadata\n            .modified()\n            .map_err(MetisError::Io)?\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_secs_f64();\n\n        // Create Document struct\n        let document = Document {\n            id: id.clone(),\n            filepath: filepath.to_string_lossy().to_string(),\n            document_type: document_type.clone(),\n            level: document_type,\n            status,\n            parent_id,\n            created_at,\n            updated_at,\n            content_hash,\n            frontmatter: frontmatter.clone(),\n            exit_criteria_met,\n            content: Some(parsed.content),\n            file_size: Some(file_size),\n            file_modified_at: Some(file_modified_at),\n        };\n\n        // Store in database - create bindings to avoid temporary value issues\n        let doc_type_str = document.document_type.to_string();\n        let level_str = document.level.to_string();\n        let created_at_timestamp = document.created_at.timestamp_millis() as f64 / 1000.0;\n        let updated_at_timestamp = document.updated_at.timestamp_millis() as f64 / 1000.0;\n        let frontmatter_json = serde_json::to_string(\u0026document.frontmatter)?;\n\n        sqlx::query!(\n            r#\"\n            INSERT OR REPLACE INTO documents \n            (id, filepath, document_type, level, status, parent_id, \n             created_at, updated_at, content_hash, frontmatter_json, \n             exit_criteria_met, content, file_size, file_modified_at)\n            VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14)\n            \"#,\n            document.id,\n            document.filepath,\n            doc_type_str,\n            level_str,\n            document.status,\n            document.parent_id,\n            created_at_timestamp,\n            updated_at_timestamp,\n            document.content_hash,\n            frontmatter_json,\n            document.exit_criteria_met,\n            document.content,\n            document.file_size,\n            document.file_modified_at\n        )\n        .execute(\u0026self.pool)\n        .await?;\n\n        // Extract and store properties for efficient queries\n        self.update_properties(\u0026document.id, \u0026frontmatter).await?;\n\n        Ok(document)\n    }\n\n    /// Get a document by ID\n    pub async fn get_document(\u0026self, document_id: \u0026str) -\u003e Result\u003cOption\u003cDocument\u003e\u003e {\n        let record = sqlx::query!(\n            r#\"\n            SELECT id, filepath, document_type, level, status, parent_id, \n                   created_at, updated_at, content_hash, frontmatter_json, \n                   exit_criteria_met, content, file_size, file_modified_at\n            FROM documents \n            WHERE id = ?\n            \"#,\n            document_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await?;\n\n        if let Some(row) = record {\n            let document_type: DocumentType = row.document_type.parse()?;\n            let level: DocumentType = row.level.parse()?;\n            let frontmatter: serde_json::Value = serde_json::from_str(\u0026row.frontmatter_json)?;\n            let created_at =\n                DateTime::from_timestamp(row.created_at as i64, 0).unwrap_or_else(Utc::now);\n            let updated_at =\n                DateTime::from_timestamp(row.updated_at as i64, 0).unwrap_or_else(Utc::now);\n\n            Ok(Some(Document {\n                id: row.id.unwrap_or_default(),\n                filepath: row.filepath,\n                document_type,\n                level,\n                status: row.status,\n                parent_id: row.parent_id,\n                created_at,\n                updated_at,\n                content_hash: row.content_hash,\n                frontmatter,\n                exit_criteria_met: row.exit_criteria_met.unwrap_or(false),\n                content: row.content,\n                file_size: row.file_size,\n                file_modified_at: row.file_modified_at,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Update an existing document by re-reading the file\n    pub async fn update_document(\u0026self, filepath: \u0026Path) -\u003e Result\u003cDocument\u003e {\n        // For updates, we just re-store the document which will replace it\n        self.store_document(filepath).await\n    }\n\n    /// Delete a document by ID\n    pub async fn delete_document(\u0026self, document_id: \u0026str) -\u003e Result\u003cbool\u003e {\n        let result = sqlx::query!(\"DELETE FROM documents WHERE id = ?\", document_id)\n            .execute(\u0026self.pool)\n            .await?;\n\n        Ok(result.rows_affected() \u003e 0)\n    }\n\n    /// Extract frontmatter properties and store them for efficient querying\n    async fn update_properties(\n        \u0026self,\n        document_id: \u0026str,\n        frontmatter: \u0026serde_json::Value,\n    ) -\u003e Result\u003c()\u003e {\n        // First, delete existing properties for this document\n        sqlx::query!(\n            \"DELETE FROM document_properties WHERE document_id = ?\",\n            document_id\n        )\n        .execute(\u0026self.pool)\n        .await?;\n\n        // Extract properties from frontmatter\n        if let serde_json::Value::Object(map) = frontmatter {\n            for (key, value) in map {\n                let (prop_value, prop_type) = match value {\n                    serde_json::Value::String(s) =\u003e (s.clone(), \"text\".to_string()),\n                    serde_json::Value::Number(n) =\u003e (n.to_string(), \"number\".to_string()),\n                    serde_json::Value::Bool(b) =\u003e (b.to_string(), \"boolean\".to_string()),\n                    serde_json::Value::Array(_) =\u003e (value.to_string(), \"array\".to_string()),\n                    _ =\u003e (value.to_string(), \"text\".to_string()),\n                };\n\n                sqlx::query!(\n                    r#\"\n                    INSERT INTO document_properties \n                    (document_id, property_name, property_value, property_type)\n                    VALUES (?1, ?2, ?3, ?4)\n                    \"#,\n                    document_id,\n                    key,\n                    prop_value,\n                    prop_type\n                )\n                .execute(\u0026self.pool)\n                .await?;\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use sqlx::SqlitePool;\n    use std::fs;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    async fn create_test_store() -\u003e DocumentStore {\n        let pool = SqlitePool::connect(\":memory:\").await.unwrap();\n        DocumentStore::from_pool(pool).await.unwrap()\n    }\n\n    fn create_test_document_file(content: \u0026str) -\u003e NamedTempFile {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        temp_file.write_all(content.as_bytes()).unwrap();\n        temp_file.flush().unwrap();\n        temp_file\n    }\n\n    #[tokio::test]\n    async fn test_document_store_creation() {\n        let pool = SqlitePool::connect(\":memory:\").await.unwrap();\n        let store = DocumentStore::from_pool(pool).await.unwrap();\n\n        // Verify tables were created by checking the schema\n        let tables: Vec\u003c(String,)\u003e =\n            sqlx::query_as(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\")\n                .fetch_all(store.pool())\n                .await\n                .unwrap();\n\n        let table_names: Vec\u003cString\u003e = tables.into_iter().map(|(name,)| name).collect();\n\n        assert!(table_names.contains(\u0026\"documents\".to_string()));\n        assert!(table_names.contains(\u0026\"document_relationships\".to_string()));\n        assert!(table_names.contains(\u0026\"document_properties\".to_string()));\n        assert!(table_names.contains(\u0026\"document_search\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_store_document() {\n        let store = create_test_store().await;\n\n        let document_content = r##\"---\nid: test-vision-document\nlevel: vision\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\ntags:\n  - \"#vision\"\n  - \"#phase/shaping\"\n---\n\n# Test Vision Document\n\nThis is a test vision document for testing purposes.\n\n## Goals\n\n- Test goal 1\n- Test goal 2\n\"##;\n\n        let temp_file = create_test_document_file(document_content);\n        let result = store.store_document(temp_file.path()).await;\n\n        assert!(result.is_ok());\n        let document = result.unwrap();\n\n        assert_eq!(document.id, \"test-vision-document\");\n        assert_eq!(document.document_type, DocumentType::Vision);\n        assert_eq!(document.status, \"draft\");\n        // Phase is now in tags, not a separate field\n        assert!(document.content.is_some());\n        assert!(document\n            .content\n            .as_ref()\n            .unwrap()\n            .contains(\"Test Vision Document\"));\n    }\n\n    #[tokio::test]\n    async fn test_get_document() {\n        let store = create_test_store().await;\n\n        let document_content = r#\"---\nid: test-get-document\nlevel: strategy\nstatus: active\nphase: design\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\n---\n\n# Test Strategy Document\n\nContent for get test.\n\"#;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Store the document first\n        store.store_document(temp_file.path()).await.unwrap();\n\n        // Now get it\n        let result = store.get_document(\"test-get-document\").await;\n        assert!(result.is_ok());\n\n        let document = result.unwrap();\n        assert!(document.is_some());\n\n        let doc = document.unwrap();\n        assert_eq!(doc.id, \"test-get-document\");\n        assert_eq!(doc.document_type, DocumentType::Strategy);\n        assert_eq!(doc.status, \"active\");\n        // Phase is now in tags, not a separate field\n    }\n\n    #[tokio::test]\n    async fn test_get_nonexistent_document() {\n        let store = create_test_store().await;\n\n        let result = store.get_document(\"nonexistent-document\").await;\n        assert!(result.is_ok());\n        assert!(result.unwrap().is_none());\n    }\n\n    #[tokio::test]\n    async fn test_update_document() {\n        let store = create_test_store().await;\n\n        let initial_content = r#\"---\nid: test-update-document\nlevel: task\nstatus: todo\nphase: todo\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\n---\n\n# Initial Content\n\"#;\n\n        let updated_content = r#\"---\nid: test-update-document\nlevel: task\nstatus: doing\nphase: doing\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T19:00:00Z\nexit_criteria_met: false\n---\n\n# Updated Content\n\nThis content has been updated.\n\"#;\n\n        let temp_file = create_test_document_file(initial_content);\n\n        // Store initial document\n        let initial_doc = store.store_document(temp_file.path()).await.unwrap();\n        assert_eq!(initial_doc.status, \"todo\");\n\n        // Update the file content\n        fs::write(temp_file.path(), updated_content).unwrap();\n\n        // Update the document\n        let updated_doc = store.update_document(temp_file.path()).await.unwrap();\n        assert_eq!(updated_doc.status, \"doing\");\n        assert!(updated_doc\n            .content\n            .as_ref()\n            .unwrap()\n            .contains(\"Updated Content\"));\n\n        // Verify it was updated in the database\n        let retrieved_doc = store\n            .get_document(\"test-update-document\")\n            .await\n            .unwrap()\n            .unwrap();\n        assert_eq!(retrieved_doc.status, \"doing\");\n    }\n\n    #[tokio::test]\n    async fn test_delete_document() {\n        let store = create_test_store().await;\n\n        let document_content = r#\"---\nid: test-delete-document\nlevel: adr\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\n---\n\n# Document to Delete\n\"#;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Store the document\n        store.store_document(temp_file.path()).await.unwrap();\n\n        // Verify it exists\n        let doc = store.get_document(\"test-delete-document\").await.unwrap();\n        assert!(doc.is_some());\n\n        // Delete it\n        let deleted = store.delete_document(\"test-delete-document\").await.unwrap();\n        assert!(deleted);\n\n        // Verify it's gone\n        let doc_after = store.get_document(\"test-delete-document\").await.unwrap();\n        assert!(doc_after.is_none());\n\n        // Try to delete again - should return false\n        let deleted_again = store.delete_document(\"test-delete-document\").await.unwrap();\n        assert!(!deleted_again);\n    }\n\n    #[tokio::test]\n    async fn test_properties_extraction() {\n        let store = create_test_store().await;\n\n        let document_content = r##\"---\nid: test-properties-document\nlevel: initiative\nstatus: active\nphase: design\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\ntechnical_lead: john.doe\nestimated_complexity: l\npriority: high\ntags:\n  - \"#initiative\"\n  - \"#phase/design\"\n---\n\n# Test Properties Document\n\"##;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Store the document\n        store.store_document(temp_file.path()).await.unwrap();\n\n        // Check that properties were extracted\n        let properties: Vec\u003c(String, String, String)\u003e = sqlx::query_as(\n            \"SELECT property_name, property_value, property_type FROM document_properties WHERE document_id = ? ORDER BY property_name\"\n        )\n        .bind(\"test-properties-document\")\n        .fetch_all(store.pool())\n        .await\n        .unwrap();\n\n        // Should have extracted multiple properties\n        assert!(!properties.is_empty());\n\n        // Check for specific properties\n        let technical_lead = properties\n            .iter()\n            .find(|(name, _, _)| name == \"technical_lead\");\n        assert!(technical_lead.is_some());\n        assert_eq!(technical_lead.unwrap().1, \"john.doe\");\n\n        let complexity = properties\n            .iter()\n            .find(|(name, _, _)| name == \"estimated_complexity\");\n        assert!(complexity.is_some());\n        assert_eq!(complexity.unwrap().1, \"l\");\n    }\n\n    #[tokio::test]\n    async fn test_missing_required_fields() {\n        let store = create_test_store().await;\n\n        let document_content = r#\"---\nstatus: draft\nphase: shaping\n---\n\n# Document Missing Required Fields\n\"#;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Should fail due to missing id field\n        let result = store.store_document(temp_file.path()).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::MissingRequiredField { field }) = result {\n            assert_eq!(field, \"id\");\n        } else {\n            panic!(\"Expected MissingRequiredField error\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_content_hash_calculation() {\n        let store = create_test_store().await;\n\n        let document_content = r#\"---\nid: test-hash-document\nlevel: vision\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\n---\n\n# Test Hash Document\n\nContent for hash testing.\n\"#;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Store the document\n        let doc1 = store.store_document(temp_file.path()).await.unwrap();\n\n        // Store the same document again\n        let doc2 = store.store_document(temp_file.path()).await.unwrap();\n\n        // Content hashes should be the same\n        assert_eq!(doc1.content_hash, doc2.content_hash);\n        assert!(!doc1.content_hash.is_empty());\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":66}},{"line":25,"address":[],"length":0,"stats":{"Line":33}},{"line":26,"address":[],"length":0,"stats":{"Line":21}},{"line":29,"address":[],"length":0,"stats":{"Line":66}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":33}},{"line":38,"address":[],"length":0,"stats":{"Line":40}},{"line":39,"address":[],"length":0,"stats":{"Line":20}},{"line":42,"address":[],"length":0,"stats":{"Line":20}},{"line":44,"address":[],"length":0,"stats":{"Line":20}},{"line":48,"address":[],"length":0,"stats":{"Line":24}},{"line":49,"address":[],"length":0,"stats":{"Line":24}},{"line":53,"address":[],"length":0,"stats":{"Line":20}},{"line":54,"address":[],"length":0,"stats":{"Line":20}},{"line":58,"address":[],"length":0,"stats":{"Line":74}},{"line":60,"address":[],"length":0,"stats":{"Line":74}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":37}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":37}},{"line":70,"address":[],"length":0,"stats":{"Line":37}},{"line":71,"address":[],"length":0,"stats":{"Line":663}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":220}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":36}},{"line":82,"address":[],"length":0,"stats":{"Line":36}},{"line":83,"address":[],"length":0,"stats":{"Line":36}},{"line":85,"address":[],"length":0,"stats":{"Line":74}},{"line":86,"address":[],"length":0,"stats":{"Line":38}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":36}},{"line":92,"address":[],"length":0,"stats":{"Line":20}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":36}},{"line":112,"address":[],"length":0,"stats":{"Line":36}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":36}},{"line":120,"address":[],"length":0,"stats":{"Line":36}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":36}},{"line":126,"address":[],"length":0,"stats":{"Line":36}},{"line":128,"address":[],"length":0,"stats":{"Line":36}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":25}},{"line":136,"address":[],"length":0,"stats":{"Line":12}},{"line":138,"address":[],"length":0,"stats":{"Line":24}},{"line":140,"address":[],"length":0,"stats":{"Line":51}},{"line":141,"address":[],"length":0,"stats":{"Line":9}},{"line":142,"address":[],"length":0,"stats":{"Line":9}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":36}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":36}},{"line":153,"address":[],"length":0,"stats":{"Line":36}},{"line":154,"address":[],"length":0,"stats":{"Line":36}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":36}},{"line":160,"address":[],"length":0,"stats":{"Line":36}},{"line":161,"address":[],"length":0,"stats":{"Line":36}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":36}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":36}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":36}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":8}},{"line":226,"address":[],"length":0,"stats":{"Line":30}},{"line":228,"address":[],"length":0,"stats":{"Line":26}},{"line":232,"address":[],"length":0,"stats":{"Line":18}},{"line":233,"address":[],"length":0,"stats":{"Line":18}},{"line":241,"address":[],"length":0,"stats":{"Line":9}},{"line":243,"address":[],"length":0,"stats":{"Line":9}},{"line":244,"address":[],"length":0,"stats":{"Line":9}},{"line":246,"address":[],"length":0,"stats":{"Line":6}},{"line":247,"address":[],"length":0,"stats":{"Line":6}},{"line":248,"address":[],"length":0,"stats":{"Line":6}},{"line":249,"address":[],"length":0,"stats":{"Line":6}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":3}},{"line":277,"address":[],"length":0,"stats":{"Line":2}},{"line":279,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":8}},{"line":284,"address":[],"length":0,"stats":{"Line":8}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":4}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":28}},{"line":298,"address":[],"length":0,"stats":{"Line":28}},{"line":300,"address":[],"length":0,"stats":{"Line":28}},{"line":302,"address":[],"length":0,"stats":{"Line":28}},{"line":303,"address":[],"length":0,"stats":{"Line":30}},{"line":306,"address":[],"length":0,"stats":{"Line":52}},{"line":307,"address":[],"length":0,"stats":{"Line":420}},{"line":308,"address":[],"length":0,"stats":{"Line":394}},{"line":309,"address":[],"length":0,"stats":{"Line":156}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":311,"address":[],"length":0,"stats":{"Line":26}},{"line":312,"address":[],"length":0,"stats":{"Line":14}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":197}},{"line":322,"address":[],"length":0,"stats":{"Line":197}},{"line":323,"address":[],"length":0,"stats":{"Line":197}},{"line":324,"address":[],"length":0,"stats":{"Line":197}},{"line":325,"address":[],"length":0,"stats":{"Line":197}},{"line":327,"address":[],"length":0,"stats":{"Line":197}},{"line":328,"address":[],"length":0,"stats":{"Line":197}},{"line":332,"address":[],"length":0,"stats":{"Line":26}}],"covered":93,"coverable":167},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","database","query.rs"],"content":"//! Query operations for document discovery and search\n\nuse crate::{Document, DocumentType, RelationshipType, Result};\nuse sqlx::SqlitePool;\n\n/// Search result with ranking and snippet\n#[derive(Debug, Clone, serde::Serialize)]\npub struct SearchResult {\n    pub document: Document,\n    pub rank: f64,\n    pub snippet: String,\n}\n\n/// Direction for relationship queries\n#[derive(Debug, Clone)]\npub enum RelationshipDirection {\n    /// Relationships where this document is the source (outgoing)\n    Outgoing,\n    /// Relationships where this document is the target (incoming)\n    Incoming,\n    /// All relationships involving this document\n    Both,\n}\n\n/// Document relationship with metadata\n#[derive(Debug, Clone, serde::Serialize)]\npub struct Relationship {\n    pub from_id: String,\n    pub to_id: String,\n    pub relationship_type: RelationshipType,\n    pub created_at: chrono::DateTime\u003cchrono::Utc\u003e,\n}\n\n/// Query service for document operations\n#[derive(Clone)]\npub struct QueryService {\n    pool: SqlitePool,\n}\n\nimpl QueryService {\n    /// Create a new QueryService with the given database pool\n    pub fn new(pool: SqlitePool) -\u003e Self {\n        Self { pool }\n    }\n\n    /// Find documents by document type\n    pub async fn find_documents_by_type(\u0026self, doc_type: DocumentType) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        self.find_documents_by_type_paginated(doc_type, None, None)\n            .await\n    }\n\n    /// Find documents by document type with pagination\n    pub async fn find_documents_by_type_paginated(\n        \u0026self,\n        doc_type: DocumentType,\n        limit: Option\u003cusize\u003e,\n        offset: Option\u003cusize\u003e,\n    ) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let doc_type_str = doc_type.to_string();\n\n        let sql = format!(\n            r#\"\n            SELECT id, filepath, document_type, level, status, parent_id, \n                   created_at, updated_at, content_hash, frontmatter_json, \n                   exit_criteria_met, content, file_size, file_modified_at\n            FROM documents \n            WHERE document_type = ?\n            ORDER BY updated_at DESC\n            {}\n            \"#,\n            match (limit, offset) {\n                (Some(l), Some(o)) =\u003e format!(\"LIMIT {} OFFSET {}\", l, o),\n                (Some(l), None) =\u003e format!(\"LIMIT {}\", l),\n                (None, Some(o)) =\u003e format!(\"OFFSET {}\", o),\n                (None, None) =\u003e String::new(),\n            }\n        );\n\n        let records = sqlx::query(\u0026sql)\n            .bind(\u0026doc_type_str)\n            .fetch_all(\u0026self.pool)\n            .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            use sqlx::Row;\n            documents.push(self.record_to_document(\n                row.try_get::\u003cOption\u003cString\u003e, _\u003e(\"id\")?.unwrap_or_default(),\n                row.try_get(\"filepath\")?,\n                row.try_get(\"document_type\")?,\n                row.try_get(\"level\")?,\n                row.try_get(\"status\")?,\n                row.try_get(\"parent_id\")?,\n                row.try_get(\"created_at\")?,\n                row.try_get(\"updated_at\")?,\n                row.try_get(\"content_hash\")?,\n                row.try_get(\"frontmatter_json\")?,\n                row.try_get(\"exit_criteria_met\")?,\n                row.try_get(\"content\")?,\n                row.try_get(\"file_size\")?,\n                row.try_get(\"file_modified_at\")?,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Find documents by phase tag (e.g., \"draft\", \"review\", \"published\")\n    pub async fn find_documents_by_phase(\u0026self, phase: \u0026str) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let phase_tag = format!(\"#phase/{}\", phase);\n        let search_pattern = format!(\"%{}%\", phase_tag);\n        let records = sqlx::query!(\n            r#\"\n            SELECT id, filepath, document_type, level, status, parent_id, \n                   created_at, updated_at, content_hash, frontmatter_json, \n                   exit_criteria_met, content, file_size, file_modified_at\n            FROM documents \n            WHERE frontmatter_json LIKE ?\n            ORDER BY updated_at DESC\n            \"#,\n            search_pattern\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            documents.push(self.record_to_document(\n                row.id.unwrap_or_default(),\n                row.filepath,\n                row.document_type,\n                row.level,\n                row.status,\n                row.parent_id,\n                row.created_at,\n                row.updated_at,\n                row.content_hash,\n                row.frontmatter_json,\n                row.exit_criteria_met,\n                row.content,\n                row.file_size,\n                row.file_modified_at,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Find documents by parent ID\n    pub async fn find_documents_by_parent(\u0026self, parent_id: \u0026str) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let records = sqlx::query!(\n            r#\"\n            SELECT id, filepath, document_type, level, status, parent_id, \n                   created_at, updated_at, content_hash, frontmatter_json, \n                   exit_criteria_met, content, file_size, file_modified_at\n            FROM documents \n            WHERE parent_id = ?\n            ORDER BY updated_at DESC\n            \"#,\n            parent_id\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            documents.push(self.record_to_document(\n                row.id.unwrap_or_default(),\n                row.filepath,\n                row.document_type,\n                row.level,\n                row.status,\n                row.parent_id,\n                row.created_at,\n                row.updated_at,\n                row.content_hash,\n                row.frontmatter_json,\n                row.exit_criteria_met,\n                row.content,\n                row.file_size,\n                row.file_modified_at,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Find orphaned documents (documents with parent_id that doesn't exist)\n    pub async fn find_orphaned_documents(\u0026self) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let records = sqlx::query!(\n            r#\"\n            SELECT d.id, d.filepath, d.document_type, d.level, d.status, d.parent_id, \n                   d.created_at, d.updated_at, d.content_hash, d.frontmatter_json, \n                   d.exit_criteria_met, d.content, d.file_size, d.file_modified_at\n            FROM documents d\n            LEFT JOIN documents p ON d.parent_id = p.id\n            WHERE d.parent_id IS NOT NULL AND p.id IS NULL\n            ORDER BY d.updated_at DESC\n            \"#\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            documents.push(self.record_to_document(\n                row.id.unwrap_or_default(),\n                row.filepath,\n                row.document_type,\n                row.level,\n                row.status,\n                row.parent_id,\n                row.created_at,\n                row.updated_at,\n                row.content_hash,\n                row.frontmatter_json,\n                row.exit_criteria_met,\n                row.content,\n                row.file_size,\n                row.file_modified_at,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Get all property names used in documents\n    pub async fn get_all_property_names(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let records = sqlx::query!(\n            \"SELECT DISTINCT property_name FROM document_properties ORDER BY property_name\"\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        Ok(records.into_iter().map(|row| row.property_name).collect())\n    }\n\n    /// Get all values for a specific property with usage counts\n    pub async fn get_property_values(\u0026self, prop_name: \u0026str) -\u003e Result\u003cVec\u003c(String, usize)\u003e\u003e {\n        let records = sqlx::query!(\n            r#\"\n            SELECT property_value, COUNT(*) as count \n            FROM document_properties \n            WHERE property_name = ? \n            GROUP BY property_value \n            ORDER BY count DESC, property_value\n            \"#,\n            prop_name\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        Ok(records\n            .into_iter()\n            .map(|row| (row.property_value.unwrap_or_default(), row.count as usize))\n            .collect())\n    }\n\n    /// Search documents by property value (equals only for now)\n    pub async fn search_by_property(\u0026self, prop_name: \u0026str, value: \u0026str) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let records = sqlx::query!(\n            r#\"\n            SELECT DISTINCT d.id, d.filepath, d.document_type, d.level, d.status, d.parent_id, \n                           d.created_at, d.updated_at, d.content_hash, d.frontmatter_json, \n                           d.exit_criteria_met, d.content, d.file_size, d.file_modified_at\n            FROM documents d\n            JOIN document_properties p ON d.id = p.document_id\n            WHERE p.property_name = ? AND p.property_value = ?\n            ORDER BY d.updated_at DESC\n            \"#,\n            prop_name,\n            value\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            documents.push(self.record_to_document(\n                row.id.unwrap_or_default(),\n                row.filepath,\n                row.document_type,\n                row.level,\n                row.status,\n                row.parent_id,\n                row.created_at,\n                row.updated_at,\n                row.content_hash,\n                row.frontmatter_json,\n                row.exit_criteria_met,\n                row.content,\n                row.file_size,\n                row.file_modified_at,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Full-text search using FTS5 with ranking and snippets\n    pub async fn search_content(\u0026self, query: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n        use sqlx::Row;\n\n        let records = sqlx::query(\n            r#\"\n            SELECT d.id, d.filepath, d.document_type, d.level, d.status, d.parent_id, \n                   d.created_at, d.updated_at, d.content_hash, d.frontmatter_json, \n                   d.exit_criteria_met, d.content, d.file_size, d.file_modified_at,\n                   bm25(document_search) as rank,\n                   snippet(document_search, -1, '\u003cmark\u003e', '\u003c/mark\u003e', '...', 64) as snippet\n            FROM document_search\n            JOIN documents d ON document_search.document_id = d.id\n            WHERE document_search MATCH ?\n            ORDER BY rank\n            LIMIT ?\n            \"#,\n        )\n        .bind(query)\n        .bind(limit as i64)\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut results = Vec::new();\n        for row in records {\n            let document = self.record_to_document(\n                row.try_get::\u003cOption\u003cString\u003e, _\u003e(\"id\")?.unwrap_or_default(),\n                row.try_get(\"filepath\")?,\n                row.try_get(\"document_type\")?,\n                row.try_get(\"level\")?,\n                row.try_get(\"status\")?,\n                row.try_get(\"parent_id\")?,\n                row.try_get(\"created_at\")?,\n                row.try_get(\"updated_at\")?,\n                row.try_get(\"content_hash\")?,\n                row.try_get(\"frontmatter_json\")?,\n                row.try_get(\"exit_criteria_met\")?,\n                row.try_get(\"content\")?,\n                row.try_get(\"file_size\")?,\n                row.try_get(\"file_modified_at\")?,\n            )?;\n\n            let search_result = SearchResult {\n                document,\n                rank: row.try_get::\u003cf64, _\u003e(\"rank\").unwrap_or(0.0),\n                snippet: row.try_get::\u003cString, _\u003e(\"snippet\").unwrap_or_default(),\n            };\n            results.push(search_result);\n        }\n        Ok(results)\n    }\n\n    /// Get relationships for a document\n    pub async fn get_relationships(\n        \u0026self,\n        document_id: \u0026str,\n        direction: RelationshipDirection,\n    ) -\u003e Result\u003cVec\u003cRelationship\u003e\u003e {\n        use sqlx::Row;\n\n        let (sql, bind_params): (String, Vec\u003c\u0026str\u003e) = match direction {\n            RelationshipDirection::Outgoing =\u003e (\n                \"SELECT from_id, to_id, relationship_type, created_at FROM document_relationships WHERE from_id = ? ORDER BY created_at DESC\".to_string(),\n                vec![document_id]\n            ),\n            RelationshipDirection::Incoming =\u003e (\n                \"SELECT from_id, to_id, relationship_type, created_at FROM document_relationships WHERE to_id = ? ORDER BY created_at DESC\".to_string(),\n                vec![document_id]\n            ),\n            RelationshipDirection::Both =\u003e (\n                \"SELECT from_id, to_id, relationship_type, created_at FROM document_relationships WHERE from_id = ? OR to_id = ? ORDER BY created_at DESC\".to_string(),\n                vec![document_id, document_id]\n            ),\n        };\n\n        let mut query = sqlx::query(\u0026sql);\n        for param in bind_params {\n            query = query.bind(param);\n        }\n\n        let records = query.fetch_all(\u0026self.pool).await?;\n\n        let mut relationships = Vec::new();\n        for row in records {\n            let relationship_type_str: String = row.try_get(\"relationship_type\")?;\n            let relationship_type: RelationshipType = match relationship_type_str.as_str() {\n                \"parent\" =\u003e RelationshipType::Parent,\n                \"blocks\" =\u003e RelationshipType::Blocks,\n                \"supersedes\" =\u003e RelationshipType::Supersedes,\n                \"related\" =\u003e RelationshipType::Related,\n                _ =\u003e continue, // Skip unknown relationship types\n            };\n\n            let created_at_timestamp: f64 = row.try_get(\"created_at\")?;\n            let created_at = chrono::DateTime::from_timestamp(created_at_timestamp as i64, 0)\n                .unwrap_or_else(chrono::Utc::now);\n\n            relationships.push(Relationship {\n                from_id: row.try_get(\"from_id\")?,\n                to_id: row.try_get(\"to_id\")?,\n                relationship_type,\n                created_at,\n            });\n        }\n\n        Ok(relationships)\n    }\n\n    /// Helper function to convert record fields to Document\n    #[allow(clippy::too_many_arguments)]\n    fn record_to_document(\n        \u0026self,\n        id: String,\n        filepath: String,\n        document_type_str: String,\n        level_str: String,\n        status: String,\n        parent_id: Option\u003cString\u003e,\n        created_at: f64,\n        updated_at: f64,\n        content_hash: String,\n        frontmatter_json: String,\n        exit_criteria_met: Option\u003cbool\u003e,\n        content: Option\u003cString\u003e,\n        file_size: Option\u003ci64\u003e,\n        file_modified_at: Option\u003cf64\u003e,\n    ) -\u003e Result\u003cDocument\u003e {\n        use chrono::{DateTime, Utc};\n\n        let document_type: DocumentType = document_type_str.parse()?;\n        let level: DocumentType = level_str.parse()?;\n        let frontmatter: serde_json::Value = serde_json::from_str(\u0026frontmatter_json)?;\n        let created_at_dt = DateTime::from_timestamp(created_at as i64, 0).unwrap_or_else(Utc::now);\n        let updated_at_dt = DateTime::from_timestamp(updated_at as i64, 0).unwrap_or_else(Utc::now);\n\n        Ok(Document {\n            id,\n            filepath,\n            document_type,\n            level,\n            status,\n            parent_id,\n            created_at: created_at_dt,\n            updated_at: updated_at_dt,\n            content_hash,\n            frontmatter,\n            exit_criteria_met: exit_criteria_met.unwrap_or(false),\n            content,\n            file_size,\n            file_modified_at,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::database::DocumentStore;\n    use sqlx::SqlitePool;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    async fn create_test_setup() -\u003e (DocumentStore, QueryService) {\n        let pool = SqlitePool::connect(\":memory:\").await.unwrap();\n        let store = DocumentStore::from_pool(pool.clone()).await.unwrap();\n        let query_service = QueryService::new(pool);\n        (store, query_service)\n    }\n\n    fn create_test_document_file(content: \u0026str) -\u003e NamedTempFile {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        temp_file.write_all(content.as_bytes()).unwrap();\n        temp_file.flush().unwrap();\n        temp_file\n    }\n\n    #[tokio::test]\n    async fn test_find_documents_by_type() {\n        let (store, query_service) = create_test_setup().await;\n\n        // Create test documents of different types\n        let vision_content = r##\"---\nid: test-vision\nlevel: vision\nstatus: draft\ntags:\n  - \"#phase/shaping\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Vision\n\"##;\n\n        let strategy_content = r##\"---\nid: test-strategy\nlevel: strategy\nstatus: active\ntags:\n  - \"#phase/design\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Strategy\n\"##;\n\n        let vision_file = create_test_document_file(vision_content);\n        let strategy_file = create_test_document_file(strategy_content);\n\n        store.store_document(vision_file.path()).await.unwrap();\n        store.store_document(strategy_file.path()).await.unwrap();\n\n        // Query for vision documents\n        let visions = query_service\n            .find_documents_by_type(DocumentType::Vision)\n            .await\n            .unwrap();\n        assert_eq!(visions.len(), 1);\n        assert_eq!(visions[0].id, \"test-vision\");\n\n        // Query for strategy documents\n        let strategies = query_service\n            .find_documents_by_type(DocumentType::Strategy)\n            .await\n            .unwrap();\n        assert_eq!(strategies.len(), 1);\n        assert_eq!(strategies[0].id, \"test-strategy\");\n    }\n\n    #[tokio::test]\n    async fn test_find_documents_by_phase() {\n        let (store, query_service) = create_test_setup().await;\n\n        let shaping_content = r##\"---\nid: test-shaping\nlevel: task\nstatus: todo\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\ntags:\n  - \"#phase/shaping\"\n---\n\n# Shaping Task\n\"##;\n\n        let design_content = r##\"---\nid: test-design\nlevel: task\nstatus: active\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\ntags:\n  - \"#phase/design\"\n---\n\n# Design Task\n\"##;\n\n        let shaping_file = create_test_document_file(shaping_content);\n        let design_file = create_test_document_file(design_content);\n\n        store.store_document(shaping_file.path()).await.unwrap();\n        store.store_document(design_file.path()).await.unwrap();\n\n        // Query by phase\n        let shaping_docs = query_service\n            .find_documents_by_phase(\"shaping\")\n            .await\n            .unwrap();\n        assert_eq!(shaping_docs.len(), 1);\n        assert_eq!(shaping_docs[0].id, \"test-shaping\");\n\n        let design_docs = query_service\n            .find_documents_by_phase(\"design\")\n            .await\n            .unwrap();\n        assert_eq!(design_docs.len(), 1);\n        assert_eq!(design_docs[0].id, \"test-design\");\n    }\n\n    #[tokio::test]\n    async fn test_search_by_property() {\n        let (store, query_service) = create_test_setup().await;\n\n        let doc_content = r##\"---\nid: test-properties\nlevel: initiative\nstatus: active\ntags:\n  - \"#phase/design\"\ntechnical_lead: john.doe\npriority: high\nestimated_complexity: l\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Properties\n\"##;\n\n        let doc_file = create_test_document_file(doc_content);\n        store.store_document(doc_file.path()).await.unwrap();\n\n        // Search by exact match\n        let results = query_service\n            .search_by_property(\"technical_lead\", \"john.doe\")\n            .await\n            .unwrap();\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].id, \"test-properties\");\n\n        // Search for non-match\n        let results = query_service\n            .search_by_property(\"technical_lead\", \"jane.doe\")\n            .await\n            .unwrap();\n        assert_eq!(results.len(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_property_names_and_values() {\n        let (store, query_service) = create_test_setup().await;\n\n        let doc_content = r##\"---\nid: test-props\nlevel: task\nstatus: todo\ntags:\n  - \"#phase/todo\"\npriority: high\nestimated_hours: 8\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Props\n\"##;\n\n        let doc_file = create_test_document_file(doc_content);\n        store.store_document(doc_file.path()).await.unwrap();\n\n        // Get all property names\n        let prop_names = query_service.get_all_property_names().await.unwrap();\n        assert!(prop_names.contains(\u0026\"priority\".to_string()));\n        assert!(prop_names.contains(\u0026\"estimated_hours\".to_string()));\n\n        // Get values for specific property\n        let priority_values = query_service.get_property_values(\"priority\").await.unwrap();\n        assert_eq!(priority_values.len(), 1);\n        assert_eq!(priority_values[0].0, \"high\");\n        assert_eq!(priority_values[0].1, 1); // count\n    }\n\n    #[tokio::test]\n    async fn test_search_content_fts() {\n        let (store, query_service) = create_test_setup().await;\n\n        let doc1_content = r##\"---\nid: test-search-1\nlevel: vision\nstatus: draft\ntags:\n  - \"#phase/shaping\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Document Management Vision\n\nThis vision outlines our approach to document management using Rust and SQLite.\n\"##;\n\n        let doc2_content = r##\"---\nid: test-search-2\nlevel: strategy\nstatus: active\ntags:\n  - \"#phase/design\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Storage Strategy\n\nOur storage strategy focuses on SQLite performance and indexing capabilities.\n\"##;\n\n        let doc1_file = create_test_document_file(doc1_content);\n        let doc2_file = create_test_document_file(doc2_content);\n\n        store.store_document(doc1_file.path()).await.unwrap();\n        store.store_document(doc2_file.path()).await.unwrap();\n\n        // Search for documents containing \"SQLite\"\n        let results = query_service.search_content(\"SQLite\", 10).await.unwrap();\n        assert_eq!(results.len(), 2);\n\n        // Verify search results have proper structure\n        for result in \u0026results {\n            assert!(!result.document.id.is_empty());\n            // BM25 scores can be negative, so just check it's a valid number\n            assert!(!result.rank.is_nan());\n            assert!(!result.snippet.is_empty());\n        }\n\n        // Search for specific term that should match only one document\n        let mgmt_results = query_service\n            .search_content(\"management\", 10)\n            .await\n            .unwrap();\n        assert_eq!(mgmt_results.len(), 1);\n        assert_eq!(mgmt_results[0].document.id, \"test-search-1\");\n\n        // Search for term that doesn't exist\n        let no_results = query_service\n            .search_content(\"nonexistent\", 10)\n            .await\n            .unwrap();\n        assert_eq!(no_results.len(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_relationships() {\n        let (store, query_service) = create_test_setup().await;\n\n        // Create test documents\n        let doc1_content = r##\"---\nid: parent-doc\nlevel: strategy\nstatus: active\ntags:\n  - \"#phase/design\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Parent Document\n\"##;\n\n        let doc2_content = r##\"---\nid: child-doc\nlevel: task\nstatus: todo\ntags:\n  - \"#phase/todo\"\nparent: parent-doc\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Child Document\n\"##;\n\n        let doc1_file = create_test_document_file(doc1_content);\n        let doc2_file = create_test_document_file(doc2_content);\n\n        store.store_document(doc1_file.path()).await.unwrap();\n        store.store_document(doc2_file.path()).await.unwrap();\n\n        // Manually insert a relationship for testing\n        sqlx::query(\n            \"INSERT INTO document_relationships (from_id, to_id, relationship_type, created_at) VALUES (?, ?, ?, ?)\"\n        )\n        .bind(\"parent-doc\")\n        .bind(\"child-doc\")\n        .bind(\"blocks\")\n        .bind(chrono::Utc::now().timestamp() as f64)\n        .execute(store.pool())\n        .await\n        .unwrap();\n\n        // Test outgoing relationships\n        let outgoing = query_service\n            .get_relationships(\"parent-doc\", RelationshipDirection::Outgoing)\n            .await\n            .unwrap();\n        assert_eq!(outgoing.len(), 1);\n        assert_eq!(outgoing[0].from_id, \"parent-doc\");\n        assert_eq!(outgoing[0].to_id, \"child-doc\");\n\n        // Test incoming relationships\n        let incoming = query_service\n            .get_relationships(\"child-doc\", RelationshipDirection::Incoming)\n            .await\n            .unwrap();\n        assert_eq!(incoming.len(), 1);\n        assert_eq!(incoming[0].from_id, \"parent-doc\");\n        assert_eq!(incoming[0].to_id, \"child-doc\");\n\n        // Test both directions\n        let both = query_service\n            .get_relationships(\"parent-doc\", RelationshipDirection::Both)\n            .await\n            .unwrap();\n        assert_eq!(both.len(), 1);\n\n        // Test no relationships\n        let none = query_service\n            .get_relationships(\"nonexistent\", RelationshipDirection::Both)\n            .await\n            .unwrap();\n        assert_eq!(none.len(), 0);\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":26}},{"line":47,"address":[],"length":0,"stats":{"Line":184}},{"line":48,"address":[],"length":0,"stats":{"Line":92}},{"line":49,"address":[],"length":0,"stats":{"Line":92}},{"line":53,"address":[],"length":0,"stats":{"Line":92}},{"line":59,"address":[],"length":0,"stats":{"Line":92}},{"line":61,"address":[],"length":0,"stats":{"Line":92}},{"line":71,"address":[],"length":0,"stats":{"Line":92}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":92}},{"line":79,"address":[],"length":0,"stats":{"Line":184}},{"line":80,"address":[],"length":0,"stats":{"Line":92}},{"line":81,"address":[],"length":0,"stats":{"Line":92}},{"line":82,"address":[],"length":0,"stats":{"Line":92}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":149}},{"line":87,"address":[],"length":0,"stats":{"Line":19}},{"line":88,"address":[],"length":0,"stats":{"Line":38}},{"line":89,"address":[],"length":0,"stats":{"Line":19}},{"line":90,"address":[],"length":0,"stats":{"Line":19}},{"line":91,"address":[],"length":0,"stats":{"Line":19}},{"line":92,"address":[],"length":0,"stats":{"Line":19}},{"line":93,"address":[],"length":0,"stats":{"Line":19}},{"line":94,"address":[],"length":0,"stats":{"Line":19}},{"line":95,"address":[],"length":0,"stats":{"Line":19}},{"line":96,"address":[],"length":0,"stats":{"Line":19}},{"line":97,"address":[],"length":0,"stats":{"Line":19}},{"line":98,"address":[],"length":0,"stats":{"Line":19}},{"line":99,"address":[],"length":0,"stats":{"Line":19}},{"line":100,"address":[],"length":0,"stats":{"Line":19}},{"line":101,"address":[],"length":0,"stats":{"Line":19}},{"line":104,"address":[],"length":0,"stats":{"Line":92}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":9}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":4}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":1}},{"line":292,"address":[],"length":0,"stats":{"Line":2}},{"line":296,"address":[],"length":0,"stats":{"Line":10}},{"line":313,"address":[],"length":0,"stats":{"Line":5}},{"line":314,"address":[],"length":0,"stats":{"Line":5}},{"line":315,"address":[],"length":0,"stats":{"Line":5}},{"line":316,"address":[],"length":0,"stats":{"Line":5}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":11}},{"line":320,"address":[],"length":0,"stats":{"Line":6}},{"line":321,"address":[],"length":0,"stats":{"Line":6}},{"line":322,"address":[],"length":0,"stats":{"Line":3}},{"line":323,"address":[],"length":0,"stats":{"Line":3}},{"line":324,"address":[],"length":0,"stats":{"Line":3}},{"line":325,"address":[],"length":0,"stats":{"Line":3}},{"line":326,"address":[],"length":0,"stats":{"Line":3}},{"line":327,"address":[],"length":0,"stats":{"Line":3}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":3}},{"line":332,"address":[],"length":0,"stats":{"Line":3}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":5}},{"line":348,"address":[],"length":0,"stats":{"Line":4}},{"line":355,"address":[],"length":0,"stats":{"Line":8}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":357,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":361,"address":[],"length":0,"stats":{"Line":1}},{"line":362,"address":[],"length":0,"stats":{"Line":1}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[],"length":0,"stats":{"Line":2}},{"line":370,"address":[],"length":0,"stats":{"Line":4}},{"line":371,"address":[],"length":0,"stats":{"Line":16}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":8}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":10}},{"line":379,"address":[],"length":0,"stats":{"Line":6}},{"line":380,"address":[],"length":0,"stats":{"Line":3}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":6}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":3}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":3}},{"line":395,"address":[],"length":0,"stats":{"Line":3}},{"line":396,"address":[],"length":0,"stats":{"Line":3}},{"line":400,"address":[],"length":0,"stats":{"Line":4}},{"line":405,"address":[],"length":0,"stats":{"Line":25}},{"line":424,"address":[],"length":0,"stats":{"Line":50}},{"line":425,"address":[],"length":0,"stats":{"Line":25}},{"line":426,"address":[],"length":0,"stats":{"Line":25}}],"covered":137,"coverable":205},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","error.rs"],"content":"//! Error types for Metis operations\n\nuse thiserror::Error;\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, MetisError\u003e;\n\n#[derive(Debug, Error)]\npub enum MetisError {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n\n    #[error(\"Migration error: {0}\")]\n    Migration(#[from] sqlx::migrate::MigrateError),\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"JSON serialization error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"YAML parsing error: {0}\")]\n    Yaml(#[from] serde_yaml::Error),\n\n    #[error(\"Document not found: {id}\")]\n    DocumentNotFound { id: String },\n\n    #[error(\"Invalid document type: {document_type}\")]\n    InvalidDocumentType { document_type: String },\n\n    #[error(\"Invalid phase transition from {from} to {to} for document type {doc_type}\")]\n    InvalidPhaseTransition {\n        from: String,\n        to: String,\n        doc_type: String,\n    },\n\n    #[error(\"Missing required field: {field}\")]\n    MissingRequiredField { field: String },\n\n    #[error(\"Template not found: {template}\")]\n    TemplateNotFound { template: String },\n\n    #[error(\"Validation failed: {message}\")]\n    ValidationFailed { message: String },\n\n    #[error(\"Exit criteria not met: {missing_count} of {total_count} criteria incomplete\")]\n    ExitCriteriaNotMet {\n        missing_count: usize,\n        total_count: usize,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","exit_criteria.rs"],"content":"//! Exit criteria validation for documents\n\nuse crate::{MetisError, Result};\nuse std::path::Path;\nuse tokio::fs;\n\n/// Result of exit criteria validation containing detailed completion status\n#[derive(Debug, Clone)]\npub struct ExitCriteriaResult {\n    pub met: bool,\n    pub total_criteria: usize,\n    pub completed_criteria: usize,\n    pub missing_criteria: Vec\u003cString\u003e,\n}\n\nimpl ExitCriteriaResult {\n    /// Create a new result with no criteria found\n    pub fn empty() -\u003e Self {\n        Self {\n            met: true, // No criteria means all criteria are met\n            total_criteria: 0,\n            completed_criteria: 0,\n            missing_criteria: Vec::new(),\n        }\n    }\n}\n\n/// Validate exit criteria from a file path\npub async fn validate_exit_criteria(document_path: \u0026Path) -\u003e Result\u003cExitCriteriaResult\u003e {\n    let content = fs::read_to_string(document_path)\n        .await\n        .map_err(MetisError::Io)?;\n    validate_exit_criteria_content(\u0026content)\n}\n\n/// Validate exit criteria from document content\npub fn validate_exit_criteria_content(content: \u0026str) -\u003e Result\u003cExitCriteriaResult\u003e {\n    let criteria = parse_exit_criteria(content);\n\n    if criteria.is_empty() {\n        return Ok(ExitCriteriaResult::empty());\n    }\n\n    let completed_criteria = criteria.iter().filter(|c| c.completed).count();\n    let missing_criteria: Vec\u003cString\u003e = criteria\n        .iter()\n        .filter(|c| !c.completed)\n        .map(|c| c.text.clone())\n        .collect();\n\n    Ok(ExitCriteriaResult {\n        met: missing_criteria.is_empty(),\n        total_criteria: criteria.len(),\n        completed_criteria,\n        missing_criteria,\n    })\n}\n\n/// Individual exit criterion with completion status\n#[derive(Debug, Clone)]\nstruct ExitCriterion {\n    text: String,\n    completed: bool,\n}\n\n/// Parse exit criteria from markdown content\nfn parse_exit_criteria(content: \u0026str) -\u003e Vec\u003cExitCriterion\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let mut criteria = Vec::new();\n    let mut in_exit_criteria = false;\n\n    for line in lines {\n        let trimmed = line.trim();\n\n        // Look for the exit criteria section\n        if trimmed.starts_with(\"## Exit Criteria\") {\n            in_exit_criteria = true;\n            continue;\n        }\n\n        // Stop parsing if we hit another section\n        if in_exit_criteria \u0026\u0026 trimmed.starts_with(\"##\") \u0026\u0026 !trimmed.starts_with(\"## Exit Criteria\")\n        {\n            break;\n        }\n\n        // Parse checkbox items\n        if in_exit_criteria {\n            if let Some(criterion) = parse_checkbox_line(trimmed) {\n                criteria.push(criterion);\n            }\n        }\n    }\n\n    criteria\n}\n\n/// Parse a single line for checkbox format\nfn parse_checkbox_line(line: \u0026str) -\u003e Option\u003cExitCriterion\u003e {\n    let trimmed = line.trim();\n\n    // Check for incomplete checkbox: - [ ]\n    if let Some(text) = trimmed.strip_prefix(\"- [ ]\") {\n        return Some(ExitCriterion {\n            text: text.trim().to_string(),\n            completed: false,\n        });\n    }\n\n    // Check for completed checkbox: - [x] or - [X]\n    if let Some(text) = trimmed.strip_prefix(\"- [x]\") {\n        return Some(ExitCriterion {\n            text: text.trim().to_string(),\n            completed: true,\n        });\n    }\n\n    if let Some(text) = trimmed.strip_prefix(\"- [X]\") {\n        return Some(ExitCriterion {\n            text: text.trim().to_string(),\n            completed: true,\n        });\n    }\n\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn test_parse_checkbox_line() {\n        // Incomplete checkbox\n        let incomplete = parse_checkbox_line(\"- [ ] This is incomplete\");\n        assert!(incomplete.is_some());\n        let criterion = incomplete.unwrap();\n        assert_eq!(criterion.text, \"This is incomplete\");\n        assert!(!criterion.completed);\n\n        // Completed checkbox (lowercase x)\n        let completed = parse_checkbox_line(\"- [x] This is complete\");\n        assert!(completed.is_some());\n        let criterion = completed.unwrap();\n        assert_eq!(criterion.text, \"This is complete\");\n        assert!(criterion.completed);\n\n        // Completed checkbox (uppercase X)\n        let completed_upper = parse_checkbox_line(\"- [X] This is also complete\");\n        assert!(completed_upper.is_some());\n        let criterion = completed_upper.unwrap();\n        assert_eq!(criterion.text, \"This is also complete\");\n        assert!(criterion.completed);\n\n        // Not a checkbox\n        let not_checkbox = parse_checkbox_line(\"- This is just a list item\");\n        assert!(not_checkbox.is_none());\n\n        // Not a checkbox either\n        let also_not = parse_checkbox_line(\"Some regular text\");\n        assert!(also_not.is_none());\n    }\n\n    #[test]\n    fn test_parse_exit_criteria() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\nSome content here.\n\n## Exit Criteria\n\n- [ ] First incomplete criterion\n- [x] Second completed criterion\n- [ ] Third incomplete criterion\n- [X] Fourth completed criterion (uppercase)\n\n## Some Other Section\n\n- [ ] This should not be parsed\n\";\n\n        let criteria = parse_exit_criteria(content);\n        assert_eq!(criteria.len(), 4);\n\n        assert_eq!(criteria[0].text, \"First incomplete criterion\");\n        assert!(!criteria[0].completed);\n\n        assert_eq!(criteria[1].text, \"Second completed criterion\");\n        assert!(criteria[1].completed);\n\n        assert_eq!(criteria[2].text, \"Third incomplete criterion\");\n        assert!(!criteria[2].completed);\n\n        assert_eq!(criteria[3].text, \"Fourth completed criterion (uppercase)\");\n        assert!(criteria[3].completed);\n    }\n\n    #[test]\n    fn test_validate_exit_criteria_content() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\n- [x] Complete criterion\n- [ ] Incomplete criterion 1  \n- [ ] Incomplete criterion 2\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(!result.met);\n        assert_eq!(result.total_criteria, 3);\n        assert_eq!(result.completed_criteria, 1);\n        assert_eq!(result.missing_criteria.len(), 2);\n        assert_eq!(result.missing_criteria[0], \"Incomplete criterion 1\");\n        assert_eq!(result.missing_criteria[1], \"Incomplete criterion 2\");\n    }\n\n    #[test]\n    fn test_validate_all_criteria_complete() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\n- [x] First criterion\n- [x] Second criterion\n- [X] Third criterion\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(result.met);\n        assert_eq!(result.total_criteria, 3);\n        assert_eq!(result.completed_criteria, 3);\n        assert!(result.missing_criteria.is_empty());\n    }\n\n    #[test]\n    fn test_validate_no_exit_criteria() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\nSome content without exit criteria.\n\n## Some Other Section\n\nRegular content here.\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(result.met); // No criteria means all criteria are met\n        assert_eq!(result.total_criteria, 0);\n        assert_eq!(result.completed_criteria, 0);\n        assert!(result.missing_criteria.is_empty());\n    }\n\n    #[test]\n    fn test_validate_empty_exit_criteria_section() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\n## Next Section\n\nSome other content.\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(result.met);\n        assert_eq!(result.total_criteria, 0);\n        assert_eq!(result.completed_criteria, 0);\n        assert!(result.missing_criteria.is_empty());\n    }\n\n    #[test]\n    fn test_mixed_content_in_exit_criteria() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\nHere are the criteria:\n\n- [x] Complete this task\n- [ ] Review the implementation\n\nSome explanatory text here.\n\n- [x] Write tests\n- [ ] Update documentation\n\nMore text.\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(!result.met);\n        assert_eq!(result.total_criteria, 4);\n        assert_eq!(result.completed_criteria, 2);\n        assert_eq!(result.missing_criteria.len(), 2);\n        assert_eq!(result.missing_criteria[0], \"Review the implementation\");\n        assert_eq!(result.missing_criteria[1], \"Update documentation\");\n    }\n\n    #[tokio::test]\n    async fn test_validate_exit_criteria_from_file() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\n- [x] Criterion 1\n- [ ] Criterion 2\n- [x] Criterion 3\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        let result = validate_exit_criteria(file_path).await.unwrap();\n        assert!(!result.met);\n        assert_eq!(result.total_criteria, 3);\n        assert_eq!(result.completed_criteria, 2);\n        assert_eq!(result.missing_criteria.len(), 1);\n        assert_eq!(result.missing_criteria[0], \"Criterion 2\");\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":1}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":17}},{"line":47,"address":[],"length":0,"stats":{"Line":13}},{"line":48,"address":[],"length":0,"stats":{"Line":5}},{"line":67,"address":[],"length":0,"stats":{"Line":7}},{"line":68,"address":[],"length":0,"stats":{"Line":7}},{"line":69,"address":[],"length":0,"stats":{"Line":7}},{"line":70,"address":[],"length":0,"stats":{"Line":7}},{"line":72,"address":[],"length":0,"stats":{"Line":195}},{"line":73,"address":[],"length":0,"stats":{"Line":95}},{"line":76,"address":[],"length":0,"stats":{"Line":95}},{"line":77,"address":[],"length":0,"stats":{"Line":6}},{"line":78,"address":[],"length":0,"stats":{"Line":6}},{"line":82,"address":[],"length":0,"stats":{"Line":124}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":87}},{"line":89,"address":[],"length":0,"stats":{"Line":48}},{"line":95,"address":[],"length":0,"stats":{"Line":7}},{"line":99,"address":[],"length":0,"stats":{"Line":36}},{"line":100,"address":[],"length":0,"stats":{"Line":36}},{"line":103,"address":[],"length":0,"stats":{"Line":44}},{"line":111,"address":[],"length":0,"stats":{"Line":37}},{"line":118,"address":[],"length":0,"stats":{"Line":22}},{"line":125,"address":[],"length":0,"stats":{"Line":16}}],"covered":33,"coverable":34},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","lib.rs"],"content":"//! Metis - A design-first software development documentation system\n//!\n//! Metis implements the Flight Levels methodology for hierarchical documentation\n//! management, providing core functions for creating, validating, and transitioning\n//! documents through their defined phases.\n\npub mod context;\npub mod core;\npub mod database;\npub mod error;\npub mod exit_criteria;\npub mod models;\npub mod phases;\npub mod project;\npub mod render;\npub mod sync;\npub mod template;\npub mod updates;\npub mod validation;\n\n// Re-export main types for convenience\npub use core::{\n    can_transition_to_phase, render, transition_phase, validate, validate_content,\n    validate_exit_criteria, validate_exit_criteria_content, Complexity, DocumentContext,\n    ExitCriteriaResult, RiskLevel, TemplateEngine, ValidationResult,\n};\npub use database::{\n    DocumentStore, QueryService, Relationship, RelationshipDirection, SearchResult,\n};\npub use error::{MetisError, Result};\npub use models::*;\npub use project::{initialize_project, ProjectConfig, ProjectMetadata};\npub use sync::{SyncEngine, SyncError, SyncResult};\npub use updates::{update_blocked_by, update_document_content, update_exit_criterion};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","main.rs"],"content":"// Placeholder main.rs for now\nfn main() {\n    println!(\"Metis - Document management system\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","models","document.rs"],"content":"//! Document model definitions\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type, PartialEq, Default)]\n#[sqlx(rename_all = \"lowercase\")]\npub enum DocumentType {\n    #[default]\n    Task,\n    Vision,\n    Strategy,\n    Initiative,\n    Adr,\n}\n\nimpl std::fmt::Display for DocumentType {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            DocumentType::Vision =\u003e write!(f, \"vision\"),\n            DocumentType::Strategy =\u003e write!(f, \"strategy\"),\n            DocumentType::Initiative =\u003e write!(f, \"initiative\"),\n            DocumentType::Task =\u003e write!(f, \"task\"),\n            DocumentType::Adr =\u003e write!(f, \"adr\"),\n        }\n    }\n}\n\nimpl std::str::FromStr for DocumentType {\n    type Err = crate::MetisError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_lowercase().as_str() {\n            \"vision\" =\u003e Ok(DocumentType::Vision),\n            \"strategy\" =\u003e Ok(DocumentType::Strategy),\n            \"initiative\" =\u003e Ok(DocumentType::Initiative),\n            \"task\" =\u003e Ok(DocumentType::Task),\n            \"adr\" =\u003e Ok(DocumentType::Adr),\n            _ =\u003e Err(crate::MetisError::InvalidDocumentType {\n                document_type: s.to_string(),\n            }),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Document {\n    pub id: String,\n    pub filepath: String,\n    pub document_type: DocumentType,\n    pub level: DocumentType, // Same as document_type\n    pub status: String,\n    pub parent_id: Option\u003cString\u003e,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub updated_at: DateTime\u003cUtc\u003e,\n    pub content_hash: String,\n    pub frontmatter: serde_json::Value,\n    pub exit_criteria_met: bool,\n    pub content: Option\u003cString\u003e, // Body without frontmatter\n    pub file_size: Option\u003ci64\u003e,\n    pub file_modified_at: Option\u003cf64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n#[sqlx(rename_all = \"lowercase\")]\npub enum RiskLevel {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n#[sqlx(rename_all = \"lowercase\")]\npub enum Complexity {\n    S,  // Small\n    M,  // Medium\n    L,  // Large\n    XL, // Extra Large\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n#[sqlx(rename_all = \"lowercase\")]\npub enum RelationshipType {\n    Parent,\n    Blocks,\n    Supersedes,\n    Related,\n}\n\n#[derive(Debug, Clone)]\npub struct DocumentRelationship {\n    pub from_id: String,\n    pub to_id: String,\n    pub relationship_type: RelationshipType,\n    pub created_at: DateTime\u003cUtc\u003e,\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":170}},{"line":19,"address":[],"length":0,"stats":{"Line":170}},{"line":20,"address":[],"length":0,"stats":{"Line":41}},{"line":21,"address":[],"length":0,"stats":{"Line":39}},{"line":22,"address":[],"length":0,"stats":{"Line":34}},{"line":23,"address":[],"length":0,"stats":{"Line":36}},{"line":24,"address":[],"length":0,"stats":{"Line":20}},{"line":32,"address":[],"length":0,"stats":{"Line":112}},{"line":33,"address":[],"length":0,"stats":{"Line":112}},{"line":34,"address":[],"length":0,"stats":{"Line":159}},{"line":35,"address":[],"length":0,"stats":{"Line":86}},{"line":36,"address":[],"length":0,"stats":{"Line":56}},{"line":37,"address":[],"length":0,"stats":{"Line":61}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":16},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","models","mod.rs"],"content":"//! Data models for the Metis document management system\n\npub mod document;\n\n// Re-export main types for convenience\npub use document::{Complexity, Document, DocumentType, RelationshipType, RiskLevel};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","phases.rs"],"content":"//! Phase transition management for documents\n\nuse crate::validation::validate_content;\nuse crate::{DocumentType, MetisError, Result};\nuse std::path::Path;\nuse tokio::fs;\n\n/// Transition a document to a new phase with validation and file updates\npub async fn transition_phase(\n    document_path: \u0026Path,\n    new_phase: \u0026str,\n    force: bool,\n) -\u003e Result\u003cString\u003e {\n    // Read current document content\n    let content = fs::read_to_string(document_path)\n        .await\n        .map_err(MetisError::Io)?;\n\n    // Validate current document and extract document type\n    let validation_result = validate_content(\u0026content)?;\n    if !validation_result.is_valid \u0026\u0026 !force {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\n                \"Document validation failed: {:?}\",\n                validation_result.frontmatter_errors\n            ),\n        });\n    }\n\n    let doc_type = validation_result\n        .document_type\n        .ok_or_else(|| MetisError::ValidationFailed {\n            message: \"Cannot determine document type\".to_string(),\n        })?;\n\n    // Extract current phase from content\n    let current_phase = extract_current_phase(\u0026content)?;\n\n    // Check if transition is valid (unless forced)\n    if !force \u0026\u0026 !is_valid_transition(\u0026doc_type, \u0026current_phase, new_phase) {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\n                \"Invalid phase transition from '{}' to '{}' for {} document. Valid transitions: {}\",\n                current_phase,\n                new_phase,\n                format!(\"{:?}\", doc_type).to_lowercase(),\n                get_valid_transitions(\u0026doc_type, \u0026current_phase).join(\", \")\n            ),\n        });\n    }\n\n    // Update document content with new phase\n    let updated_content = update_phase_in_content(\u0026content, \u0026current_phase, new_phase)?;\n\n    // Write updated content back to file\n    fs::write(document_path, \u0026updated_content)\n        .await\n        .map_err(MetisError::Io)?;\n\n    Ok(updated_content)\n}\n\n/// Check if a phase transition is allowed without making changes\npub async fn can_transition_to_phase(document_path: \u0026Path, target_phase: \u0026str) -\u003e Result\u003cbool\u003e {\n    // Read current document content\n    let content = fs::read_to_string(document_path)\n        .await\n        .map_err(MetisError::Io)?;\n\n    // Validate current document and extract document type\n    let validation_result = validate_content(\u0026content)?;\n    if !validation_result.is_valid {\n        return Ok(false);\n    }\n\n    let doc_type = validation_result\n        .document_type\n        .ok_or_else(|| MetisError::ValidationFailed {\n            message: \"Cannot determine document type\".to_string(),\n        })?;\n\n    // Extract current phase from content\n    let current_phase = extract_current_phase(\u0026content)?;\n\n    // Check if transition is valid\n    Ok(is_valid_transition(\u0026doc_type, \u0026current_phase, target_phase))\n}\n\n/// Extract the current active phase from document content\nfn extract_current_phase(content: \u0026str) -\u003e Result\u003cString\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let mut in_frontmatter = false;\n    let mut in_tags = false;\n\n    for line in lines {\n        let trimmed = line.trim();\n\n        if trimmed == \"---\" {\n            if !in_frontmatter {\n                in_frontmatter = true;\n                continue;\n            } else {\n                break; // End of frontmatter\n            }\n        }\n\n        if !in_frontmatter {\n            continue;\n        }\n\n        if trimmed == \"tags:\" {\n            in_tags = true;\n            continue;\n        }\n\n        if in_tags {\n            // Look for active phase tag (not commented out)\n            if trimmed.starts_with(\"- \\\"#phase/\") \u0026\u0026 !trimmed.starts_with(\"# \") {\n                if let Some(phase_start) = trimmed.find(\"#phase/\") {\n                    let phase_part = \u0026trimmed[phase_start + 7..]; // Skip \"#phase/\"\n                    if let Some(end_quote) = phase_part.find('\"') {\n                        return Ok(phase_part[..end_quote].to_string());\n                    }\n                }\n            }\n\n            // If we hit a line that doesn't start with spaces/dashes, we're out of tags\n            if !trimmed.is_empty() \u0026\u0026 !trimmed.starts_with(\"-\") \u0026\u0026 !trimmed.starts_with(\"#\") {\n                break;\n            }\n        }\n    }\n\n    Err(MetisError::ValidationFailed {\n        message: \"No active phase tag found in document\".to_string(),\n    })\n}\n\n/// Update the phase in document content using comment/uncomment logic\nfn update_phase_in_content(content: \u0026str, current_phase: \u0026str, new_phase: \u0026str) -\u003e Result\u003cString\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let mut updated_lines = Vec::new();\n    let mut in_frontmatter = false;\n    let mut in_tags = false;\n\n    for line in lines {\n        let trimmed = line.trim();\n\n        if trimmed == \"---\" {\n            updated_lines.push(line.to_string());\n            if !in_frontmatter {\n                in_frontmatter = true;\n            } else {\n                in_frontmatter = false; // End of frontmatter\n                in_tags = false;\n            }\n            continue;\n        }\n\n        if !in_frontmatter {\n            updated_lines.push(line.to_string());\n            continue;\n        }\n\n        if trimmed == \"tags:\" {\n            updated_lines.push(line.to_string());\n            in_tags = true;\n            continue;\n        }\n\n        if in_tags {\n            // Handle phase tag lines\n            if trimmed.contains(\"#phase/\") {\n                let is_current_phase = trimmed.contains(\u0026format!(\"#phase/{}\", current_phase));\n                let is_target_phase = trimmed.contains(\u0026format!(\"#phase/{}\", new_phase));\n\n                if is_current_phase \u0026\u0026 !trimmed.starts_with(\"#\") {\n                    // Comment out the current phase\n                    let spaces = line.len() - line.trim_start().len();\n                    updated_lines.push(format!(\"{}# {}\", \" \".repeat(spaces), trimmed));\n                } else if is_target_phase \u0026\u0026 trimmed.starts_with(\"#\") {\n                    // Uncomment the target phase\n                    let uncommented = trimmed.strip_prefix(\"# \").unwrap_or(trimmed);\n                    let spaces = line.len() - line.trim_start().len();\n                    updated_lines.push(format!(\"{}{}\", \" \".repeat(spaces), uncommented));\n                } else {\n                    // Keep other phase tags as-is\n                    updated_lines.push(line.to_string());\n                }\n            } else {\n                updated_lines.push(line.to_string());\n                // If we hit a line that doesn't start with spaces/dashes, we're out of tags\n                if !trimmed.is_empty() \u0026\u0026 !trimmed.starts_with(\"-\") \u0026\u0026 !trimmed.starts_with(\"#\") {\n                    in_tags = false;\n                }\n            }\n        } else {\n            updated_lines.push(line.to_string());\n        }\n    }\n\n    Ok(updated_lines.join(\"\\n\"))\n}\n\n/// Check if a phase transition is valid according to business rules\nfn is_valid_transition(doc_type: \u0026DocumentType, current_phase: \u0026str, target_phase: \u0026str) -\u003e bool {\n    let valid_transitions = get_valid_transitions(doc_type, current_phase);\n    valid_transitions.contains(\u0026target_phase.to_string())\n}\n\n/// Get valid next phases for a document type and current phase\nfn get_valid_transitions(doc_type: \u0026DocumentType, current_phase: \u0026str) -\u003e Vec\u003cString\u003e {\n    match doc_type {\n        DocumentType::Vision =\u003e match current_phase {\n            \"draft\" =\u003e vec![\"review\".to_string()],\n            \"review\" =\u003e vec![\"draft\".to_string(), \"published\".to_string()],\n            \"published\" =\u003e vec![\"review\".to_string()], // Can go back for updates\n            _ =\u003e vec![],\n        },\n        DocumentType::Strategy =\u003e match current_phase {\n            \"shaping\" =\u003e vec![\"design\".to_string()],\n            \"design\" =\u003e vec![\"shaping\".to_string(), \"ready\".to_string()],\n            \"ready\" =\u003e vec![\"design\".to_string(), \"active\".to_string()],\n            \"active\" =\u003e vec![\"ready\".to_string(), \"completed\".to_string()],\n            \"completed\" =\u003e vec![\"active\".to_string()], // Can reopen if needed\n            _ =\u003e vec![],\n        },\n        DocumentType::Initiative =\u003e match current_phase {\n            \"discovery\" =\u003e vec![\"design\".to_string()],\n            \"design\" =\u003e vec![\"discovery\".to_string(), \"ready\".to_string()],\n            \"ready\" =\u003e vec![\"design\".to_string(), \"decompose\".to_string()],\n            \"decompose\" =\u003e vec![\"ready\".to_string(), \"active\".to_string()],\n            \"active\" =\u003e vec![\"decompose\".to_string(), \"completed\".to_string()],\n            \"completed\" =\u003e vec![\"active\".to_string()], // Can reopen if needed\n            _ =\u003e vec![],\n        },\n        DocumentType::Task =\u003e match current_phase {\n            \"todo\" =\u003e vec![\"doing\".to_string()],\n            \"doing\" =\u003e vec![\"todo\".to_string(), \"completed\".to_string()],\n            \"completed\" =\u003e vec![\"doing\".to_string()], // Can reopen if needed\n            _ =\u003e vec![],\n        },\n        DocumentType::Adr =\u003e match current_phase {\n            \"draft\" =\u003e vec![\"discussion\".to_string()],\n            \"discussion\" =\u003e vec![\"draft\".to_string(), \"decided\".to_string()],\n            \"decided\" =\u003e vec![\"superseded\".to_string()],\n            \"superseded\" =\u003e vec![], // Terminal state\n            _ =\u003e vec![],\n        },\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn test_extract_current_phase() {\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  # - \\\"#phase/shaping\\\"\n  # - \\\"#phase/design\\\"\n  - \\\"#phase/active\\\"\n  # - \\\"#phase/completed\\\"\n---\n\n# Test Strategy\n\nContent here...\n\";\n\n        let phase = extract_current_phase(content).unwrap();\n        assert_eq!(phase, \"active\");\n    }\n\n    #[test]\n    fn test_extract_current_phase_no_active() {\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ntags:\n  - \\\"#strategy\\\"\n  # - \\\"#phase/shaping\\\"\n  # - \\\"#phase/design\\\"\n  # - \\\"#phase/active\\\"\n---\n\n# Test Strategy\n\";\n\n        let result = extract_current_phase(content);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_update_phase_in_content() {\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ntags:\n  - \\\"#strategy\\\"\n  # - \\\"#phase/shaping\\\"\n  # - \\\"#phase/design\\\"\n  - \\\"#phase/active\\\"\n  # - \\\"#phase/completed\\\"\n---\n\n# Test Strategy\n\nContent here...\n\";\n\n        let updated = update_phase_in_content(content, \"active\", \"completed\").unwrap();\n\n        assert!(updated.contains(\"# - \\\"#phase/active\\\"\"));\n        assert!(updated.contains(\"- \\\"#phase/completed\\\"\"));\n        assert!(!updated.contains(\"# - \\\"#phase/completed\\\"\"));\n    }\n\n    #[test]\n    fn test_valid_strategy_transitions() {\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"shaping\",\n            \"design\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"design\",\n            \"ready\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"ready\",\n            \"active\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"active\",\n            \"completed\"\n        ));\n\n        // Backward transitions\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"design\",\n            \"shaping\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"ready\",\n            \"design\"\n        ));\n\n        // Invalid transitions\n        assert!(!is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"shaping\",\n            \"active\"\n        ));\n        assert!(!is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"completed\",\n            \"shaping\"\n        ));\n    }\n\n    #[test]\n    fn test_valid_task_transitions() {\n        assert!(is_valid_transition(\u0026DocumentType::Task, \"todo\", \"doing\"));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Task,\n            \"doing\",\n            \"completed\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Task,\n            \"completed\",\n            \"doing\"\n        ));\n\n        // Invalid transitions\n        assert!(!is_valid_transition(\n            \u0026DocumentType::Task,\n            \"todo\",\n            \"completed\"\n        ));\n    }\n\n    #[test]\n    fn test_valid_adr_transitions() {\n        assert!(is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"draft\",\n            \"discussion\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"discussion\",\n            \"decided\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"decided\",\n            \"superseded\"\n        ));\n\n        // Backward transition\n        assert!(is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"discussion\",\n            \"draft\"\n        ));\n\n        // Invalid transitions\n        assert!(!is_valid_transition(\u0026DocumentType::Adr, \"draft\", \"decided\"));\n        assert!(!is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"superseded\",\n            \"decided\"\n        ));\n    }\n\n    #[tokio::test]\n    async fn test_transition_phase_file() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  # - \\\"#phase/shaping\\\"\n  # - \\\"#phase/design\\\"\n  - \\\"#phase/active\\\"\n  # - \\\"#phase/completed\\\"\nrisk_level: medium\n---\n\n# Test Strategy\n\nContent here...\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        // Transition from active to completed\n        let result = transition_phase(file_path, \"completed\", false).await;\n        assert!(result.is_ok());\n\n        let updated_content = result.unwrap();\n        assert!(updated_content.contains(\"# - \\\"#phase/active\\\"\"));\n        assert!(updated_content.contains(\"- \\\"#phase/completed\\\"\"));\n\n        // Verify file was actually updated\n        let file_content = fs::read_to_string(file_path).await.unwrap();\n        assert_eq!(file_content, updated_content);\n    }\n\n    #[tokio::test]\n    async fn test_invalid_transition_rejected() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/active\\\"\nrisk_level: medium\n---\n\n# Test Strategy\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        // Try invalid transition from active to shaping\n        let result = transition_phase(file_path, \"shaping\", false).await;\n        assert!(result.is_err());\n\n        // Verify file was not changed\n        let file_content = fs::read_to_string(file_path).await.unwrap();\n        assert_eq!(file_content, content);\n    }\n\n    #[tokio::test]\n    async fn test_force_invalid_transition() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/active\\\"\n  # - \\\"#phase/shaping\\\"\nrisk_level: medium\n---\n\n# Test Strategy\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        // Force invalid transition from active to shaping\n        let result = transition_phase(file_path, \"shaping\", true).await;\n        assert!(result.is_ok());\n\n        let updated_content = result.unwrap();\n        assert!(updated_content.contains(\"# - \\\"#phase/active\\\"\"));\n        assert!(updated_content.contains(\"- \\\"#phase/shaping\\\"\"));\n    }\n\n    #[tokio::test]\n    async fn test_can_transition_to_phase() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/active\\\"\nrisk_level: medium\n---\n\n# Test Strategy\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        // Can transition to completed\n        let can_complete = can_transition_to_phase(file_path, \"completed\")\n            .await\n            .unwrap();\n        assert!(can_complete);\n\n        // Cannot transition to shaping\n        let can_shape = can_transition_to_phase(file_path, \"shaping\").await.unwrap();\n        assert!(!can_shape);\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":15,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":3}},{"line":17,"address":[],"length":0,"stats":{"Line":3}},{"line":20,"address":[],"length":0,"stats":{"Line":3}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":6}},{"line":31,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":7}},{"line":91,"address":[],"length":0,"stats":{"Line":7}},{"line":92,"address":[],"length":0,"stats":{"Line":7}},{"line":93,"address":[],"length":0,"stats":{"Line":7}},{"line":95,"address":[],"length":0,"stats":{"Line":136}},{"line":96,"address":[],"length":0,"stats":{"Line":68}},{"line":98,"address":[],"length":0,"stats":{"Line":68}},{"line":99,"address":[],"length":0,"stats":{"Line":8}},{"line":100,"address":[],"length":0,"stats":{"Line":7}},{"line":101,"address":[],"length":0,"stats":{"Line":7}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":60}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":60}},{"line":112,"address":[],"length":0,"stats":{"Line":7}},{"line":113,"address":[],"length":0,"stats":{"Line":7}},{"line":116,"address":[],"length":0,"stats":{"Line":53}},{"line":118,"address":[],"length":0,"stats":{"Line":26}},{"line":119,"address":[],"length":0,"stats":{"Line":12}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":35}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":144,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":97}},{"line":150,"address":[],"length":0,"stats":{"Line":6}},{"line":151,"address":[],"length":0,"stats":{"Line":9}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":157,"address":[],"length":0,"stats":{"Line":6}},{"line":160,"address":[],"length":0,"stats":{"Line":41}},{"line":161,"address":[],"length":0,"stats":{"Line":10}},{"line":162,"address":[],"length":0,"stats":{"Line":10}},{"line":165,"address":[],"length":0,"stats":{"Line":31}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":171,"address":[],"length":0,"stats":{"Line":28}},{"line":173,"address":[],"length":0,"stats":{"Line":15}},{"line":174,"address":[],"length":0,"stats":{"Line":10}},{"line":175,"address":[],"length":0,"stats":{"Line":10}},{"line":177,"address":[],"length":0,"stats":{"Line":16}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":16}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[],"length":0,"stats":{"Line":3}},{"line":188,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":5}},{"line":193,"address":[],"length":0,"stats":{"Line":14}},{"line":194,"address":[],"length":0,"stats":{"Line":2}},{"line":198,"address":[],"length":0,"stats":{"Line":13}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":206,"address":[],"length":0,"stats":{"Line":22}},{"line":207,"address":[],"length":0,"stats":{"Line":22}},{"line":208,"address":[],"length":0,"stats":{"Line":22}},{"line":212,"address":[],"length":0,"stats":{"Line":23}},{"line":213,"address":[],"length":0,"stats":{"Line":23}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":13}},{"line":221,"address":[],"length":0,"stats":{"Line":15}},{"line":222,"address":[],"length":0,"stats":{"Line":13}},{"line":223,"address":[],"length":0,"stats":{"Line":11}},{"line":224,"address":[],"length":0,"stats":{"Line":13}},{"line":225,"address":[],"length":0,"stats":{"Line":2}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":4}},{"line":238,"address":[],"length":0,"stats":{"Line":6}},{"line":239,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":6}},{"line":244,"address":[],"length":0,"stats":{"Line":8}},{"line":245,"address":[],"length":0,"stats":{"Line":6}},{"line":246,"address":[],"length":0,"stats":{"Line":3}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":248,"address":[],"length":0,"stats":{"Line":0}}],"covered":107,"coverable":137},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","project.rs"],"content":"//! Project initialization functionality\n\nuse crate::{DocumentContext, DocumentStore, DocumentType, MetisError, Result, TemplateEngine};\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// Configuration for initializing a new Metis project\n#[derive(Debug, Clone)]\npub struct ProjectConfig {\n    pub name: String,\n    pub description: Option\u003cString\u003e,\n    pub root_path: PathBuf,\n}\n\n/// Metadata returned after successful project initialization\n#[derive(Debug, Clone)]\npub struct ProjectMetadata {\n    pub project_path: PathBuf,\n    pub database_path: PathBuf,\n}\n\n/// Initialize a new Metis project (idempotent and non-destructive)\npub async fn initialize_project(config: ProjectConfig) -\u003e Result\u003cProjectMetadata\u003e {\n    let project_path = config.root_path.join(\"metis\");\n    let database_path = project_path.join(\".metis.db\");\n\n    // 1. Validate project name (filesystem safety)\n    if !is_valid_project_name(\u0026config.name) {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\"Invalid project name '{}'. Use only alphanumeric characters, hyphens, and underscores.\", config.name),\n        });\n    }\n\n    // 2. Validate parent directory exists and is writable\n    if !config.root_path.exists() {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\n                \"Parent directory does not exist: {}\",\n                config.root_path.display()\n            ),\n        });\n    }\n\n    if !config.root_path.is_dir() {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\"Path is not a directory: {}\", config.root_path.display()),\n        });\n    }\n\n    // 3. Create metis directory if it doesn't exist\n    if !project_path.exists() {\n        fs::create_dir_all(\u0026project_path).map_err(|e| MetisError::ValidationFailed {\n            message: format!(\"Failed to create metis directory: {}\", e),\n        })?;\n    }\n\n    // 4. Test write permissions by creating and removing a temporary file\n    let temp_file = project_path.join(\".metis_temp_test\");\n    if let Err(e) = fs::write(\u0026temp_file, \"\") {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\"Directory is not writable: {}\", e),\n        });\n    }\n    let _ = fs::remove_file(temp_file); // Ignore errors on cleanup\n\n    // 5. Create directory structure if it doesn't exist\n    create_directory_structure(\u0026project_path)?;\n\n    // 6. Initialize database if it doesn't exist\n    if !database_path.exists() {\n        let database_url = format!(\"sqlite:{}\", database_path.display());\n        let _store = DocumentStore::new(\u0026database_url).await?;\n    }\n\n    // 7. Create initial vision document if it doesn't exist\n    create_initial_vision(\u0026project_path, \u0026config.name, config.description.as_deref())?;\n\n    Ok(ProjectMetadata {\n        project_path,\n        database_path,\n    })\n}\n\n/// Create the standard Metis directory structure (idempotent)\nfn create_directory_structure(project_path: \u0026Path) -\u003e Result\u003c()\u003e {\n    let strategies_dir = project_path.join(\"strategies\");\n    let decisions_dir = project_path.join(\"decisions\");\n\n    // create_dir_all is already idempotent - it won't fail if directories exist\n    fs::create_dir_all(\u0026strategies_dir).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to create strategies directory: {}\", e),\n    })?;\n\n    fs::create_dir_all(\u0026decisions_dir).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to create decisions directory: {}\", e),\n    })?;\n\n    Ok(())\n}\n\n/// Create the initial vision document using the template system (non-destructive)\nfn create_initial_vision(\n    project_path: \u0026Path,\n    project_name: \u0026str,\n    description: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003c()\u003e {\n    let vision_path = project_path.join(\"vision.md\");\n\n    // Only create vision document if it doesn't already exist\n    if vision_path.exists() {\n        return Ok(());\n    }\n\n    let template_engine = TemplateEngine::new()?;\n\n    // Create context for vision document\n    let vision_context = DocumentContext::new(format!(\"{} Vision\", project_name));\n\n    // Render the vision document\n    let vision_content = template_engine.render_document(\u0026DocumentType::Vision, \u0026vision_context)?;\n\n    // Customize content if description is provided\n    let final_content = if let Some(desc) = description {\n        // Replace the placeholder purpose section with the provided description\n        vision_content.replace(\"{Why this vision exists and what it aims to achieve}\", desc)\n    } else {\n        vision_content\n    };\n\n    // Write vision document to project root\n    fs::write(\u0026vision_path, final_content).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to create vision document: {}\", e),\n    })?;\n\n    Ok(())\n}\n\n/// Validate that a project name is safe for filesystem use\nfn is_valid_project_name(name: \u0026str) -\u003e bool {\n    if name.is_empty() || name.len() \u003e 255 {\n        return false;\n    }\n\n    // Only allow alphanumeric characters, hyphens, underscores, and spaces\n    name.chars()\n        .all(|c| c.is_alphanumeric() || c == '-' || c == '_' || c == ' ')\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_is_valid_project_name() {\n        assert!(is_valid_project_name(\"my-project\"));\n        assert!(is_valid_project_name(\"my_project\"));\n        assert!(is_valid_project_name(\"MyProject123\"));\n        assert!(is_valid_project_name(\"My Project\"));\n\n        assert!(!is_valid_project_name(\"\"));\n        assert!(!is_valid_project_name(\"my/project\"));\n        assert!(!is_valid_project_name(\"my\\\\project\"));\n        assert!(!is_valid_project_name(\"my\u003cproject\u003e\"));\n        assert!(!is_valid_project_name(\"my|project\"));\n\n        // Test very long name\n        let long_name = \"a\".repeat(256);\n        assert!(!is_valid_project_name(\u0026long_name));\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_success() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        let config = ProjectConfig {\n            name: \"Test Project\".to_string(),\n            description: Some(\"A test project for validation\".to_string()),\n            root_path: project_path.clone(),\n        };\n\n        let result = initialize_project(config).await;\n        assert!(result.is_ok());\n\n        let metadata = result.unwrap();\n        assert_eq!(metadata.project_path, project_path.join(\"metis\"));\n        assert_eq!(\n            metadata.database_path,\n            project_path.join(\"metis\").join(\".metis.db\")\n        );\n\n        // Verify directory structure was created\n        assert!(project_path.join(\"metis\").join(\"strategies\").exists());\n        assert!(project_path.join(\"metis\").join(\"decisions\").exists());\n\n        // Verify database was created\n        assert!(project_path.join(\"metis\").join(\".metis.db\").exists());\n\n        // Verify vision document was created\n        let vision_path = project_path.join(\"metis\").join(\"vision.md\");\n        assert!(vision_path.exists());\n\n        let vision_content = fs::read_to_string(vision_path).unwrap();\n        assert!(vision_content.contains(\"Test Project Vision\"));\n        assert!(vision_content.contains(\"A test project for validation\"));\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_already_exists() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        // Create existing metis directory and .metis.db file\n        fs::create_dir_all(project_path.join(\"metis\")).unwrap();\n        fs::write(project_path.join(\"metis\").join(\".metis.db\"), \"\").unwrap();\n\n        let config = ProjectConfig {\n            name: \"Test Project\".to_string(),\n            description: None,\n            root_path: project_path.clone(),\n        };\n\n        // Should succeed because initialization is now idempotent\n        let result = initialize_project(config).await;\n        assert!(result.is_ok());\n\n        let metadata = result.unwrap();\n        assert_eq!(metadata.project_path, project_path.join(\"metis\"));\n        assert_eq!(\n            metadata.database_path,\n            project_path.join(\"metis\").join(\".metis.db\")\n        );\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_twice() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        let config = ProjectConfig {\n            name: \"Test Project\".to_string(),\n            description: Some(\"A test project for double initialization\".to_string()),\n            root_path: project_path.clone(),\n        };\n\n        // First initialization should succeed\n        let result1 = initialize_project(config.clone()).await;\n        assert!(result1.is_ok());\n\n        // Verify it was created properly\n        assert!(project_path.join(\"metis\").join(\".metis.db\").exists());\n        assert!(project_path.join(\"metis\").join(\"vision.md\").exists());\n\n        // Second initialization should succeed (idempotent)\n        let result2 = initialize_project(config).await;\n        assert!(result2.is_ok());\n\n        let metadata2 = result2.unwrap();\n        assert_eq!(metadata2.project_path, project_path.join(\"metis\"));\n        assert_eq!(\n            metadata2.database_path,\n            project_path.join(\"metis\").join(\".metis.db\")\n        );\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_invalid_name() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        let config = ProjectConfig {\n            name: \"invalid/name\".to_string(), // Contains slash\n            description: None,\n            root_path: project_path.clone(),\n        };\n\n        let result = initialize_project(config).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Invalid project name\"));\n        } else {\n            panic!(\"Expected ValidationFailed error\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_nonexistent_directory() {\n        let nonexistent_path = PathBuf::from(\"/nonexistent/directory\");\n\n        let config = ProjectConfig {\n            name: \"Test Project\".to_string(),\n            description: None,\n            root_path: nonexistent_path,\n        };\n\n        let result = initialize_project(config).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Parent directory does not exist\"));\n        } else {\n            panic!(\"Expected ValidationFailed error\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_without_description() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        let config = ProjectConfig {\n            name: \"Simple Project\".to_string(),\n            description: None,\n            root_path: project_path.clone(),\n        };\n\n        let result = initialize_project(config).await;\n        assert!(result.is_ok());\n\n        // Verify vision document was created with default content\n        let vision_path = project_path.join(\"metis\").join(\"vision.md\");\n        assert!(vision_path.exists());\n\n        let vision_content = fs::read_to_string(vision_path).unwrap();\n        assert!(vision_content.contains(\"Simple Project Vision\"));\n        // Should contain the default placeholder text\n        assert!(vision_content.contains(\"{Why this vision exists and what it aims to achieve}\"));\n    }\n\n    #[test]\n    fn test_create_directory_structure() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path();\n\n        let result = create_directory_structure(project_path);\n        assert!(result.is_ok());\n\n        assert!(project_path.join(\"strategies\").exists());\n        assert!(project_path.join(\"decisions\").exists());\n        assert!(project_path.join(\"strategies\").is_dir());\n        assert!(project_path.join(\"decisions\").is_dir());\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":54}},{"line":24,"address":[],"length":0,"stats":{"Line":27}},{"line":25,"address":[],"length":0,"stats":{"Line":27}},{"line":28,"address":[],"length":0,"stats":{"Line":27}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":26}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":25}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":25}},{"line":52,"address":[],"length":0,"stats":{"Line":21}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":25}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":25}},{"line":67,"address":[],"length":0,"stats":{"Line":25}},{"line":70,"address":[],"length":0,"stats":{"Line":25}},{"line":71,"address":[],"length":0,"stats":{"Line":21}},{"line":72,"address":[],"length":0,"stats":{"Line":21}},{"line":76,"address":[],"length":0,"stats":{"Line":25}},{"line":78,"address":[],"length":0,"stats":{"Line":25}},{"line":79,"address":[],"length":0,"stats":{"Line":25}},{"line":80,"address":[],"length":0,"stats":{"Line":25}},{"line":85,"address":[],"length":0,"stats":{"Line":26}},{"line":86,"address":[],"length":0,"stats":{"Line":26}},{"line":87,"address":[],"length":0,"stats":{"Line":26}},{"line":90,"address":[],"length":0,"stats":{"Line":26}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":26}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":26}},{"line":102,"address":[],"length":0,"stats":{"Line":25}},{"line":107,"address":[],"length":0,"stats":{"Line":25}},{"line":110,"address":[],"length":0,"stats":{"Line":25}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":114,"address":[],"length":0,"stats":{"Line":22}},{"line":120,"address":[],"length":0,"stats":{"Line":22}},{"line":123,"address":[],"length":0,"stats":{"Line":20}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":22}},{"line":139,"address":[],"length":0,"stats":{"Line":37}},{"line":140,"address":[],"length":0,"stats":{"Line":73}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":35}},{"line":146,"address":[],"length":0,"stats":{"Line":490}}],"covered":44,"coverable":54},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","render.rs"],"content":"//! Main render function for creating documents\n\nuse crate::context::DocumentContext;\nuse crate::template::TemplateEngine;\nuse crate::{DocumentType, MetisError, Result};\nuse std::path::{Path, PathBuf};\nuse tokio::fs;\n\n/// Main render function: create document from template and write to filesystem\npub async fn render(\n    document_type: DocumentType,\n    context: DocumentContext,\n    docs_root: \u0026Path,\n) -\u003e Result\u003cPathBuf\u003e {\n    // Create template engine\n    let engine = TemplateEngine::new()?;\n\n    // Validate context for document type\n    context.validate_for_type(\u0026document_type)?;\n\n    // Render document content\n    let content = engine.render_document(\u0026document_type, \u0026context)?;\n\n    // Generate destination path\n    let relative_path = engine.generate_destination_path(\u0026document_type, \u0026context);\n    let full_path = docs_root.join(\u0026relative_path);\n\n    // Create parent directories if they don't exist\n    if let Some(parent) = full_path.parent() {\n        fs::create_dir_all(parent).await.map_err(MetisError::Io)?;\n    }\n\n    // Write file to filesystem\n    fs::write(\u0026full_path, content)\n        .await\n        .map_err(MetisError::Io)?;\n\n    Ok(full_path)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::context::{Complexity, RiskLevel};\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_render_strategy_to_filesystem() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"Test Strategy\".to_string())\n            .with_risk_level(RiskLevel::High)\n            .with_stakeholders(vec![\"Engineering\".to_string(), \"Product\".to_string()]);\n\n        let result = render(DocumentType::Strategy, context, docs_root).await;\n        assert!(result.is_ok());\n\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n        assert!(file_path\n            .to_string_lossy()\n            .contains(\"strategies/test-strategy/strategy.md\"));\n\n        // Verify file contents\n        let content = std::fs::read_to_string(\u0026file_path).unwrap();\n        assert!(content.contains(\"---\\n\")); // Has frontmatter\n        assert!(content.contains(\"# Test Strategy Strategy\")); // Has content\n        assert!(content.contains(\"high\")); // Has risk level\n    }\n\n    #[tokio::test]\n    async fn test_render_initiative_with_parent() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"API Design\".to_string())\n            .with_parent(\"Core Platform Strategy\".to_string())\n            .with_complexity(Complexity::L)\n            .with_technical_lead(\"Alice Smith\".to_string());\n\n        let result = render(DocumentType::Initiative, context, docs_root).await;\n        assert!(result.is_ok());\n\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n        assert!(file_path\n            .to_string_lossy()\n            .contains(\"strategies/core-platform-strategy/initiatives/api-design/initiative.md\"));\n\n        // Verify file contents\n        let content = std::fs::read_to_string(\u0026file_path).unwrap();\n        assert!(content.contains(\"strategy-core-platform-strategy\")); // Has parent ID\n        assert!(content.contains(\"L\")); // Has complexity\n        assert!(content.contains(\"Alice Smith\")); // Has technical lead\n    }\n\n    #[tokio::test]\n    async fn test_render_adr_with_number() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"Use GraphQL\".to_string())\n            .with_decision_maker(\"Architecture Team\".to_string())\n            .with_number(42);\n\n        let result = render(DocumentType::Adr, context, docs_root).await;\n        assert!(result.is_ok());\n\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n        assert!(file_path\n            .to_string_lossy()\n            .contains(\"decisions/adr-042-use-graphql.md\"));\n\n        // Verify file contents\n        let content = std::fs::read_to_string(\u0026file_path).unwrap();\n        assert!(content.contains(\"ADR-42: Use GraphQL\")); // Has title\n        assert!(content.contains(\"Architecture Team\")); // Has decision maker\n    }\n\n    #[tokio::test]\n    async fn test_render_creates_directories() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"Deep Nested Strategy\".to_string())\n            .with_risk_level(RiskLevel::Medium);\n\n        // Ensure the directory doesn't exist initially\n        let expected_dir = docs_root.join(\"strategies/deep-nested-strategy\");\n        assert!(!expected_dir.exists());\n\n        let result = render(DocumentType::Strategy, context, docs_root).await;\n        assert!(result.is_ok());\n\n        // Verify directory was created\n        assert!(expected_dir.exists());\n        assert!(expected_dir.is_dir());\n\n        // Verify file was created\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n    }\n\n    #[tokio::test]\n    async fn test_render_validation_failure() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        // Strategy without required risk_level should fail\n        let context = DocumentContext::new(\"Invalid Strategy\".to_string());\n\n        let result = render(DocumentType::Strategy, context, docs_root).await;\n        assert!(result.is_err());\n\n        // Verify no file was created\n        let expected_path = docs_root.join(\"strategies/invalid-strategy/strategy.md\");\n        assert!(!expected_path.exists());\n    }\n\n    #[tokio::test]\n    async fn test_render_vision_single_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"Product Vision\".to_string())\n            .with_stakeholders(vec![\"Product\".to_string(), \"Engineering\".to_string()]);\n\n        let result = render(DocumentType::Vision, context, docs_root).await;\n        assert!(result.is_ok());\n\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n        assert_eq!(file_path, docs_root.join(\"vision.md\"));\n\n        // Verify file contents\n        let content = std::fs::read_to_string(\u0026file_path).unwrap();\n        assert!(content.contains(\"Product Vision\"));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":12}},{"line":16,"address":[],"length":0,"stats":{"Line":24}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":22}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":11}},{"line":30,"address":[],"length":0,"stats":{"Line":11}},{"line":34,"address":[],"length":0,"stats":{"Line":11}},{"line":35,"address":[],"length":0,"stats":{"Line":11}},{"line":36,"address":[],"length":0,"stats":{"Line":11}},{"line":38,"address":[],"length":0,"stats":{"Line":11}}],"covered":10,"coverable":12},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","sync.rs"],"content":"//! File synchronization engine for maintaining consistency between filesystem and database\n\nuse crate::{DocumentStore, MetisError, Result};\nuse gray_matter;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::time::SystemTime;\n\n/// Result of a sync operation\n#[derive(Debug, Clone)]\npub struct SyncResult {\n    pub files_processed: usize,\n    pub files_updated: usize,\n    pub files_deleted: usize,\n    pub errors: Vec\u003cSyncError\u003e,\n}\n\n/// Error during sync operation\n#[derive(Debug, Clone)]\npub struct SyncError {\n    pub file_path: PathBuf,\n    pub error: String,\n}\n\n/// File sync engine for vault operations\n#[derive(Clone)]\npub struct SyncEngine {\n    store: DocumentStore,\n}\n\nimpl SyncEngine {\n    /// Create a new sync engine with the given document store\n    pub fn new(store: DocumentStore) -\u003e Self {\n        Self { store }\n    }\n\n    /// Sync all markdown files from the filesystem into the database\n    pub async fn sync_from_filesystem(\u0026self, vault_path: \u0026Path) -\u003e Result\u003cSyncResult\u003e {\n        let mut result = SyncResult {\n            files_processed: 0,\n            files_updated: 0,\n            files_deleted: 0,\n            errors: Vec::new(),\n        };\n\n        // Find all markdown files in the vault\n        let markdown_files = self.find_markdown_files(vault_path)?;\n\n        // Process each file\n        for file_path in \u0026markdown_files {\n            result.files_processed += 1;\n\n            match self.process_file(file_path).await {\n                Ok(was_updated) =\u003e {\n                    if was_updated {\n                        result.files_updated += 1;\n                    }\n                }\n                Err(e) =\u003e {\n                    result.errors.push(SyncError {\n                        file_path: file_path.clone(),\n                        error: e.to_string(),\n                    });\n                }\n            }\n        }\n\n        // Handle orphan cleanup (files deleted from filesystem but still in database)\n        let orphaned = self.find_orphaned_documents(\u0026markdown_files).await?;\n        for orphan_id in orphaned {\n            // Document deletion event\n            println!(\"SYNC EVENT: Document deleted - {}\", orphan_id);\n\n            match self.store.delete_document(\u0026orphan_id).await {\n                Ok(true) =\u003e result.files_deleted += 1,\n                Ok(false) =\u003e {} // Document didn't exist\n                Err(e) =\u003e result.errors.push(SyncError {\n                    file_path: PathBuf::from(format!(\"orphan:{}\", orphan_id)),\n                    error: e.to_string(),\n                }),\n            }\n        }\n\n        Ok(result)\n    }\n\n    /// Process a single markdown file, updating database if needed\n    async fn process_file(\u0026self, file_path: \u0026Path) -\u003e Result\u003cbool\u003e {\n        // Get current file metadata\n        let metadata = fs::metadata(file_path).map_err(MetisError::Io)?;\n\n        let current_size = metadata.len();\n        let current_mtime = metadata.modified().map_err(MetisError::Io)?;\n        let current_mtime_secs = current_mtime\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_secs_f64();\n\n        // Check if document exists in database by filepath\n        let existing_doc = self.get_existing_document_by_path(file_path).await?;\n\n        let file_changed = match \u0026existing_doc {\n            None =\u003e {\n                // New file - always process\n                true\n            }\n            Some(doc) =\u003e {\n                // Compare with stored metadata\n                let stored_size = doc.file_size.unwrap_or(0) as u64;\n                let stored_mtime = doc.file_modified_at.unwrap_or(0.0);\n\n                current_size != stored_size || current_mtime_secs != stored_mtime\n            }\n        };\n\n        if !file_changed {\n            return Ok(false); // No changes detected\n        }\n\n        // File has changed or is new - process it\n        let is_new_document = existing_doc.is_none();\n\n        // Store/update the document (this will update file metadata too)\n        self.store.store_document(file_path).await?;\n\n        // Handle the three basic events\n        if is_new_document {\n            // Document creation event\n            println!(\"SYNC EVENT: Document created - {}\", file_path.display());\n        } else {\n            // Document modification event\n            println!(\"SYNC EVENT: Document changed - {}\", file_path.display());\n        }\n\n        Ok(true)\n    }\n\n    /// Find all markdown files in the vault directory\n    fn find_markdown_files(\u0026self, vault_path: \u0026Path) -\u003e Result\u003cVec\u003cPathBuf\u003e\u003e {\n        let mut markdown_files = Vec::new();\n        self.find_markdown_files_recursive(vault_path, \u0026mut markdown_files)?;\n        Ok(markdown_files)\n    }\n\n    /// Recursively find markdown files\n    #[allow(clippy::only_used_in_recursion)]\n    fn find_markdown_files_recursive(\u0026self, dir: \u0026Path, files: \u0026mut Vec\u003cPathBuf\u003e) -\u003e Result\u003c()\u003e {\n        let entries = fs::read_dir(dir).map_err(MetisError::Io)?;\n\n        for entry in entries {\n            let entry = entry.map_err(MetisError::Io)?;\n            let path = entry.path();\n\n            if path.is_dir() {\n                // Skip hidden directories\n                if let Some(dir_name) = path.file_name() {\n                    if dir_name.to_string_lossy().starts_with('.') {\n                        continue;\n                    }\n                }\n                self.find_markdown_files_recursive(\u0026path, files)?;\n            } else if path.extension().is_some_and(|ext| ext == \"md\") {\n                files.push(path);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get existing document from database by filepath\n    async fn get_existing_document_by_path(\n        \u0026self,\n        file_path: \u0026Path,\n    ) -\u003e Result\u003cOption\u003ccrate::Document\u003e\u003e {\n        // Convert path to string for database query\n        let filepath_str = file_path.to_string_lossy().to_string();\n\n        // Query database by filepath\n        let record = sqlx::query!(\n            \"SELECT id, filepath, document_type, level, status, parent_id, \n                    created_at, updated_at, content_hash, frontmatter_json, \n                    exit_criteria_met, content, file_size, file_modified_at\n             FROM documents WHERE filepath = ?\",\n            filepath_str\n        )\n        .fetch_optional(self.store.pool())\n        .await?;\n\n        if let Some(row) = record {\n            let document_type: crate::DocumentType = row.document_type.parse().unwrap_or_default();\n            let level: crate::DocumentType = row.level.parse().unwrap_or_default();\n            let frontmatter: serde_json::Value =\n                serde_json::from_str(\u0026row.frontmatter_json).unwrap_or_default();\n            let created_at =\n                chrono::DateTime::from_timestamp(row.created_at as i64, 0).unwrap_or_default();\n            let updated_at =\n                chrono::DateTime::from_timestamp(row.updated_at as i64, 0).unwrap_or_default();\n\n            Ok(Some(crate::Document {\n                id: row.id.unwrap_or_default(),\n                filepath: row.filepath,\n                document_type,\n                level,\n                status: row.status,\n                parent_id: row.parent_id,\n                created_at,\n                updated_at,\n                content_hash: row.content_hash,\n                frontmatter,\n                exit_criteria_met: row.exit_criteria_met.unwrap_or(false),\n                content: row.content,\n                file_size: row.file_size,\n                file_modified_at: row.file_modified_at,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Check if file has changed based on size, mtime, or content hash\n    #[allow(dead_code)]\n    async fn file_has_changed(\n        \u0026self,\n        existing_doc: \u0026crate::Document,\n        file_size: u64,\n        modified_time: SystemTime,\n    ) -\u003e Result\u003cbool\u003e {\n        // First check file size - if different, definitely changed\n        let existing_metadata = fs::metadata(\u0026existing_doc.filepath).map_err(MetisError::Io)?;\n\n        if file_size != existing_metadata.len() {\n            return Ok(true);\n        }\n\n        // Then check modification time - if newer, likely changed\n        let existing_modified = existing_metadata.modified().map_err(MetisError::Io)?;\n\n        if modified_time \u003e existing_modified {\n            return Ok(true);\n        }\n\n        // If size and time are the same, assume no change\n        Ok(false)\n    }\n\n    /// Find documents in database that no longer have corresponding files\n    async fn find_orphaned_documents(\u0026self, existing_files: \u0026[PathBuf]) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        // Get all documents from database\n        let query_service = self.store.query_service();\n\n        // For simplicity, we'll check all document types\n        // In practice, we might want a more efficient \"get all documents\" query\n        let mut all_docs = Vec::new();\n\n        use crate::DocumentType;\n        for doc_type in [\n            DocumentType::Vision,\n            DocumentType::Strategy,\n            DocumentType::Initiative,\n            DocumentType::Task,\n            DocumentType::Adr,\n        ] {\n            let docs = query_service.find_documents_by_type(doc_type).await?;\n            all_docs.extend(docs);\n        }\n\n        let mut orphaned = Vec::new();\n\n        for doc in all_docs {\n            let doc_path = PathBuf::from(\u0026doc.filepath);\n            if !existing_files.contains(\u0026doc_path) \u0026\u0026 !doc_path.exists() {\n                orphaned.push(doc.id);\n            }\n        }\n\n        Ok(orphaned)\n    }\n\n    /// Validate consistency between filesystem and database\n    pub async fn validate_consistency(\u0026self, _vault_path: \u0026Path) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let issues = Vec::new();\n\n        // TODO: Implement consistency validation\n        // - Check all database documents have corresponding files\n        // - Check all markdown files are in database\n        // - Validate frontmatter schema compliance\n\n        Ok(issues)\n    }\n\n    /// Calculate content hash for a file\n    #[allow(dead_code)]\n    fn calculate_content_hash(\u0026self, content: \u0026str) -\u003e String {\n        use sha2::{Digest, Sha256};\n        let mut hasher = Sha256::new();\n        hasher.update(content.as_bytes());\n        format!(\"{:x}\", hasher.finalize())\n    }\n\n    /// Extract document ID from frontmatter\n    #[allow(dead_code)]\n    fn extract_document_id(\u0026self, content: \u0026str) -\u003e Option\u003cString\u003e {\n        let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(content);\n        if let Some(gray_matter::Pod::Hash(map)) = parsed.data {\n            if let Some(gray_matter::Pod::String(id)) = map.get(\"id\") {\n                return Some(id.clone());\n            }\n        }\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    async fn create_test_sync_engine() -\u003e (SyncEngine, TempDir) {\n        use sqlx::SqlitePool;\n        let pool = SqlitePool::connect(\":memory:\").await.unwrap();\n        let store = DocumentStore::from_pool(pool).await.unwrap();\n        let sync_engine = SyncEngine::new(store);\n        let temp_dir = TempDir::new().unwrap();\n        (sync_engine, temp_dir)\n    }\n\n    fn create_test_markdown_file(dir: \u0026Path, filename: \u0026str, content: \u0026str) -\u003e PathBuf {\n        let file_path = dir.join(filename);\n        fs::write(\u0026file_path, content).unwrap();\n        file_path\n    }\n\n    #[tokio::test]\n    async fn test_find_markdown_files() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        // Create test markdown files\n        create_test_markdown_file(temp_dir.path(), \"doc1.md\", \"# Test 1\");\n        create_test_markdown_file(temp_dir.path(), \"doc2.md\", \"# Test 2\");\n        create_test_markdown_file(temp_dir.path(), \"readme.txt\", \"Not markdown\"); // Should be ignored\n\n        // Create subdirectory with more files\n        let subdir = temp_dir.path().join(\"subdir\");\n        fs::create_dir(\u0026subdir).unwrap();\n        create_test_markdown_file(\u0026subdir, \"doc3.md\", \"# Test 3\");\n\n        let files = sync_engine.find_markdown_files(temp_dir.path()).unwrap();\n\n        assert_eq!(files.len(), 3);\n        assert!(files.iter().any(|p| p.file_name().unwrap() == \"doc1.md\"));\n        assert!(files.iter().any(|p| p.file_name().unwrap() == \"doc2.md\"));\n        assert!(files.iter().any(|p| p.file_name().unwrap() == \"doc3.md\"));\n    }\n\n    #[tokio::test]\n    async fn test_sync_from_filesystem() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        // Create test documents with proper frontmatter\n        let doc1_content = r#\"---\nid: test-doc-1\nlevel: vision\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Document 1\n\"#;\n\n        let doc2_content = r#\"---\nid: test-doc-2\nlevel: strategy\nstatus: active\nphase: design\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Document 2\n\"#;\n\n        create_test_markdown_file(temp_dir.path(), \"doc1.md\", doc1_content);\n        create_test_markdown_file(temp_dir.path(), \"doc2.md\", doc2_content);\n\n        let result = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n\n        assert_eq!(result.files_processed, 2);\n        assert_eq!(result.files_updated, 2);\n        assert_eq!(result.files_deleted, 0);\n        assert!(result.errors.is_empty());\n\n        // Verify documents were stored\n        let doc1 = sync_engine.store.get_document(\"test-doc-1\").await.unwrap();\n        assert!(doc1.is_some());\n        assert_eq!(doc1.unwrap().id, \"test-doc-1\");\n\n        let doc2 = sync_engine.store.get_document(\"test-doc-2\").await.unwrap();\n        assert!(doc2.is_some());\n        assert_eq!(doc2.unwrap().id, \"test-doc-2\");\n    }\n\n    #[tokio::test]\n    async fn test_orphan_cleanup() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        // Create initial document\n        let doc_content = r#\"---\nid: test-orphan\nlevel: task\nstatus: todo\nphase: todo\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Orphan Document\n\"#;\n\n        let doc_path = create_test_markdown_file(temp_dir.path(), \"orphan.md\", doc_content);\n\n        // First sync - document should be added\n        let result1 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result1.files_processed, 1);\n        assert_eq!(result1.files_updated, 1);\n        assert_eq!(result1.files_deleted, 0);\n\n        // Verify document exists\n        let doc = sync_engine.store.get_document(\"test-orphan\").await.unwrap();\n        assert!(doc.is_some());\n\n        // Delete the file from filesystem\n        fs::remove_file(\u0026doc_path).unwrap();\n\n        // Second sync - document should be removed from database\n        let result2 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result2.files_processed, 0); // No files to process\n        assert_eq!(result2.files_updated, 0);\n        assert_eq!(result2.files_deleted, 1); // One orphan removed\n\n        // Verify document no longer exists\n        let doc_after = sync_engine.store.get_document(\"test-orphan\").await.unwrap();\n        assert!(doc_after.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_incremental_sync() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        let doc_content = r#\"---\nid: test-incremental\nlevel: vision\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Incremental Document\n\"#;\n\n        create_test_markdown_file(temp_dir.path(), \"incremental.md\", doc_content);\n\n        // First sync\n        let result1 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result1.files_updated, 1);\n\n        // Second sync with no changes - sync engine should detect no changes\n        let result2 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result2.files_processed, 1);\n        assert_eq!(result2.files_updated, 0); // No changes detected, file not updated\n    }\n\n    #[tokio::test]\n    async fn test_sync_event_detection() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        let doc_content = r#\"---\nid: test-sync-events\nlevel: task\nstatus: todo\nphase: todo\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Sync Events Document\n\"#;\n\n        let doc_path = create_test_markdown_file(temp_dir.path(), \"events.md\", doc_content);\n\n        // First sync - should detect creation event\n        let result1 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result1.files_updated, 1);\n        assert_eq!(result1.files_deleted, 0);\n\n        // Modify the document content\n        let updated_content = r#\"---\nid: test-sync-events\nlevel: task\nstatus: doing\nphase: doing\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Sync Events Document\n\nThis content has been updated!\n\"#;\n\n        fs::write(\u0026doc_path, updated_content).unwrap();\n\n        // Second sync - should detect modification event\n        let result2 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result2.files_updated, 1);\n        assert_eq!(result2.files_deleted, 0);\n\n        // Delete the file\n        fs::remove_file(\u0026doc_path).unwrap();\n\n        // Third sync - should detect deletion event\n        let result3 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result3.files_processed, 0); // No files to process\n        assert_eq!(result3.files_updated, 0);\n        assert_eq!(result3.files_deleted, 1); // One file deleted\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":11}},{"line":38,"address":[],"length":0,"stats":{"Line":28}},{"line":43,"address":[],"length":0,"stats":{"Line":14}},{"line":47,"address":[],"length":0,"stats":{"Line":28}},{"line":50,"address":[],"length":0,"stats":{"Line":56}},{"line":51,"address":[],"length":0,"stats":{"Line":21}},{"line":53,"address":[],"length":0,"stats":{"Line":21}},{"line":54,"address":[],"length":0,"stats":{"Line":11}},{"line":55,"address":[],"length":0,"stats":{"Line":19}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":59,"address":[],"length":0,"stats":{"Line":10}},{"line":60,"address":[],"length":0,"stats":{"Line":10}},{"line":61,"address":[],"length":0,"stats":{"Line":10}},{"line":62,"address":[],"length":0,"stats":{"Line":10}},{"line":69,"address":[],"length":0,"stats":{"Line":28}},{"line":70,"address":[],"length":0,"stats":{"Line":18}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":14}},{"line":88,"address":[],"length":0,"stats":{"Line":42}},{"line":90,"address":[],"length":0,"stats":{"Line":42}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":21}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":21}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":17}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":7}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":18}},{"line":124,"address":[],"length":0,"stats":{"Line":28}},{"line":127,"address":[],"length":0,"stats":{"Line":15}},{"line":129,"address":[],"length":0,"stats":{"Line":7}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":15}},{"line":140,"address":[],"length":0,"stats":{"Line":15}},{"line":141,"address":[],"length":0,"stats":{"Line":15}},{"line":142,"address":[],"length":0,"stats":{"Line":15}},{"line":147,"address":[],"length":0,"stats":{"Line":42}},{"line":148,"address":[],"length":0,"stats":{"Line":84}},{"line":150,"address":[],"length":0,"stats":{"Line":182}},{"line":151,"address":[],"length":0,"stats":{"Line":140}},{"line":156,"address":[],"length":0,"stats":{"Line":54}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":27}},{"line":162,"address":[],"length":0,"stats":{"Line":110}},{"line":163,"address":[],"length":0,"stats":{"Line":24}},{"line":167,"address":[],"length":0,"stats":{"Line":42}},{"line":171,"address":[],"length":0,"stats":{"Line":21}},{"line":176,"address":[],"length":0,"stats":{"Line":21}},{"line":179,"address":[],"length":0,"stats":{"Line":42}},{"line":184,"address":[],"length":0,"stats":{"Line":21}},{"line":186,"address":[],"length":0,"stats":{"Line":21}},{"line":187,"address":[],"length":0,"stats":{"Line":21}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":17}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":28}},{"line":249,"address":[],"length":0,"stats":{"Line":14}},{"line":253,"address":[],"length":0,"stats":{"Line":14}},{"line":256,"address":[],"length":0,"stats":{"Line":70}},{"line":257,"address":[],"length":0,"stats":{"Line":14}},{"line":258,"address":[],"length":0,"stats":{"Line":14}},{"line":259,"address":[],"length":0,"stats":{"Line":14}},{"line":260,"address":[],"length":0,"stats":{"Line":14}},{"line":261,"address":[],"length":0,"stats":{"Line":14}},{"line":263,"address":[],"length":0,"stats":{"Line":140}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":14}},{"line":269,"address":[],"length":0,"stats":{"Line":44}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}}],"covered":70,"coverable":128},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","template.rs"],"content":"//! Template engine for document rendering\n\nuse crate::context::DocumentContext;\nuse crate::{DocumentType, MetisError, Result};\nuse include_dir::{include_dir, Dir};\nuse std::collections::HashMap;\nuse tera::{Context, Tera};\n\n/// Template engine for rendering documents\nstatic TEMPLATES_DIR: Dir\u003c'_\u003e = include_dir!(\"$CARGO_MANIFEST_DIR/src/templates\");\n\npub struct TemplateEngine {\n    tera: Tera,\n}\n\nimpl TemplateEngine {\n    /// Create a new template engine with all bundled templates\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let mut tera = Tera::new(\"templates/**/*\").unwrap_or_default();\n\n        // Load templates from bundled directory\n        let mut templates = HashMap::new();\n\n        fn load_templates_recursive(\n            dir: \u0026Dir,\n            path_prefix: \u0026str,\n            templates: \u0026mut HashMap\u003cString, String\u003e,\n        ) -\u003e Result\u003c()\u003e {\n            for entry in dir.entries() {\n                match entry {\n                    include_dir::DirEntry::Dir(subdir) =\u003e {\n                        let new_prefix = if path_prefix.is_empty() {\n                            subdir\n                                .path()\n                                .file_name()\n                                .unwrap()\n                                .to_string_lossy()\n                                .to_string()\n                        } else {\n                            format!(\n                                \"{}/{}\",\n                                path_prefix,\n                                subdir.path().file_name().unwrap().to_string_lossy()\n                            )\n                        };\n                        load_templates_recursive(subdir, \u0026new_prefix, templates)?;\n                    }\n                    include_dir::DirEntry::File(file) =\u003e {\n                        let filename = file.path().file_name().unwrap().to_string_lossy();\n                        let template_name = if path_prefix.is_empty() {\n                            filename.to_string()\n                        } else {\n                            format!(\"{}/{}\", path_prefix, filename)\n                        };\n\n                        let content =\n                            file.contents_utf8()\n                                .ok_or_else(|| MetisError::ValidationFailed {\n                                    message: format!(\n                                        \"Template {} is not valid UTF-8\",\n                                        template_name\n                                    ),\n                                })?;\n\n                        templates.insert(template_name, content.to_string());\n                    }\n                }\n            }\n            Ok(())\n        }\n\n        load_templates_recursive(\u0026TEMPLATES_DIR, \"\", \u0026mut templates)?;\n\n        // Add templates to Tera\n        for (name, content) in templates {\n            tera.add_raw_template(\u0026name, \u0026content)\n                .map_err(|e| MetisError::ValidationFailed {\n                    message: format!(\"Failed to parse template {}: {}\", name, e),\n                })?;\n        }\n\n        Ok(Self { tera })\n    }\n\n    /// Render a complete document (frontmatter + content + postmatter)\n    pub fn render_document(\n        \u0026self,\n        doc_type: \u0026DocumentType,\n        context: \u0026DocumentContext,\n    ) -\u003e Result\u003cString\u003e {\n        // Validate context for document type\n        context.validate_for_type(doc_type)?;\n\n        let type_name = match doc_type {\n            DocumentType::Strategy =\u003e \"strategy\",\n            DocumentType::Initiative =\u003e \"initiative\",\n            DocumentType::Task =\u003e \"task\",\n            DocumentType::Vision =\u003e \"vision\",\n            DocumentType::Adr =\u003e \"adr\",\n        };\n\n        // Create Tera context\n        let mut tera_context = Context::new();\n        tera_context.insert(\"title\", \u0026context.title);\n        tera_context.insert(\"slug\", \u0026context.slug);\n        tera_context.insert(\n            \"created_at\",\n            \u0026context.created_at.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string(),\n        );\n        tera_context.insert(\n            \"updated_at\",\n            \u0026context.updated_at.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string(),\n        );\n\n        if let Some(ref parent) = context.parent_title {\n            tera_context.insert(\"parent_title\", parent);\n            // Generate parent ID based on the parent title\n            // For now, we'll infer the parent type from the document type hierarchy\n            let parent_id = match doc_type {\n                DocumentType::Strategy =\u003e \"metis-vision\".to_string(), // Strategies have vision as parent\n                DocumentType::Initiative =\u003e {\n                    format!(\"strategy-{}\", DocumentContext::title_to_slug(parent))\n                }\n                DocumentType::Task =\u003e {\n                    format!(\"initiative-{}\", DocumentContext::title_to_slug(parent))\n                }\n                _ =\u003e DocumentContext::title_to_slug(parent), // Default case\n            };\n            tera_context.insert(\"parent_id\", \u0026parent_id);\n        } else {\n            tera_context.insert(\"parent_title\", \"\");\n            tera_context.insert(\"parent_id\", \"\");\n        }\n\n        tera_context.insert(\"blocked_by\", \u0026context.blocked_by);\n        tera_context.insert(\"stakeholders\", \u0026context.stakeholders);\n\n        // Always provide these fields to templates even if empty\n        tera_context.insert(\n            \"technical_lead\",\n            \u0026context.technical_lead.as_deref().unwrap_or(\"\"),\n        );\n        tera_context.insert(\n            \"decision_maker\",\n            \u0026context.decision_maker.as_deref().unwrap_or(\"\"),\n        );\n        if let Some(decision_date) = context.decision_date {\n            tera_context.insert(\n                \"decision_date\",\n                \u0026decision_date.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string(),\n            );\n        } else {\n            tera_context.insert(\"decision_date\", \"\");\n        }\n        if let Some(number) = context.number {\n            tera_context.insert(\"number\", \u0026number);\n        } else {\n            tera_context.insert(\"number\", \u00260u32);\n        }\n        if let Some(complexity) = context.complexity {\n            tera_context.insert(\"complexity\", \u0026format!(\"{:?}\", complexity));\n        } else {\n            tera_context.insert(\"complexity\", \"\");\n        }\n        if let Some(risk_level) = context.risk_level {\n            tera_context.insert(\"risk_level\", \u0026format!(\"{:?}\", risk_level).to_lowercase());\n        } else {\n            tera_context.insert(\"risk_level\", \"medium\");\n        }\n\n        // Render each part\n        let frontmatter =\n            self.render_template(\u0026format!(\"{}/frontmatter.yaml\", type_name), \u0026tera_context)?;\n        let content = self.render_template(\u0026format!(\"{}/content.md\", type_name), \u0026tera_context)?;\n        let postmatter =\n            self.render_template(\u0026format!(\"{}/postmatter.md\", type_name), \u0026tera_context)?;\n\n        // Combine with proper YAML frontmatter formatting\n        Ok(format!(\n            \"---\\n{}\\n---\\n\\n{}\\n\\n{}\",\n            frontmatter, content, postmatter\n        ))\n    }\n\n    /// Render a specific template with context\n    pub fn render_template(\u0026self, template_name: \u0026str, context: \u0026Context) -\u003e Result\u003cString\u003e {\n        self.tera\n            .render(template_name, context)\n            .map_err(|e| MetisError::ValidationFailed {\n                message: format!(\"Template rendering failed for {}: {}\", template_name, e),\n            })\n    }\n\n    /// Generate destination path for a document based on type and context\n    pub fn generate_destination_path(\n        \u0026self,\n        doc_type: \u0026DocumentType,\n        context: \u0026DocumentContext,\n    ) -\u003e String {\n        match doc_type {\n            DocumentType::Vision =\u003e \"vision.md\".to_string(),\n            DocumentType::Strategy =\u003e {\n                format!(\"strategies/{}/strategy.md\", context.slug)\n            }\n            DocumentType::Initiative =\u003e {\n                if let Some(ref parent) = context.parent_title {\n                    let parent_slug = DocumentContext::title_to_slug(parent);\n                    format!(\n                        \"strategies/{}/initiatives/{}/initiative.md\",\n                        parent_slug, context.slug\n                    )\n                } else {\n                    format!(\"initiatives/{}/initiative.md\", context.slug)\n                }\n            }\n            DocumentType::Task =\u003e {\n                if let Some(ref parent) = context.parent_title {\n                    // For tasks, we need to traverse up to find the strategy\n                    // This is a simplified version - in practice we'd query the database\n                    let parent_slug = DocumentContext::title_to_slug(parent);\n                    format!(\n                        \"strategies/*/initiatives/{}/tasks/{}.md\",\n                        parent_slug, context.slug\n                    )\n                } else {\n                    format!(\"tasks/{}.md\", context.slug)\n                }\n            }\n            DocumentType::Adr =\u003e {\n                if let Some(number) = context.number {\n                    format!(\"decisions/adr-{:03}-{}.md\", number, context.slug)\n                } else {\n                    format!(\"decisions/{}.md\", context.slug)\n                }\n            }\n        }\n    }\n\n    /// List all available templates\n    pub fn list_templates(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.tera\n            .get_template_names()\n            .map(|s| s.to_string())\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::context::{Complexity, RiskLevel};\n\n    #[test]\n    fn test_template_engine_creation() {\n        let engine = TemplateEngine::new();\n        assert!(engine.is_ok());\n\n        let engine = engine.unwrap();\n        let templates = engine.list_templates();\n        eprintln!(\"Available templates: {:?}\", templates);\n        assert!(!templates.is_empty());\n\n        // Check that we have templates for all document types\n        assert!(templates.iter().any(|t| t.contains(\"strategy\")));\n        assert!(templates.iter().any(|t| t.contains(\"initiative\")));\n        assert!(templates.iter().any(|t| t.contains(\"task\")));\n        assert!(templates.iter().any(|t| t.contains(\"vision\")));\n        assert!(templates.iter().any(|t| t.contains(\"adr\")));\n    }\n\n    #[test]\n    fn test_strategy_document_rendering() {\n        let engine = TemplateEngine::new().unwrap();\n        let context = DocumentContext::new(\"Test Strategy\".to_string())\n            .with_risk_level(RiskLevel::High)\n            .with_stakeholders(vec![\"Engineering\".to_string(), \"Product\".to_string()]);\n\n        let result = engine.render_document(\u0026DocumentType::Strategy, \u0026context);\n        if let Err(ref e) = result {\n            eprintln!(\"Render error: {:?}\", e);\n        }\n        assert!(result.is_ok());\n\n        let rendered = result.unwrap();\n        assert!(rendered.contains(\"---\\n\")); // Has frontmatter\n        assert!(rendered.contains(\"# Test Strategy Strategy\")); // Has content\n        assert!(rendered.contains(\"test-strategy\")); // Has slug\n        assert!(rendered.contains(\"high\")); // Has risk level\n    }\n\n    #[test]\n    fn test_initiative_document_rendering() {\n        let engine = TemplateEngine::new().unwrap();\n        let context = DocumentContext::new(\"Test Initiative\".to_string())\n            .with_parent(\"Parent Strategy\".to_string())\n            .with_complexity(Complexity::L)\n            .with_technical_lead(\"Alice Smith\".to_string());\n\n        let result = engine.render_document(\u0026DocumentType::Initiative, \u0026context);\n        assert!(result.is_ok());\n\n        let rendered = result.unwrap();\n        assert!(rendered.contains(\"---\\n\")); // Has frontmatter\n        assert!(rendered.contains(\"# Test Initiative\")); // Has content\n        assert!(rendered.contains(\"strategy-parent-strategy\")); // Has parent ID\n        assert!(rendered.contains(\"L\")); // Has complexity\n        assert!(rendered.contains(\"Alice Smith\")); // Has technical lead\n    }\n\n    #[test]\n    fn test_adr_document_rendering() {\n        let engine = TemplateEngine::new().unwrap();\n        let context = DocumentContext::new(\"Use Database for Storage\".to_string())\n            .with_decision_maker(\"Architecture Team\".to_string())\n            .with_number(5);\n\n        let result = engine.render_document(\u0026DocumentType::Adr, \u0026context);\n        if let Err(ref e) = result {\n            eprintln!(\"ADR render error: {:?}\", e);\n        }\n        assert!(result.is_ok());\n\n        let rendered = result.unwrap();\n        assert!(rendered.contains(\"---\\n\")); // Has frontmatter\n        assert!(rendered.contains(\"Use Database for Storage\")); // Has title\n        assert!(rendered.contains(\"Architecture Team\")); // Has decision maker\n        assert!(rendered.contains(\"5\")); // Has ADR number\n    }\n\n    #[test]\n    fn test_validation_failure_on_missing_required_fields() {\n        let engine = TemplateEngine::new().unwrap();\n\n        // Strategy without risk_level should fail\n        let strategy_context = DocumentContext::new(\"Test Strategy\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Strategy, \u0026strategy_context);\n        assert!(result.is_err());\n\n        // Initiative without complexity should fail\n        let initiative_context = DocumentContext::new(\"Test Initiative\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Initiative, \u0026initiative_context);\n        assert!(result.is_err());\n\n        // ADR without decision_maker should fail\n        let adr_context = DocumentContext::new(\"Test ADR\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Adr, \u0026adr_context);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_destination_path_generation() {\n        let engine = TemplateEngine::new().unwrap();\n\n        // Vision\n        let vision_context = DocumentContext::new(\"Product Vision\".to_string());\n        assert_eq!(\n            engine.generate_destination_path(\u0026DocumentType::Vision, \u0026vision_context),\n            \"vision.md\"\n        );\n\n        // Strategy\n        let strategy_context = DocumentContext::new(\"Core Platform Strategy\".to_string());\n        assert_eq!(\n            engine.generate_destination_path(\u0026DocumentType::Strategy, \u0026strategy_context),\n            \"strategies/core-platform-strategy/strategy.md\"\n        );\n\n        // Initiative with parent\n        let initiative_context = DocumentContext::new(\"API Design\".to_string())\n            .with_parent(\"Core Platform Strategy\".to_string());\n        assert_eq!(\n            engine.generate_destination_path(\u0026DocumentType::Initiative, \u0026initiative_context),\n            \"strategies/core-platform-strategy/initiatives/api-design/initiative.md\"\n        );\n\n        // ADR with number\n        let adr_context = DocumentContext::new(\"Use GraphQL\".to_string()).with_number(42);\n        assert_eq!(\n            engine.generate_destination_path(\u0026DocumentType::Adr, \u0026adr_context),\n            \"decisions/adr-042-use-graphql.md\"\n        );\n    }\n\n    #[test]\n    fn test_vision_and_task_render_without_extra_fields() {\n        let engine = TemplateEngine::new().unwrap();\n\n        // Vision should render without any extra fields\n        let vision_context = DocumentContext::new(\"Product Vision\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Vision, \u0026vision_context);\n        assert!(result.is_ok());\n\n        // Task should render without any extra fields\n        let task_context = DocumentContext::new(\"Implement Feature\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Task, \u0026task_context);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":41}},{"line":19,"address":[],"length":0,"stats":{"Line":41}},{"line":22,"address":[],"length":0,"stats":{"Line":41}},{"line":24,"address":[],"length":0,"stats":{"Line":246}},{"line":29,"address":[],"length":0,"stats":{"Line":1066}},{"line":30,"address":[],"length":0,"stats":{"Line":820}},{"line":31,"address":[],"length":0,"stats":{"Line":205}},{"line":33,"address":[],"length":0,"stats":{"Line":205}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":615}},{"line":49,"address":[],"length":0,"stats":{"Line":615}},{"line":50,"address":[],"length":0,"stats":{"Line":1230}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":615}},{"line":56,"address":[],"length":0,"stats":{"Line":615}},{"line":57,"address":[],"length":0,"stats":{"Line":615}},{"line":58,"address":[],"length":0,"stats":{"Line":615}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":246}},{"line":72,"address":[],"length":0,"stats":{"Line":41}},{"line":75,"address":[],"length":0,"stats":{"Line":1271}},{"line":76,"address":[],"length":0,"stats":{"Line":615}},{"line":77,"address":[],"length":0,"stats":{"Line":615}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":41}},{"line":86,"address":[],"length":0,"stats":{"Line":41}},{"line":92,"address":[],"length":0,"stats":{"Line":44}},{"line":94,"address":[],"length":0,"stats":{"Line":38}},{"line":95,"address":[],"length":0,"stats":{"Line":5}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":24}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":8}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":30}},{"line":132,"address":[],"length":0,"stats":{"Line":30}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":38}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":36}},{"line":160,"address":[],"length":0,"stats":{"Line":6}},{"line":163,"address":[],"length":0,"stats":{"Line":32}},{"line":165,"address":[],"length":0,"stats":{"Line":5}},{"line":168,"address":[],"length":0,"stats":{"Line":33}},{"line":172,"address":[],"length":0,"stats":{"Line":38}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":38}},{"line":175,"address":[],"length":0,"stats":{"Line":38}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":114}},{"line":187,"address":[],"length":0,"stats":{"Line":114}},{"line":188,"address":[],"length":0,"stats":{"Line":114}},{"line":189,"address":[],"length":0,"stats":{"Line":114}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":15}},{"line":200,"address":[],"length":0,"stats":{"Line":15}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":5}},{"line":206,"address":[],"length":0,"stats":{"Line":12}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":4}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":17}}],"covered":57,"coverable":76},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","updates.rs"],"content":"//! Document update operations for surgical content modifications\n\nuse crate::{validate_content, MetisError, Result};\nuse chrono::Utc;\nuse gray_matter;\nuse std::fs;\nuse std::path::Path;\n\n/// Update specific document sections using markdown heading navigation\npub async fn update_document_content(\n    document_path: \u0026Path,\n    section_heading: \u0026str,\n    new_content: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    // Read the document file\n    let raw_content = fs::read_to_string(document_path).map_err(MetisError::Io)?;\n\n    // Parse frontmatter and content\n    let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026raw_content);\n    let frontmatter_yaml = if let Some(data) = parsed.data {\n        // Convert Pod to YAML string for reconstruction\n        match data {\n            gray_matter::Pod::Hash(_) =\u003e {\n                // Extract the original frontmatter YAML from the raw content\n                extract_frontmatter_yaml(\u0026raw_content)?\n            }\n            _ =\u003e String::new(),\n        }\n    } else {\n        String::new()\n    };\n\n    let content = parsed.content;\n\n    // Update the section content\n    let updated_content = update_section_in_content(\u0026content, section_heading, new_content)?;\n\n    // Reconstruct the document\n    let final_document = if frontmatter_yaml.is_empty() {\n        updated_content\n    } else {\n        format!(\"---\\n{}\\n---\\n\\n{}\", frontmatter_yaml, updated_content)\n    };\n\n    // Validate the updated document\n    validate_content(\u0026final_document).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Updated document failed validation: {}\", e),\n    })?;\n\n    // Write the updated document back atomically\n    write_file_atomic(document_path, \u0026final_document)?;\n\n    Ok(())\n}\n\n/// Update exit criteria checkbox completion status\npub async fn update_exit_criterion(\n    document_path: \u0026Path,\n    criterion_text: \u0026str,\n    completed: bool,\n) -\u003e Result\u003c()\u003e {\n    // Read the document file\n    let raw_content = fs::read_to_string(document_path).map_err(MetisError::Io)?;\n\n    // Parse frontmatter and content\n    let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026raw_content);\n    let frontmatter_yaml = if parsed.data.is_some() {\n        extract_frontmatter_yaml(\u0026raw_content)?\n    } else {\n        String::new()\n    };\n\n    let content = parsed.content;\n\n    // Update the checkbox in content\n    let updated_content = update_checkbox_in_content(\u0026content, criterion_text, completed)?;\n\n    // Check if all criteria are now complete\n    let all_complete = check_all_criteria_complete(\u0026updated_content)?;\n\n    // Update frontmatter with new exit_criteria_met status and timestamp\n    let updated_frontmatter = update_frontmatter_exit_criteria(\u0026frontmatter_yaml, all_complete)?;\n\n    // Reconstruct the document\n    let final_document = if updated_frontmatter.is_empty() {\n        updated_content\n    } else {\n        format!(\"---\\n{}\\n---\\n\\n{}\", updated_frontmatter, updated_content)\n    };\n\n    // Validate the updated document\n    validate_content(\u0026final_document).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Updated document failed validation: {}\", e),\n    })?;\n\n    // Write the updated document back atomically\n    write_file_atomic(document_path, \u0026final_document)?;\n\n    Ok(())\n}\n\n/// Update blocked_by relationships in document frontmatter\npub async fn update_blocked_by(document_path: \u0026Path, blocked_by: Vec\u003cString\u003e) -\u003e Result\u003c()\u003e {\n    // Read the document file\n    let raw_content = fs::read_to_string(document_path).map_err(MetisError::Io)?;\n\n    // Parse frontmatter and content\n    let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026raw_content);\n    let frontmatter_yaml = if parsed.data.is_some() {\n        extract_frontmatter_yaml(\u0026raw_content)?\n    } else {\n        return Err(MetisError::ValidationFailed {\n            message: \"Document has no frontmatter to update\".to_string(),\n        });\n    };\n\n    let content = parsed.content;\n\n    // Validate blocked_by references\n    validate_blocked_by_references(\u0026blocked_by)?;\n\n    // Update frontmatter with new blocked_by and timestamp\n    let updated_frontmatter = update_frontmatter_blocked_by(\u0026frontmatter_yaml, \u0026blocked_by)?;\n\n    // Reconstruct the document\n    let final_document = format!(\"---\\n{}\\n---\\n\\n{}\", updated_frontmatter, content);\n\n    // Validate the updated document\n    validate_content(\u0026final_document).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Updated document failed validation: {}\", e),\n    })?;\n\n    // Write the updated document back atomically\n    write_file_atomic(document_path, \u0026final_document)?;\n\n    Ok(())\n}\n\n/// Update a section within content text, preserving structure\nfn update_section_in_content(\n    content: \u0026str,\n    section_heading: \u0026str,\n    new_content: \u0026str,\n) -\u003e Result\u003cString\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let target_heading = format!(\"## {}\", section_heading);\n\n    // Find the section start\n    let section_start = lines.iter().position(|line| {\n        line.trim() == target_heading\n    }).ok_or_else(|| MetisError::ValidationFailed {\n        message: format!(\"H2 section '## {}' not found in document. Provide heading text only (e.g., 'Problem Statement' for '## Problem Statement')\", section_heading),\n    })?;\n\n    // Find the section end (next ## heading or end of document)\n    let section_end = lines[section_start + 1..]\n        .iter()\n        .position(|line| line.trim_start().starts_with(\"## \"))\n        .map(|pos| section_start + 1 + pos)\n        .unwrap_or(lines.len());\n\n    // Build the updated content\n    let mut updated_lines = Vec::new();\n\n    // Add content before the section\n    updated_lines.extend_from_slice(\u0026lines[..section_start + 1]);\n\n    // Add empty line after heading if new content exists\n    if !new_content.trim().is_empty() {\n        updated_lines.push(\"\");\n\n        // Add the new content\n        for line in new_content.lines() {\n            updated_lines.push(line);\n        }\n    }\n\n    // Add content after the section\n    if section_end \u003c lines.len() {\n        updated_lines.push(\"\"); // Empty line before next section\n        updated_lines.extend_from_slice(\u0026lines[section_end..]);\n    }\n\n    Ok(updated_lines.join(\"\\n\"))\n}\n\n/// Extract original frontmatter YAML from raw content\nfn extract_frontmatter_yaml(raw_content: \u0026str) -\u003e Result\u003cString\u003e {\n    if !raw_content.starts_with(\"---\\n\") {\n        return Ok(String::new());\n    }\n\n    let content_after_first_marker = \u0026raw_content[4..]; // Skip \"---\\n\"\n    if let Some(end_pos) = content_after_first_marker.find(\"\\n---\\n\") {\n        Ok(content_after_first_marker[..end_pos].to_string())\n    } else {\n        Err(MetisError::ValidationFailed {\n            message: \"Invalid frontmatter format - missing closing marker\".to_string(),\n        })\n    }\n}\n\n/// Update checkbox state in content for a specific criterion\nfn update_checkbox_in_content(\n    content: \u0026str,\n    criterion_text: \u0026str,\n    completed: bool,\n) -\u003e Result\u003cString\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n\n    // Find the Exit Criteria section\n    let exit_criteria_start = lines\n        .iter()\n        .position(|line| line.trim() == \"## Exit Criteria\")\n        .ok_or_else(|| MetisError::ValidationFailed {\n            message: \"Exit Criteria section not found in document\".to_string(),\n        })?;\n\n    // Find the end of the Exit Criteria section\n    let exit_criteria_end = lines[exit_criteria_start + 1..]\n        .iter()\n        .position(|line| line.trim_start().starts_with(\"## \"))\n        .map(|pos| exit_criteria_start + 1 + pos)\n        .unwrap_or(lines.len());\n\n    // Find matching criteria within the section\n    let mut matching_lines = Vec::new();\n    for (i, line) in lines[exit_criteria_start + 1..exit_criteria_end]\n        .iter()\n        .enumerate()\n    {\n        if is_checkbox_line(line) \u0026\u0026 line.to_lowercase().contains(\u0026criterion_text.to_lowercase()) {\n            matching_lines.push(exit_criteria_start + 1 + i);\n        }\n    }\n\n    // Check for ambiguous matches\n    if matching_lines.is_empty() {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\"No exit criteria found matching text: '{}'\", criterion_text),\n        });\n    }\n\n    if matching_lines.len() \u003e 1 {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\n                \"Multiple exit criteria match text '{}' - please be more specific\",\n                criterion_text\n            ),\n        });\n    }\n\n    // Update the matching line\n    let target_line_idx = matching_lines[0];\n    let updated_lines: Vec\u003cString\u003e = lines\n        .iter()\n        .enumerate()\n        .map(|(i, line)| {\n            if i == target_line_idx {\n                update_checkbox_state(line, completed)\n            } else {\n                line.to_string()\n            }\n        })\n        .collect();\n\n    Ok(updated_lines.join(\"\\n\"))\n}\n\n/// Check if a line contains a checkbox\nfn is_checkbox_line(line: \u0026str) -\u003e bool {\n    let trimmed = line.trim_start();\n    trimmed.starts_with(\"- [ ]\") || trimmed.starts_with(\"- [x]\") || trimmed.starts_with(\"- [X]\")\n}\n\n/// Update the checkbox state in a single line\nfn update_checkbox_state(line: \u0026str, completed: bool) -\u003e String {\n    let checkbox = if completed { \"[x]\" } else { \"[ ]\" };\n\n    // Replace any checkbox pattern with the desired state\n    if line.trim_start().starts_with(\"- [ ]\") {\n        line.replacen(\"- [ ]\", \u0026format!(\"- {}\", checkbox), 1)\n    } else if line.trim_start().starts_with(\"- [x]\") {\n        line.replacen(\"- [x]\", \u0026format!(\"- {}\", checkbox), 1)\n    } else if line.trim_start().starts_with(\"- [X]\") {\n        line.replacen(\"- [X]\", \u0026format!(\"- {}\", checkbox), 1)\n    } else {\n        line.to_string()\n    }\n}\n\n/// Check if all exit criteria in the content are complete\nfn check_all_criteria_complete(content: \u0026str) -\u003e Result\u003cbool\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n\n    // Find the Exit Criteria section\n    let exit_criteria_start = lines\n        .iter()\n        .position(|line| line.trim() == \"## Exit Criteria\");\n\n    if exit_criteria_start.is_none() {\n        // No exit criteria section, consider complete\n        return Ok(true);\n    }\n\n    let start = exit_criteria_start.unwrap();\n    let exit_criteria_end = lines[start + 1..]\n        .iter()\n        .position(|line| line.trim_start().starts_with(\"## \"))\n        .map(|pos| start + 1 + pos)\n        .unwrap_or(lines.len());\n\n    // Check all checkbox lines in the section\n    for line in \u0026lines[start + 1..exit_criteria_end] {\n        if is_checkbox_line(line) \u0026\u0026 line.trim_start().starts_with(\"- [ ]\") {\n            return Ok(false); // Found incomplete criterion\n        }\n    }\n\n    Ok(true) // All criteria are complete\n}\n\n/// Update frontmatter with exit criteria status and timestamp\nfn update_frontmatter_exit_criteria(frontmatter_yaml: \u0026str, all_complete: bool) -\u003e Result\u003cString\u003e {\n    if frontmatter_yaml.is_empty() {\n        return Ok(String::new());\n    }\n\n    // Parse YAML\n    let mut frontmatter: serde_yaml::Value =\n        serde_yaml::from_str(frontmatter_yaml).map_err(|e| MetisError::ValidationFailed {\n            message: format!(\"Failed to parse frontmatter YAML: {}\", e),\n        })?;\n\n    // Update fields\n    if let serde_yaml::Value::Mapping(ref mut map) = frontmatter {\n        // Update exit_criteria_met\n        map.insert(\n            serde_yaml::Value::String(\"exit_criteria_met\".to_string()),\n            serde_yaml::Value::Bool(all_complete),\n        );\n\n        // Update updated_at timestamp\n        let now = Utc::now();\n        map.insert(\n            serde_yaml::Value::String(\"updated_at\".to_string()),\n            serde_yaml::Value::String(now.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string()),\n        );\n    }\n\n    // Serialize back to YAML\n    serde_yaml::to_string(\u0026frontmatter).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to serialize frontmatter YAML: {}\", e),\n    })\n}\n\n/// Validate blocked_by reference format\nfn validate_blocked_by_references(blocked_by: \u0026[String]) -\u003e Result\u003c()\u003e {\n    for reference in blocked_by {\n        if !is_valid_wiki_link_reference(reference) {\n            return Err(MetisError::ValidationFailed {\n                message: format!(\n                    \"Invalid reference format '{}'. Expected format: '[[Document Title]]'\",\n                    reference\n                ),\n            });\n        }\n    }\n    Ok(())\n}\n\n/// Check if a string is a valid wiki-link reference\nfn is_valid_wiki_link_reference(reference: \u0026str) -\u003e bool {\n    if reference.is_empty() {\n        return false;\n    }\n\n    // Must start with [[ and end with ]]\n    if !reference.starts_with(\"[[\") || !reference.ends_with(\"]]\") {\n        return false;\n    }\n\n    // Extract the inner content\n    let inner = \u0026reference[2..reference.len() - 2];\n\n    // Must not be empty and should not contain invalid characters\n    !inner.is_empty() \u0026\u0026 !inner.contains(\"[[\") \u0026\u0026 !inner.contains(\"]]\")\n}\n\n/// Update frontmatter with new blocked_by list and timestamp\nfn update_frontmatter_blocked_by(frontmatter_yaml: \u0026str, blocked_by: \u0026[String]) -\u003e Result\u003cString\u003e {\n    // Parse YAML\n    let mut frontmatter: serde_yaml::Value =\n        serde_yaml::from_str(frontmatter_yaml).map_err(|e| MetisError::ValidationFailed {\n            message: format!(\"Failed to parse frontmatter YAML: {}\", e),\n        })?;\n\n    // Update fields\n    if let serde_yaml::Value::Mapping(ref mut map) = frontmatter {\n        // Update blocked_by field\n        if blocked_by.is_empty() {\n            // Empty blocked_by should be represented as empty array or null\n            map.insert(\n                serde_yaml::Value::String(\"blocked_by\".to_string()),\n                serde_yaml::Value::Sequence(Vec::new()),\n            );\n        } else {\n            let blocked_by_values: Vec\u003cserde_yaml::Value\u003e = blocked_by\n                .iter()\n                .map(|s| serde_yaml::Value::String(s.clone()))\n                .collect();\n            map.insert(\n                serde_yaml::Value::String(\"blocked_by\".to_string()),\n                serde_yaml::Value::Sequence(blocked_by_values),\n            );\n        }\n\n        // Update updated_at timestamp\n        let now = Utc::now();\n        map.insert(\n            serde_yaml::Value::String(\"updated_at\".to_string()),\n            serde_yaml::Value::String(now.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string()),\n        );\n    }\n\n    // Serialize back to YAML\n    serde_yaml::to_string(\u0026frontmatter).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to serialize frontmatter YAML: {}\", e),\n    })\n}\n\n/// Write file atomically using a temporary file\nfn write_file_atomic(path: \u0026Path, content: \u0026str) -\u003e Result\u003c()\u003e {\n    let temp_path = path.with_extension(\"tmp\");\n\n    // Write to temporary file first\n    fs::write(\u0026temp_path, content).map_err(MetisError::Io)?;\n\n    // Atomic rename\n    fs::rename(\u0026temp_path, path).map_err(MetisError::Io)?;\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    fn create_test_document(content: \u0026str) -\u003e NamedTempFile {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        temp_file.write_all(content.as_bytes()).unwrap();\n        temp_file.flush().unwrap();\n        temp_file\n    }\n\n    #[test]\n    fn test_update_section_in_content_basic() {\n        let content = r#\"# Document Title\n\n## Introduction\n\nThis is the introduction.\n\n## Implementation\n\nOld implementation details.\n\n## Conclusion\n\nThis is the conclusion.\"#;\n\n        let result = update_section_in_content(\n            content,\n            \"Implementation\",\n            \"New implementation details.\\n\\nWith multiple paragraphs.\",\n        );\n\n        assert!(result.is_ok());\n        let updated = result.unwrap();\n\n        assert!(updated.contains(\"New implementation details.\"));\n        assert!(updated.contains(\"With multiple paragraphs.\"));\n        assert!(updated.contains(\"This is the introduction.\"));\n        assert!(updated.contains(\"This is the conclusion.\"));\n        assert!(!updated.contains(\"Old implementation details.\"));\n    }\n\n    #[test]\n    fn test_update_section_in_content_last_section() {\n        let content = r#\"# Document Title\n\n## Introduction\n\nThis is the introduction.\n\n## Conclusion\n\nOld conclusion.\"#;\n\n        let result =\n            update_section_in_content(content, \"Conclusion\", \"New conclusion with more details.\");\n\n        assert!(result.is_ok());\n        let updated = result.unwrap();\n\n        assert!(updated.contains(\"New conclusion with more details.\"));\n        assert!(updated.contains(\"This is the introduction.\"));\n        assert!(!updated.contains(\"Old conclusion.\"));\n    }\n\n    #[test]\n    fn test_update_section_in_content_empty_content() {\n        let content = r#\"# Document Title\n\n## Introduction\n\nThis is the introduction.\n\n## Implementation\n\nOld implementation details.\n\n## Conclusion\n\nThis is the conclusion.\"#;\n\n        let result = update_section_in_content(content, \"Implementation\", \"\");\n\n        assert!(result.is_ok());\n        let updated = result.unwrap();\n\n        assert!(!updated.contains(\"Old implementation details.\"));\n        assert!(updated.contains(\"This is the introduction.\"));\n        assert!(updated.contains(\"This is the conclusion.\"));\n\n        // Section heading should still be present\n        assert!(updated.contains(\"## Implementation\"));\n    }\n\n    #[test]\n    fn test_update_section_in_content_missing_section() {\n        let content = r#\"# Document Title\n\n## Introduction\n\nThis is the introduction.\"#;\n\n        let result = update_section_in_content(content, \"NonExistent\", \"New content\");\n\n        assert!(result.is_err());\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"H2 section '## NonExistent' not found\"));\n        } else {\n            panic!(\"Expected ValidationFailed error\");\n        }\n    }\n\n    #[test]\n    fn test_extract_frontmatter_yaml() {\n        let content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\ntags:\n  - \"#strategy\"\n  - \"#active\"\n---\n\n# Test Document\n\nContent here.\"##;\n\n        let result = extract_frontmatter_yaml(content);\n        assert!(result.is_ok());\n\n        let yaml = result.unwrap();\n        assert!(yaml.contains(\"id: test-document\"));\n        assert!(yaml.contains(\"level: strategy\"));\n        assert!(yaml.contains(\"status: active\"));\n        assert!(!yaml.contains(\"# Test Document\"));\n    }\n\n    #[test]\n    fn test_extract_frontmatter_yaml_no_frontmatter() {\n        let content = r#\"# Test Document\n\nJust content, no frontmatter.\"#;\n\n        let result = extract_frontmatter_yaml(content);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"\");\n    }\n\n    #[test]\n    fn test_extract_frontmatter_yaml_invalid() {\n        let content = r#\"---\nid: test-document\nlevel: strategy\n# Missing closing marker\"#;\n\n        let result = extract_frontmatter_yaml(content);\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_update_document_content_full() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the old problem statement.\n\n## Solution Approach\n\nThis section needs updating.\n\n## Exit Criteria\n\n- [ ] Criterion 1\n- [ ] Criterion 2\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let result = update_document_content(\n            temp_file.path(),\n            \"Solution Approach\",\n            \"This is the updated solution approach.\\n\\nWith more detailed implementation notes.\",\n        )\n        .await;\n\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify updates\n        assert!(updated_content.contains(\"This is the updated solution approach.\"));\n        assert!(updated_content.contains(\"With more detailed implementation notes.\"));\n        assert!(!updated_content.contains(\"This section needs updating.\"));\n\n        // Verify other sections preserved\n        assert!(updated_content.contains(\"This is the old problem statement.\"));\n        assert!(updated_content.contains(\"- [ ] Criterion 1\"));\n\n        // Verify frontmatter preserved\n        assert!(updated_content.contains(\"id: test-document\"));\n        assert!(updated_content.contains(\"level: strategy\"));\n    }\n\n    #[tokio::test]\n    async fn test_update_document_content_nonexistent_file() {\n        let result =\n            update_document_content(Path::new(\"/nonexistent/file.md\"), \"Section\", \"Content\").await;\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_is_checkbox_line() {\n        assert!(is_checkbox_line(\"- [ ] Incomplete task\"));\n        assert!(is_checkbox_line(\"- [x] Complete task\"));\n        assert!(is_checkbox_line(\"- [X] Complete task\"));\n        assert!(is_checkbox_line(\"  - [ ] Indented task\"));\n\n        assert!(!is_checkbox_line(\"- Regular list item\"));\n        assert!(!is_checkbox_line(\"Not a list\"));\n        assert!(!is_checkbox_line(\"- [invalid] Bad checkbox\"));\n    }\n\n    #[test]\n    fn test_update_checkbox_state() {\n        assert_eq!(\n            update_checkbox_state(\"- [ ] Complete this task\", true),\n            \"- [x] Complete this task\"\n        );\n        assert_eq!(\n            update_checkbox_state(\"- [x] Complete this task\", false),\n            \"- [ ] Complete this task\"\n        );\n        assert_eq!(\n            update_checkbox_state(\"- [X] Complete this task\", false),\n            \"- [ ] Complete this task\"\n        );\n        assert_eq!(\n            update_checkbox_state(\"  - [ ] Indented task\", true),\n            \"  - [x] Indented task\"\n        );\n    }\n\n    #[test]\n    fn test_check_all_criteria_complete() {\n        let content_all_complete = r#\"# Document\n\n## Exit Criteria\n\n- [x] First criterion\n- [x] Second criterion\n- [x] Third criterion\"#;\n\n        let content_incomplete = r#\"# Document\n\n## Exit Criteria\n\n- [x] First criterion\n- [ ] Second criterion\n- [x] Third criterion\"#;\n\n        let content_no_exit_criteria = r#\"# Document\n\n## Other Section\n\nSome content.\"#;\n\n        assert!(check_all_criteria_complete(content_all_complete).unwrap());\n        assert!(!check_all_criteria_complete(content_incomplete).unwrap());\n        assert!(check_all_criteria_complete(content_no_exit_criteria).unwrap());\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content() {\n        let content = r#\"# Document\n\n## Exit Criteria\n\n- [ ] First criterion to complete\n- [x] Second criterion already done\n- [ ] Third criterion pending\"#;\n\n        let result = update_checkbox_in_content(content, \"First criterion\", true);\n        assert!(result.is_ok());\n\n        let updated = result.unwrap();\n        assert!(updated.contains(\"- [x] First criterion to complete\"));\n        assert!(updated.contains(\"- [x] Second criterion already done\"));\n        assert!(updated.contains(\"- [ ] Third criterion pending\"));\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content_partial_match() {\n        let content = r#\"# Document\n\n## Exit Criteria\n\n- [ ] Complete the implementation\n- [ ] Complete the testing\n- [ ] Complete the documentation\"#;\n\n        let result = update_checkbox_in_content(content, \"implementation\", true);\n        assert!(result.is_ok());\n\n        let updated = result.unwrap();\n        assert!(updated.contains(\"- [x] Complete the implementation\"));\n        assert!(updated.contains(\"- [ ] Complete the testing\"));\n        assert!(updated.contains(\"- [ ] Complete the documentation\"));\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content_ambiguous_match() {\n        let content = r#\"# Document\n\n## Exit Criteria\n\n- [ ] Complete the implementation phase\n- [ ] Complete the implementation testing\n- [ ] Complete the documentation\"#;\n\n        let result = update_checkbox_in_content(content, \"implementation\", true);\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Multiple exit criteria match\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for ambiguous match\");\n        }\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content_no_match() {\n        let content = r#\"# Document\n\n## Exit Criteria\n\n- [ ] First criterion\n- [ ] Second criterion\"#;\n\n        let result = update_checkbox_in_content(content, \"nonexistent\", true);\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"No exit criteria found matching\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for no match\");\n        }\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content_no_exit_criteria() {\n        let content = r#\"# Document\n\n## Some Other Section\n\nNo exit criteria here.\"#;\n\n        let result = update_checkbox_in_content(content, \"anything\", true);\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Exit Criteria section not found\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for missing section\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_update_exit_criterion_full() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nexit_criteria_met: false\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the problem statement.\n\n## Exit Criteria\n\n- [ ] Define the solution approach\n- [ ] Complete implementation \n- [x] Write documentation\n\n## Conclusion\n\nFinal thoughts.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let result = update_exit_criterion(temp_file.path(), \"solution approach\", true).await;\n\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify checkbox was updated\n        assert!(updated_content.contains(\"- [x] Define the solution approach\"));\n        assert!(updated_content.contains(\"- [ ] Complete implementation\"));\n        assert!(updated_content.contains(\"- [x] Write documentation\"));\n\n        // Verify other content preserved\n        assert!(updated_content.contains(\"This is the problem statement\"));\n        assert!(updated_content.contains(\"Final thoughts\"));\n\n        // Verify frontmatter updated (exit_criteria_met should still be false since not all complete)\n        assert!(updated_content.contains(\"exit_criteria_met: false\"));\n        assert!(updated_content.contains(\"id: test-document\"));\n\n        // Verify updated_at was changed (should be current date)\n        let current_date = chrono::Utc::now().format(\"%Y-%m-%d\").to_string();\n        assert!(updated_content.contains(\u0026format!(\"updated_at: {}T\", current_date)));\n    }\n\n    #[tokio::test]\n    async fn test_update_exit_criterion_all_complete() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nexit_criteria_met: false\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Exit Criteria\n\n- [x] First criterion\n- [ ] Second criterion\n- [x] Third criterion\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        // Complete the last remaining criterion\n        let result = update_exit_criterion(temp_file.path(), \"Second criterion\", true).await;\n\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify all checkboxes are complete\n        assert!(updated_content.contains(\"- [x] First criterion\"));\n        assert!(updated_content.contains(\"- [x] Second criterion\"));\n        assert!(updated_content.contains(\"- [x] Third criterion\"));\n\n        // Verify exit_criteria_met is now true\n        assert!(updated_content.contains(\"exit_criteria_met: true\"));\n    }\n\n    #[test]\n    fn test_is_valid_wiki_link_reference() {\n        // Valid references\n        assert!(is_valid_wiki_link_reference(\"[[Document Title]]\"));\n        assert!(is_valid_wiki_link_reference(\n            \"[[Complex Document Title with Spaces]]\"\n        ));\n        assert!(is_valid_wiki_link_reference(\"[[Document-With-Hyphens]]\"));\n        assert!(is_valid_wiki_link_reference(\n            \"[[Document_With_Underscores]]\"\n        ));\n\n        // Invalid references\n        assert!(!is_valid_wiki_link_reference(\"\"));\n        assert!(!is_valid_wiki_link_reference(\"Document Title\"));\n        assert!(!is_valid_wiki_link_reference(\"[Document Title]\"));\n        assert!(!is_valid_wiki_link_reference(\"[[]]\"));\n        assert!(!is_valid_wiki_link_reference(\n            \"[[Document [[Nested]] Title]]\"\n        ));\n        assert!(!is_valid_wiki_link_reference(\"Document Title]]\"));\n        assert!(!is_valid_wiki_link_reference(\"[[Document Title\"));\n    }\n\n    #[test]\n    fn test_validate_blocked_by_references() {\n        // Valid references\n        let valid_refs = vec![\n            \"[[Document One]]\".to_string(),\n            \"[[Document Two]]\".to_string(),\n            \"[[Another Document]]\".to_string(),\n        ];\n        assert!(validate_blocked_by_references(\u0026valid_refs).is_ok());\n\n        // Empty list should be valid\n        let empty_refs: Vec\u003cString\u003e = vec![];\n        assert!(validate_blocked_by_references(\u0026empty_refs).is_ok());\n\n        // Invalid references\n        let invalid_refs = vec![\n            \"[[Valid Document]]\".to_string(),\n            \"Invalid Document\".to_string(), // Missing brackets\n        ];\n        assert!(validate_blocked_by_references(\u0026invalid_refs).is_err());\n\n        let nested_refs = vec![\"[[Document [[Nested]] Title]]\".to_string()];\n        assert!(validate_blocked_by_references(\u0026nested_refs).is_err());\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_basic() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nblocked_by: []\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the problem statement.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let new_blocked_by = vec![\n            \"[[Dependency One]]\".to_string(),\n            \"[[Dependency Two]]\".to_string(),\n        ];\n\n        let result = update_blocked_by(temp_file.path(), new_blocked_by).await;\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify blocked_by was updated\n        assert!(updated_content.contains(\"[[Dependency One]]\"));\n        assert!(updated_content.contains(\"[[Dependency Two]]\"));\n\n        // Verify other content preserved\n        assert!(updated_content.contains(\"This is the problem statement\"));\n        assert!(updated_content.contains(\"id: test-document\"));\n        assert!(updated_content.contains(\"level: strategy\"));\n\n        // Verify updated_at was changed (should be current date)\n        let current_date = chrono::Utc::now().format(\"%Y-%m-%d\").to_string();\n        assert!(updated_content.contains(\u0026format!(\"updated_at: {}T\", current_date)));\n\n        // Verify frontmatter can be parsed again\n        let parsed_again =\n            gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026updated_content);\n        assert!(parsed_again.data.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_clear_blockers() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nblocked_by:\n  - \"[[Old Dependency One]]\"\n  - \"[[Old Dependency Two]]\"\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the problem statement.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        // Clear all blockers\n        let empty_blocked_by: Vec\u003cString\u003e = vec![];\n\n        let result = update_blocked_by(temp_file.path(), empty_blocked_by).await;\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify blocked_by was cleared\n        assert!(updated_content.contains(\"blocked_by: []\"));\n        assert!(!updated_content.contains(\"Old Dependency One\"));\n        assert!(!updated_content.contains(\"Old Dependency Two\"));\n\n        // Verify other content preserved\n        assert!(updated_content.contains(\"This is the problem statement\"));\n        assert!(updated_content.contains(\"id: test-document\"));\n\n        // Verify frontmatter can be parsed again\n        let parsed_again =\n            gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026updated_content);\n        assert!(parsed_again.data.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_replace_existing() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nblocked_by:\n  - \"[[Old Dependency]]\"\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the problem statement.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let new_blocked_by = vec![\n            \"[[New Dependency One]]\".to_string(),\n            \"[[New Dependency Two]]\".to_string(),\n            \"[[New Dependency Three]]\".to_string(),\n        ];\n\n        let result = update_blocked_by(temp_file.path(), new_blocked_by).await;\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify old blocked_by was replaced\n        assert!(!updated_content.contains(\"Old Dependency\"));\n        assert!(updated_content.contains(\"[[New Dependency One]]\"));\n        assert!(updated_content.contains(\"[[New Dependency Two]]\"));\n        assert!(updated_content.contains(\"[[New Dependency Three]]\"));\n\n        // Verify other content preserved\n        assert!(updated_content.contains(\"This is the problem statement\"));\n\n        // Verify frontmatter can be parsed again\n        let parsed_again =\n            gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026updated_content);\n        assert!(parsed_again.data.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_invalid_reference() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nblocked_by: []\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let invalid_blocked_by = vec![\n            \"[[Valid Dependency]]\".to_string(),\n            \"Invalid Dependency\".to_string(), // Missing brackets\n        ];\n\n        let result = update_blocked_by(temp_file.path(), invalid_blocked_by).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Invalid reference format\"));\n            assert!(message.contains(\"Invalid Dependency\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for invalid reference\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_no_frontmatter() {\n        let document_content = r##\"# Test Strategy\n\n## Problem Statement\n\nThis document has no frontmatter.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let blocked_by = vec![\"[[Some Dependency]]\".to_string()];\n\n        let result = update_blocked_by(temp_file.path(), blocked_by).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Document has no frontmatter to update\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for missing frontmatter\");\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":8}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":10}},{"line":105,"address":[],"length":0,"stats":{"Line":10}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":7}},{"line":145,"address":[],"length":0,"stats":{"Line":7}},{"line":146,"address":[],"length":0,"stats":{"Line":7}},{"line":149,"address":[],"length":0,"stats":{"Line":108}},{"line":150,"address":[],"length":0,"stats":{"Line":97}},{"line":151,"address":[],"length":0,"stats":{"Line":107}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":14}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":170,"address":[],"length":0,"stats":{"Line":3}},{"line":173,"address":[],"length":0,"stats":{"Line":7}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":180,"address":[],"length":0,"stats":{"Line":3}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":188,"address":[],"length":0,"stats":{"Line":12}},{"line":189,"address":[],"length":0,"stats":{"Line":12}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":11}},{"line":194,"address":[],"length":0,"stats":{"Line":21}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":7}},{"line":209,"address":[],"length":0,"stats":{"Line":7}},{"line":212,"address":[],"length":0,"stats":{"Line":13}},{"line":214,"address":[],"length":0,"stats":{"Line":41}},{"line":215,"address":[],"length":0,"stats":{"Line":8}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":222,"address":[],"length":0,"stats":{"Line":25}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":24}},{"line":232,"address":[],"length":0,"stats":{"Line":23}},{"line":233,"address":[],"length":0,"stats":{"Line":6}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":244,"address":[],"length":0,"stats":{"Line":5}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":258,"address":[],"length":0,"stats":{"Line":40}},{"line":259,"address":[],"length":0,"stats":{"Line":36}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":32}},{"line":271,"address":[],"length":0,"stats":{"Line":45}},{"line":272,"address":[],"length":0,"stats":{"Line":45}},{"line":273,"address":[],"length":0,"stats":{"Line":88}},{"line":277,"address":[],"length":0,"stats":{"Line":8}},{"line":278,"address":[],"length":0,"stats":{"Line":24}},{"line":281,"address":[],"length":0,"stats":{"Line":8}},{"line":282,"address":[],"length":0,"stats":{"Line":6}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":5}},{"line":294,"address":[],"length":0,"stats":{"Line":5}},{"line":297,"address":[],"length":0,"stats":{"Line":5}},{"line":299,"address":[],"length":0,"stats":{"Line":31}},{"line":301,"address":[],"length":0,"stats":{"Line":5}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[],"length":0,"stats":{"Line":4}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":309,"address":[],"length":0,"stats":{"Line":22}},{"line":310,"address":[],"length":0,"stats":{"Line":1}},{"line":314,"address":[],"length":0,"stats":{"Line":14}},{"line":315,"address":[],"length":0,"stats":{"Line":24}},{"line":316,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":2}},{"line":324,"address":[],"length":0,"stats":{"Line":2}},{"line":325,"address":[],"length":0,"stats":{"Line":2}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":8}},{"line":359,"address":[],"length":0,"stats":{"Line":31}},{"line":360,"address":[],"length":0,"stats":{"Line":13}},{"line":361,"address":[],"length":0,"stats":{"Line":3}},{"line":362,"address":[],"length":0,"stats":{"Line":3}},{"line":363,"address":[],"length":0,"stats":{"Line":3}},{"line":364,"address":[],"length":0,"stats":{"Line":3}},{"line":369,"address":[],"length":0,"stats":{"Line":5}},{"line":373,"address":[],"length":0,"stats":{"Line":24}},{"line":374,"address":[],"length":0,"stats":{"Line":24}},{"line":375,"address":[],"length":0,"stats":{"Line":1}},{"line":379,"address":[],"length":0,"stats":{"Line":41}},{"line":380,"address":[],"length":0,"stats":{"Line":6}},{"line":384,"address":[],"length":0,"stats":{"Line":17}},{"line":387,"address":[],"length":0,"stats":{"Line":47}},{"line":391,"address":[],"length":0,"stats":{"Line":3}},{"line":393,"address":[],"length":0,"stats":{"Line":3}},{"line":394,"address":[],"length":0,"stats":{"Line":3}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":3}},{"line":401,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":1}},{"line":404,"address":[],"length":0,"stats":{"Line":1}},{"line":405,"address":[],"length":0,"stats":{"Line":1}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":7}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":6}},{"line":434,"address":[],"length":0,"stats":{"Line":6}},{"line":437,"address":[],"length":0,"stats":{"Line":6}},{"line":440,"address":[],"length":0,"stats":{"Line":6}},{"line":442,"address":[],"length":0,"stats":{"Line":6}}],"covered":132,"coverable":162},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","validation.rs"],"content":"//! Document validation functions\n\nuse crate::{DocumentType, Result};\nuse serde_yaml::Value;\nuse std::path::Path;\nuse tokio::fs;\n\n/// Result of document validation containing detailed error information\n#[derive(Debug, Clone)]\npub struct ValidationResult {\n    pub is_valid: bool,\n    pub document_type: Option\u003cDocumentType\u003e,\n    pub frontmatter_errors: Vec\u003cString\u003e,\n}\n\nimpl ValidationResult {\n    pub fn valid(document_type: DocumentType) -\u003e Self {\n        Self {\n            is_valid: true,\n            document_type: Some(document_type),\n            frontmatter_errors: Vec::new(),\n        }\n    }\n\n    pub fn invalid(errors: Vec\u003cString\u003e) -\u003e Self {\n        Self {\n            is_valid: false,\n            document_type: None,\n            frontmatter_errors: errors,\n        }\n    }\n\n    pub fn add_error(\u0026mut self, error: String) {\n        self.frontmatter_errors.push(error);\n        self.is_valid = false;\n    }\n}\n\n/// Validate a document from file path\npub async fn validate(document_path: \u0026Path) -\u003e Result\u003cValidationResult\u003e {\n    let content = fs::read_to_string(document_path)\n        .await\n        .map_err(crate::MetisError::Io)?;\n    validate_content(\u0026content)\n}\n\n/// Validate a document from content string\npub fn validate_content(content: \u0026str) -\u003e Result\u003cValidationResult\u003e {\n    // Extract frontmatter manually\n    let frontmatter = match extract_frontmatter(content) {\n        Some(fm) =\u003e fm,\n        None =\u003e {\n            return Ok(ValidationResult::invalid(vec![\n                \"No frontmatter found in document\".to_string(),\n            ]));\n        }\n    };\n\n    let mut result = ValidationResult {\n        is_valid: true,\n        document_type: None,\n        frontmatter_errors: Vec::new(),\n    };\n\n    // Extract and validate document type\n    let doc_type = match extract_document_type(\u0026frontmatter) {\n        Ok(dt) =\u003e {\n            result.document_type = Some(dt.clone());\n            dt\n        }\n        Err(error) =\u003e {\n            result.add_error(error);\n            return Ok(result);\n        }\n    };\n\n    // Validate required fields for the document type\n    validate_required_fields(\u0026frontmatter, \u0026doc_type, \u0026mut result);\n\n    // Validate phase from tags\n    validate_phase_from_tags(\u0026frontmatter, \u0026doc_type, \u0026mut result);\n\n    Ok(result)\n}\n\n/// Extract frontmatter from document content\nfn extract_frontmatter(content: \u0026str) -\u003e Option\u003cValue\u003e {\n    if !content.starts_with(\"---\") {\n        return None;\n    }\n\n    let mut lines = content.lines();\n    lines.next(); // Skip first \"---\"\n\n    let mut frontmatter_lines = Vec::new();\n    for line in lines {\n        if line.trim() == \"---\" {\n            break;\n        }\n        frontmatter_lines.push(line);\n    }\n\n    let frontmatter_str = frontmatter_lines.join(\"\\n\");\n    serde_yaml::from_str(\u0026frontmatter_str).ok()\n}\n\n/// Extract document type from frontmatter\nfn extract_document_type(frontmatter: \u0026Value) -\u003e std::result::Result\u003cDocumentType, String\u003e {\n    let level = frontmatter\n        .get(\"level\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| \"Missing 'level' field in frontmatter\".to_string())?;\n\n    match level {\n        \"vision\" =\u003e Ok(DocumentType::Vision),\n        \"strategy\" =\u003e Ok(DocumentType::Strategy),\n        \"initiative\" =\u003e Ok(DocumentType::Initiative),\n        \"task\" =\u003e Ok(DocumentType::Task),\n        \"adr\" =\u003e Ok(DocumentType::Adr),\n        _ =\u003e Err(format!(\n            \"Invalid document level: '{}'. Must be one of: vision, strategy, initiative, task, adr\",\n            level\n        )),\n    }\n}\n\n/// Validate required fields for a specific document type\nfn validate_required_fields(\n    frontmatter: \u0026Value,\n    doc_type: \u0026DocumentType,\n    result: \u0026mut ValidationResult,\n) {\n    // Check common required fields\n    let required_common = [\"id\", \"level\", \"status\", \"created_at\", \"updated_at\"];\n    for field in \u0026required_common {\n        if frontmatter.get(field).is_none() {\n            result.add_error(format!(\"Missing required field: '{}'\", field));\n        }\n    }\n\n    // Check document-type specific required fields\n    match doc_type {\n        DocumentType::Strategy =\u003e {\n            if frontmatter.get(\"risk_level\").is_none() {\n                result.add_error(\"Strategy documents require 'risk_level' field\".to_string());\n            } else if let Some(risk) = frontmatter.get(\"risk_level\").and_then(|v| v.as_str()) {\n                if ![\"low\", \"medium\", \"high\", \"critical\"].contains(\u0026risk) {\n                    result.add_error(format!(\n                        \"Invalid risk_level '{}'. Must be: low, medium, high, or critical\",\n                        risk\n                    ));\n                }\n            }\n        }\n        DocumentType::Initiative =\u003e {\n            if frontmatter.get(\"estimated_complexity\").is_none() {\n                result.add_error(\n                    \"Initiative documents require 'estimated_complexity' field\".to_string(),\n                );\n            } else if let Some(complexity) = frontmatter\n                .get(\"estimated_complexity\")\n                .and_then(|v| v.as_str())\n            {\n                if ![\"S\", \"M\", \"L\", \"XL\"].contains(\u0026complexity) {\n                    result.add_error(format!(\n                        \"Invalid complexity '{}'. Must be: S, M, L, or XL\",\n                        complexity\n                    ));\n                }\n            }\n        }\n        DocumentType::Adr =\u003e {\n            if frontmatter.get(\"decision_maker\").is_none() {\n                result.add_error(\"ADR documents require 'decision_maker' field\".to_string());\n            }\n            // Note: number field is optional in our templates, so not requiring it\n        }\n        DocumentType::Vision | DocumentType::Task =\u003e {\n            // No additional required fields for these types\n        }\n    }\n}\n\n/// Validate phase from tags array\nfn validate_phase_from_tags(\n    frontmatter: \u0026Value,\n    doc_type: \u0026DocumentType,\n    result: \u0026mut ValidationResult,\n) {\n    let tags = match frontmatter.get(\"tags\").and_then(|v| v.as_sequence()) {\n        Some(tags) =\u003e tags,\n        None =\u003e {\n            result.add_error(\"Missing 'tags' field in frontmatter\".to_string());\n            return;\n        }\n    };\n\n    // Extract phase tags\n    let phase_tags: Vec\u003cString\u003e = tags\n        .iter()\n        .filter_map(|tag| tag.as_str())\n        .filter(|tag| tag.starts_with(\"#phase/\"))\n        .map(|tag| tag.strip_prefix(\"#phase/\").unwrap().to_string())\n        .collect();\n\n    if phase_tags.is_empty() {\n        result.add_error(\"Document must have at least one #phase/ tag\".to_string());\n        return;\n    }\n\n    if phase_tags.len() \u003e 1 {\n        result.add_error(format!(\n            \"Document has multiple active phase tags: {}. Only one phase should be active.\",\n            phase_tags.join(\", \")\n        ));\n        return;\n    }\n\n    let current_phase = \u0026phase_tags[0];\n\n    // Validate phase against document type\n    let valid_phases = match doc_type {\n        DocumentType::Vision =\u003e vec![\"draft\", \"review\", \"published\"],\n        DocumentType::Strategy =\u003e vec![\"shaping\", \"design\", \"ready\", \"active\", \"completed\"],\n        DocumentType::Initiative =\u003e vec![\n            \"discovery\",\n            \"design\",\n            \"ready\",\n            \"decompose\",\n            \"active\",\n            \"completed\",\n        ],\n        DocumentType::Task =\u003e vec![\"todo\", \"doing\", \"completed\"],\n        DocumentType::Adr =\u003e vec![\"draft\", \"discussion\", \"decided\", \"superseded\"],\n    };\n\n    if !valid_phases.contains(\u0026current_phase.as_str()) {\n        result.add_error(format!(\n            \"Invalid phase '{}' for {} document. Valid phases: {}\",\n            current_phase,\n            format!(\"{:?}\", doc_type).to_lowercase(),\n            valid_phases.join(\", \")\n        ));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_valid_strategy_document() {\n        let content = \"---\nid: strategy-test\nlevel: strategy\nstatus: shaping\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\nparent: \nblocked_by: \ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/shaping\\\"\nexit_criteria_met: false\nsuccess_metrics: []\nrisk_level: high\nstakeholders: []\n---\n\n# Test Strategy\n\nContent here...\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(result.is_valid);\n        assert_eq!(result.document_type, Some(DocumentType::Strategy));\n        assert!(result.frontmatter_errors.is_empty());\n    }\n\n    #[test]\n    fn test_validate_missing_frontmatter() {\n        let content = \"# Just some markdown without frontmatter\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert_eq!(result.document_type, None);\n        assert_eq!(\n            result.frontmatter_errors,\n            vec![\"No frontmatter found in document\"]\n        );\n    }\n\n    #[test]\n    fn test_validate_invalid_level() {\n        let content = \"---\nid: test-doc\nlevel: invalid_level\nstatus: draft\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#test\\\"\n---\n\n# Test Document\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert_eq!(result.document_type, None);\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Invalid document level\")));\n    }\n\n    #[test]\n    fn test_validate_missing_required_fields() {\n        let content = \"---\nlevel: strategy\n---\n\n# Incomplete Strategy\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Missing required field: 'id'\")));\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Missing required field: 'status'\")));\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Strategy documents require 'risk_level'\")));\n    }\n\n    #[test]\n    fn test_validate_invalid_phase_tags() {\n        let content = \"---\nid: strategy-test\nlevel: strategy\nstatus: shaping\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\nrisk_level: high\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/invalid_phase\\\"\n---\n\n# Test Strategy\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Invalid phase 'invalid_phase'\")));\n    }\n\n    #[test]\n    fn test_validate_multiple_phase_tags() {\n        let content = \"---\nid: strategy-test\nlevel: strategy\nstatus: shaping\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\nrisk_level: high\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/shaping\\\"\n  - \\\"#phase/design\\\"\n---\n\n# Test Strategy\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"multiple active phase tags\")));\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":21}},{"line":34,"address":[],"length":0,"stats":{"Line":21}},{"line":35,"address":[],"length":0,"stats":{"Line":21}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":17}},{"line":50,"address":[],"length":0,"stats":{"Line":33}},{"line":51,"address":[],"length":0,"stats":{"Line":16}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":16}},{"line":66,"address":[],"length":0,"stats":{"Line":31}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":17}},{"line":88,"address":[],"length":0,"stats":{"Line":17}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":92,"address":[],"length":0,"stats":{"Line":16}},{"line":93,"address":[],"length":0,"stats":{"Line":16}},{"line":95,"address":[],"length":0,"stats":{"Line":16}},{"line":96,"address":[],"length":0,"stats":{"Line":302}},{"line":97,"address":[],"length":0,"stats":{"Line":151}},{"line":98,"address":[],"length":0,"stats":{"Line":16}},{"line":100,"address":[],"length":0,"stats":{"Line":135}},{"line":103,"address":[],"length":0,"stats":{"Line":16}},{"line":104,"address":[],"length":0,"stats":{"Line":16}},{"line":108,"address":[],"length":0,"stats":{"Line":16}},{"line":109,"address":[],"length":0,"stats":{"Line":32}},{"line":111,"address":[],"length":0,"stats":{"Line":48}},{"line":112,"address":[],"length":0,"stats":{"Line":32}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":31}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":120,"address":[],"length":0,"stats":{"Line":1}},{"line":121,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":15}},{"line":134,"address":[],"length":0,"stats":{"Line":15}},{"line":135,"address":[],"length":0,"stats":{"Line":165}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":15}},{"line":144,"address":[],"length":0,"stats":{"Line":22}},{"line":145,"address":[],"length":0,"stats":{"Line":7}},{"line":146,"address":[],"length":0,"stats":{"Line":31}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":15}},{"line":190,"address":[],"length":0,"stats":{"Line":46}},{"line":191,"address":[],"length":0,"stats":{"Line":8}},{"line":193,"address":[],"length":0,"stats":{"Line":7}},{"line":194,"address":[],"length":0,"stats":{"Line":7}},{"line":199,"address":[],"length":0,"stats":{"Line":8}},{"line":201,"address":[],"length":0,"stats":{"Line":33}},{"line":202,"address":[],"length":0,"stats":{"Line":33}},{"line":203,"address":[],"length":0,"stats":{"Line":25}},{"line":206,"address":[],"length":0,"stats":{"Line":8}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":8}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":219,"address":[],"length":0,"stats":{"Line":7}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":7}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":1}}],"covered":69,"coverable":100},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","config.rs"],"content":"use anyhow::Result;\n\n#[derive(Debug, Clone, Default)]\npub struct MetisServerConfig {\n    // Configuration is now minimal since we use direct paths\n    // Could add logging level, port bindings, etc. in future\n}\n\nimpl MetisServerConfig {\n    pub fn from_env() -\u003e Result\u003cSelf\u003e {\n        // No environment variables needed for stateless operation\n        Ok(Self {})\n    }\n\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","error.rs"],"content":"use thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum McpServerError {\n    #[error(\"Document not found: {document_path}\")]\n    DocumentNotFound { document_path: String },\n\n    #[error(\"Invalid parameter: {param_name} - {message}\")]\n    InvalidParameter { param_name: String, message: String },\n\n    #[error(\"Metis project not initialized at path: {path}\")]\n    ProjectNotInitialized { path: String },\n\n    #[error(\"Core library error: {0}\")]\n    CoreLibrary(#[from] metis_core::MetisError),\n\n    #[error(\"Configuration error: {0}\")]\n    Config(#[from] anyhow::Error),\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, McpServerError\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","lib.rs"],"content":"pub mod config;\npub mod error;\npub mod server;\npub mod tools;\n\npub use config::MetisServerConfig;\npub use error::{McpServerError, Result};\npub use server::MetisServerHandler;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","main.rs"],"content":"use anyhow::Result;\nuse metis_mcp_server::{MetisServerConfig, MetisServerHandler};\nuse rust_mcp_sdk::{\n    mcp_server::server_runtime,\n    schema::{\n        Implementation, InitializeResult, ServerCapabilities, ServerCapabilitiesTools,\n        LATEST_PROTOCOL_VERSION,\n    },\n    McpServer, StdioTransport, TransportOptions,\n};\nuse tracing::info;\n\nfn find_metis_log_path() -\u003e Option\u003cString\u003e {\n    let current_dir = std::env::current_dir().ok()?;\n    let mut current = current_dir;\n\n    // Traverse upward looking for initialized metis project\n    loop {\n        let metis_dir = current.join(\"metis\");\n        let metis_db = metis_dir.join(\".metis.db\");\n\n        // Only create logs if there's an initialized metis project\n        if metis_dir.is_dir() \u0026\u0026 metis_db.exists() {\n            return Some(\n                metis_dir\n                    .join(\"metis-mcp-server.log\")\n                    .to_string_lossy()\n                    .to_string(),\n            );\n        }\n\n        // Move to parent directory\n        if let Some(parent) = current.parent() {\n            current = parent.to_path_buf();\n        } else {\n            // Reached filesystem root\n            break;\n        }\n    }\n\n    None\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    // Initialize logging only if we find an initialized metis project\n    if let Some(log_path) = find_metis_log_path() {\n        // Initialize tracing with file output in metis project\n        let log_file = std::fs::OpenOptions::new()\n            .create(true)\n            .append(true)\n            .open(\u0026log_path)?;\n\n        tracing_subscriber::fmt()\n            .with_writer(log_file)\n            .with_ansi(false)\n            .init();\n    } else {\n        // No metis project found - use minimal console logging only\n        tracing_subscriber::fmt()\n            .with_writer(std::io::stderr)\n            .with_ansi(false)\n            .with_max_level(tracing::Level::WARN)\n            .init();\n    }\n\n    // Load configuration (minimal for now)\n    let config = MetisServerConfig::from_env()?;\n\n    info!(\"Starting Metis MCP Server\");\n\n    // Create server details\n    let server_details = InitializeResult {\n        server_info: Implementation {\n            name: \"Metis Documentation Management System\".to_string(),\n            version: \"0.1.0\".to_string(),\n            title: Some(\"Metis MCP Server\".to_string()),\n        },\n        capabilities: ServerCapabilities {\n            tools: Some(ServerCapabilitiesTools { list_changed: None }),\n            ..Default::default()\n        },\n        meta: None,\n        instructions: Some(\n            r#\"# Metis Flight Levels Documentation Management\n\n## Overview\nMetis implements a hierarchical document management system based on Flight Levels methodology. You manage projects by creating and transitioning documents through defined phases using direct file paths.\n\n## Document Hierarchy (Flight Levels)\nCreate documents in this order, with each level building on the previous:\n\n1. **Vision** (Level 3) - Overall purpose and direction\n   - Always start here - defines why the project exists\n   - Phases: draft  review  published\n\n2. **Strategy** (Level 2) - How to achieve the vision  \n   - Must reference Vision as parent\n   - Phases: shaping  design  ready  active  completed\n\n3. **Initiative** (Level 1) - Concrete projects implementing strategies\n   - Must reference Strategy as parent\n   - Phases: discovery  design  ready  decompose  active  completed\n\n4. **Task** (Level 0) - Individual work items\n   - Must reference Initiative as parent\n   - Phases: todo  doing  completed\n\n5. **ADR** (Architectural Decision Record) - Technical decisions\n   - Can exist at any level, no parent required\n   - Phases: draft  discussion  decided  superseded\n\n## Direct Path Usage\nAll tools use `project_path` pointing to the directory containing `.metis.db`:\n- Initialize: `{\"project_path\": \"/path/to/project\", \"project_name\": \"my-project\"}`\n- Create doc: `{\"project_path\": \"/path/to/project\", \"document_type\": \"vision\", \"title\": \"Project Vision\"}`\n- Update: `{\"project_path\": \"/path/to/project\", \"document_path\": \"vision.md\", ...}`\n\n## Essential Workflow\n1. **Start**: `initialize_project` creates `.metis.db` and initial structure\n2. **Build hierarchy**: Create Vision  Strategies  Initiatives  Tasks\n3. **Progress**: Use `validate_exit_criteria` before `transition_phase`\n4. **Update**: Use `update_*` tools for incremental changes\n5. **Query**: Use `list_documents` and `search_documents` to explore\n\n## Phase Transition Rules\n- Always validate exit criteria before transitioning: `validate_exit_criteria`\n- Use `transition_phase` only when ready to progress\n- Phase progression is generally linear (no skipping)\n- Force transitions with `force: true` only when necessary\n\n## Best Practices\n- Create documents in hierarchical order (Vision before Strategy, etc.)\n- Define clear exit criteria for each phase\n- Use `blocked_by` to track dependencies\n- Validate documents after creation/updates\n- Keep documents focused on their level's scope\n- Update parent documents when children complete\n\n## Common Patterns\n- Start with Vision, then 2-3 key Strategies\n- Each Strategy typically has 3-5 Initiatives  \n- Each Initiative usually has 5-15 Tasks\n- Create ADRs for significant technical decisions\n- Review hierarchy regularly as work progresses\"#.to_string(),\n        ),\n        protocol_version: LATEST_PROTOCOL_VERSION.to_string(),\n    };\n\n    // Create transport\n    let transport = StdioTransport::new(TransportOptions::default())\n        .map_err(|e| anyhow::anyhow!(\"Failed to create transport: {}\", e))?;\n\n    // Create handler\n    let handler = MetisServerHandler::new(config);\n\n    // Create and start server\n    let server = server_runtime::create_server(server_details, transport, handler);\n\n    info!(\"MCP Server starting on stdio transport\");\n    server\n        .start()\n        .await\n        .map_err(|e| anyhow::anyhow!(\"MCP server failed to start: {}\", e))?;\n\n    Ok(())\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":37},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","server.rs"],"content":"use crate::tools::{\n    CheckPhaseTransitionTool, CreateDocumentTool, InitializeProjectTool, ListDocumentsTool,\n    MetisTools, OpenVaultInObsidianTool, SearchDocumentsTool, TransitionPhaseTool,\n    UpdateBlockedByTool, UpdateDocumentContentTool, UpdateExitCriterionTool, ValidateDocumentTool,\n    ValidateExitCriteriaTool,\n};\nuse crate::MetisServerConfig;\nuse async_trait::async_trait;\nuse rust_mcp_sdk::{\n    mcp_server::ServerHandler,\n    schema::{CallToolRequest, CallToolResult, ListToolsRequest, ListToolsResult, TextContent},\n    McpServer,\n};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::sync::RwLock;\nuse tracing::{debug, error, info, warn};\n\npub struct MetisServerHandler {\n    #[allow(dead_code)]\n    config: Arc\u003cMetisServerConfig\u003e,\n    // Track active projects for background sync\n    active_projects: Arc\u003cRwLock\u003cHashMap\u003cPathBuf, Arc\u003cmetis_core::SyncEngine\u003e\u003e\u003e\u003e,\n}\n\nimpl MetisServerHandler {\n    pub fn new(config: MetisServerConfig) -\u003e Self {\n        let handler = Self {\n            config: Arc::new(config),\n            active_projects: Arc::new(RwLock::new(HashMap::new())),\n        };\n\n        // Auto-discover existing projects on startup\n        handler.discover_existing_projects();\n\n        // Start background sync task\n        handler.start_background_sync();\n\n        handler\n    }\n\n    fn discover_existing_projects(\u0026self) {\n        let active_projects = Arc::clone(\u0026self.active_projects);\n\n        tokio::spawn(async move {\n            info!(\"Discovering existing Metis projects...\");\n\n            // Start from current directory and search for .metis.db files\n            if let Ok(current_dir) = std::env::current_dir() {\n                match Self::find_metis_projects(\u0026current_dir).await {\n                    Ok(projects) =\u003e {\n                        info!(\"Found {} existing Metis projects\", projects.len());\n\n                        let mut projects_map = active_projects.write().await;\n                        for project_path in projects {\n                            match Self::initialize_sync_engine(\u0026project_path).await {\n                                Ok(sync_engine) =\u003e {\n                                    info!(\n                                        \"Registered project for sync: {}\",\n                                        project_path.display()\n                                    );\n                                    projects_map.insert(project_path, sync_engine);\n                                }\n                                Err(e) =\u003e {\n                                    warn!(\n                                        \"Failed to initialize sync engine for {}: {}\",\n                                        project_path.display(),\n                                        e\n                                    );\n                                }\n                            }\n                        }\n                    }\n                    Err(e) =\u003e {\n                        warn!(\"Failed to discover existing projects: {}\", e);\n                    }\n                }\n            }\n        });\n    }\n\n    async fn find_metis_projects(\n        start_dir: \u0026std::path::Path,\n    ) -\u003e Result\u003cVec\u003cPathBuf\u003e, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        let mut projects = Vec::new();\n        let mut current_dir = start_dir.to_path_buf();\n\n        // Traverse upward from current directory looking for metis/ subdirectory\n        loop {\n            let metis_dir = current_dir.join(\"metis\");\n            let metis_db = metis_dir.join(\".metis.db\");\n\n            if metis_dir.is_dir() \u0026\u0026 metis_db.is_file() {\n                info!(\"Found Metis project at: {}\", metis_dir.display());\n                projects.push(metis_dir);\n            }\n\n            // Move to parent directory\n            if let Some(parent) = current_dir.parent() {\n                current_dir = parent.to_path_buf();\n            } else {\n                // Reached filesystem root\n                break;\n            }\n        }\n\n        Ok(projects)\n    }\n\n    async fn initialize_sync_engine(\n        project_path: \u0026Path,\n    ) -\u003e Result\u003cArc\u003cmetis_core::SyncEngine\u003e, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        let db_path = project_path.join(\".metis.db\");\n\n        // Create document store and sync engine\n        let store = metis_core::DocumentStore::new(db_path.to_str().unwrap())\n            .await\n            .map_err(|e| format!(\"Failed to open document store: {}\", e))?;\n        let sync_engine = Arc::new(metis_core::SyncEngine::new(store));\n\n        // Run initial sync\n        info!(\n            \"Running initial sync for discovered project: {}\",\n            project_path.display()\n        );\n        match sync_engine.sync_from_filesystem(project_path).await {\n            Ok(result) =\u003e {\n                info!(\n                    \"Initial sync completed for {}: {} processed, {} updated, {} deleted\",\n                    project_path.display(),\n                    result.files_processed,\n                    result.files_updated,\n                    result.files_deleted\n                );\n\n                if !result.errors.is_empty() {\n                    warn!(\n                        \"Initial sync errors for {}: {} errors\",\n                        project_path.display(),\n                        result.errors.len()\n                    );\n                    for error in \u0026result.errors {\n                        error!(\n                            \"Initial sync error in {}: {}\",\n                            error.file_path.display(),\n                            error.error\n                        );\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                warn!(\"Initial sync failed for {}: {}\", project_path.display(), e);\n            }\n        }\n\n        Ok(sync_engine)\n    }\n\n    fn start_background_sync(\u0026self) {\n        let active_projects = Arc::clone(\u0026self.active_projects);\n\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(Duration::from_secs(5));\n            info!(\"Background sync task started, checking every 5 seconds\");\n\n            loop {\n                interval.tick().await;\n\n                let projects = active_projects.read().await;\n                debug!(\"Background sync tick: {} active projects\", projects.len());\n                for (project_path, sync_engine) in projects.iter() {\n                    match sync_engine.sync_from_filesystem(project_path).await {\n                        Ok(result) =\u003e {\n                            if result.files_updated \u003e 0 || result.files_deleted \u003e 0 {\n                                debug!(\n                                    \"Sync completed for {}: {} updated, {} deleted\",\n                                    project_path.display(),\n                                    result.files_updated,\n                                    result.files_deleted\n                                );\n                            }\n\n                            if !result.errors.is_empty() {\n                                warn!(\n                                    \"Sync errors for {}: {} errors\",\n                                    project_path.display(),\n                                    result.errors.len()\n                                );\n                                for error in \u0026result.errors {\n                                    error!(\n                                        \"Sync error in {}: {}\",\n                                        error.file_path.display(),\n                                        error.error\n                                    );\n                                }\n                            }\n                        }\n                        Err(e) =\u003e {\n                            error!(\"Sync failed for {}: {}\", project_path.display(), e);\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    async fn ensure_project_synced(\n        \u0026self,\n        project_path: \u0026PathBuf,\n    ) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        info!(\n            \"ensure_project_synced called for: {}\",\n            project_path.display()\n        );\n        let mut projects = self.active_projects.write().await;\n\n        if !projects.contains_key(project_path) {\n            info!(\n                \"Project not found in active projects, initializing: {}\",\n                project_path.display()\n            );\n            // Check if project exists\n            let db_path = project_path.join(\".metis.db\");\n            if !db_path.exists() {\n                return Err(\n                    format!(\"Metis project not found at: {}\", project_path.display()).into(),\n                );\n            }\n\n            // Create document store and sync engine\n            let store = metis_core::DocumentStore::new(db_path.to_str().unwrap())\n                .await\n                .map_err(|e| format!(\"Failed to open document store: {}\", e))?;\n            let sync_engine = Arc::new(metis_core::SyncEngine::new(store));\n\n            // Run initial sync\n            info!(\n                \"Running initial sync for project: {}\",\n                project_path.display()\n            );\n            match sync_engine.sync_from_filesystem(project_path).await {\n                Ok(result) =\u003e {\n                    info!(\n                        \"Initial sync completed for {}: {} processed, {} updated, {} deleted\",\n                        project_path.display(),\n                        result.files_processed,\n                        result.files_updated,\n                        result.files_deleted\n                    );\n                }\n                Err(e) =\u003e {\n                    warn!(\"Initial sync failed for {}: {}\", project_path.display(), e);\n                }\n            }\n\n            projects.insert(project_path.clone(), sync_engine);\n        }\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl ServerHandler for MetisServerHandler {\n    async fn handle_list_tools_request(\n        \u0026self,\n        _request: ListToolsRequest,\n        _server: \u0026dyn McpServer,\n    ) -\u003e Result\u003cListToolsResult, rust_mcp_sdk::schema::RpcError\u003e {\n        Ok(ListToolsResult {\n            tools: MetisTools::tools(),\n            meta: None,\n            next_cursor: None,\n        })\n    }\n\n    async fn handle_call_tool_request(\n        \u0026self,\n        request: CallToolRequest,\n        _server: \u0026dyn McpServer,\n    ) -\u003e Result\u003cCallToolResult, rust_mcp_sdk::schema::schema_utils::CallToolError\u003e {\n        match request.params.name.as_str() {\n            \"initialize_project\" =\u003e {\n                let tool: InitializeProjectTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                // Initialize project at the specified path\n                let base_path = PathBuf::from(\u0026tool.project_path);\n\n                let config = metis_core::ProjectConfig {\n                    root_path: base_path.clone(),\n                    name: tool.project_name.clone(),\n                    description: tool.description.clone(),\n                };\n\n                match metis_core::initialize_project(config).await {\n                    Ok(metadata) =\u003e {\n                        // Register project for background sync using the metis directory path\n                        let metis_dir = base_path.join(\"metis\");\n                        if let Err(e) = self.ensure_project_synced(\u0026metis_dir).await {\n                            warn!(\"Failed to register project for sync: {}\", e);\n                        } else {\n                            info!(\n                                \"Successfully registered new project for sync: {}\",\n                                metis_dir.display()\n                            );\n                        }\n\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Project '{}' initialized successfully\", tool.project_name),\n                            \"project_path\": metadata.project_path,\n                            \"database_path\": metadata.database_path\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to initialize project '{}': {}\", tool.project_name, e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"create_document\" =\u003e {\n                let tool: CreateDocumentTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            \"validate_document\" =\u003e {\n                let tool: ValidateDocumentTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            \"update_document_content\" =\u003e {\n                let tool: UpdateDocumentContentTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core update function\n                match metis_core::update_document_content(\n                    \u0026document_path,\n                    \u0026tool.section_heading,\n                    \u0026tool.new_content,\n                )\n                .await\n                {\n                    Ok(()) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Successfully updated section '{}' in document\", tool.section_heading),\n                            \"document_path\": document_path,\n                            \"section_heading\": tool.section_heading,\n                            \"updated\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to update document content: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"update_exit_criterion\" =\u003e {\n                let tool: UpdateExitCriterionTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core update function\n                match metis_core::update_exit_criterion(\n                    \u0026document_path,\n                    \u0026tool.criterion_title,\n                    tool.completed,\n                )\n                .await\n                {\n                    Ok(()) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Successfully updated exit criterion to {}\", if tool.completed { \"completed\" } else { \"incomplete\" }),\n                            \"document_path\": document_path,\n                            \"criterion_title\": tool.criterion_title,\n                            \"completed\": tool.completed,\n                            \"updated\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to update exit criterion: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"update_blocked_by\" =\u003e {\n                let tool: UpdateBlockedByTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core update function\n                match metis_core::update_blocked_by(\u0026document_path, tool.blocked_by.clone()).await {\n                    Ok(()) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": \"Successfully updated blocked_by relationships\",\n                            \"document_path\": document_path,\n                            \"blocked_by\": tool.blocked_by,\n                            \"updated\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to update blocked_by: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"transition_phase\" =\u003e {\n                let tool: TransitionPhaseTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core phase transition function\n                match metis_core::transition_phase(\n                    \u0026document_path,\n                    \u0026tool.new_phase,\n                    tool.force.unwrap_or(false),\n                )\n                .await\n                {\n                    Ok(result_message) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": result_message,\n                            \"document_path\": document_path,\n                            \"new_phase\": tool.new_phase,\n                            \"force\": tool.force.unwrap_or(false),\n                            \"updated\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to transition phase: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"check_phase_transition\" =\u003e {\n                let tool: CheckPhaseTransitionTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core phase checking function\n                match metis_core::can_transition_to_phase(\u0026document_path, \u0026tool.target_phase).await\n                {\n                    Ok(can_transition) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": \"Phase transition check completed\",\n                            \"document_path\": document_path,\n                            \"target_phase\": tool.target_phase,\n                            \"can_transition\": can_transition,\n                            \"valid\": can_transition\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to check phase transition: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"validate_exit_criteria\" =\u003e {\n                let tool: ValidateExitCriteriaTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core exit criteria validation function\n                match metis_core::validate_exit_criteria(\u0026document_path).await {\n                    Ok(result) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": \"Exit criteria validation completed\",\n                            \"document_path\": document_path,\n                            \"all_complete\": result.met,\n                            \"completed_count\": result.completed_criteria,\n                            \"total_count\": result.total_criteria,\n                            \"missing_criteria\": result.missing_criteria,\n                            \"valid\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to validate exit criteria: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"list_documents\" =\u003e {\n                let tool: ListDocumentsTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            \"search_documents\" =\u003e {\n                let tool: SearchDocumentsTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            \"open_vault_in_obsidian\" =\u003e {\n                let tool: OpenVaultInObsidianTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            _ =\u003e Err(\n                rust_mcp_sdk::schema::schema_utils::CallToolError::unknown_tool(\n                    request.params.name,\n                ),\n            ),\n        }\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":323},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","all_tools.rs"],"content":"use super::document::{CreateDocumentTool, ValidateDocumentTool};\nuse super::obsidian::OpenVaultInObsidianTool;\nuse super::phase::{CheckPhaseTransitionTool, TransitionPhaseTool, ValidateExitCriteriaTool};\nuse super::project::InitializeProjectTool;\nuse super::query::{ListDocumentsTool, SearchDocumentsTool};\nuse super::update::{UpdateBlockedByTool, UpdateDocumentContentTool, UpdateExitCriterionTool};\nuse rust_mcp_sdk::tool_box;\n\n// Generate the combined MetisTools enum\ntool_box!(\n    MetisTools,\n    [\n        InitializeProjectTool,\n        CreateDocumentTool,\n        ValidateDocumentTool,\n        UpdateDocumentContentTool,\n        UpdateExitCriterionTool,\n        UpdateBlockedByTool,\n        TransitionPhaseTool,\n        CheckPhaseTransitionTool,\n        ValidateExitCriteriaTool,\n        ListDocumentsTool,\n        SearchDocumentsTool,\n        OpenVaultInObsidianTool\n    ]\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","document.rs"],"content":"use metis_core::{\n    render, validate, Complexity, DocumentContext, DocumentStore, DocumentType, RiskLevel,\n};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse std::str::FromStr;\n\n#[mcp_tool(\n    name = \"create_document\",\n    description = \"Create a new Metis document (vision, strategy, initiative, task, adr)\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct CreateDocumentTool {\n    /// Path to the .metis folder where the document will be created\n    pub project_path: String,\n\n    /// Document type: vision, strategy, initiative, task, adr\n    pub document_type: String,\n\n    /// Title of the document\n    pub title: String,\n\n    /// Parent document title (required for strategy, initiative, task)\n    pub parent_title: Option\u003cString\u003e,\n\n    /// Risk level for strategies (low, medium, high)\n    pub risk_level: Option\u003cString\u003e,\n\n    /// Complexity for initiatives (xs, s, m, l, xl)\n    pub complexity: Option\u003cString\u003e,\n\n    /// Decision maker for ADRs\n    pub decision_maker: Option\u003cString\u003e,\n\n    /// Stakeholders involved\n    pub stakeholders: Option\u003cVec\u003cString\u003e\u003e,\n}\n\nimpl CreateDocumentTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n\n        // Parse document type\n        let doc_type = DocumentType::from_str(\u0026self.document_type).map_err(CallToolError::new)?;\n\n        // Create document context\n        let mut context = DocumentContext::new(self.title.clone());\n\n        // Add optional fields based on document type\n        if let Some(parent) = \u0026self.parent_title {\n            context = context.with_parent(parent.clone());\n        }\n\n        if let Some(risk) = \u0026self.risk_level {\n            let risk_level = match risk.to_lowercase().as_str() {\n                \"low\" =\u003e RiskLevel::Low,\n                \"medium\" =\u003e RiskLevel::Medium,\n                \"high\" =\u003e RiskLevel::High,\n                \"critical\" =\u003e RiskLevel::Critical,\n                _ =\u003e return Ok(CallToolResult::text_content(\n                    vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                        \"error\": format!(\"Invalid risk level '{}'. Must be: low, medium, high, critical\", risk)\n                    })).map_err(CallToolError::new)?)]\n                ))\n            };\n            context = context.with_risk_level(risk_level);\n        }\n\n        if let Some(complexity) = \u0026self.complexity {\n            let complexity_level = match complexity.to_lowercase().as_str() {\n                \"s\" =\u003e Complexity::S,\n                \"m\" =\u003e Complexity::M,\n                \"l\" =\u003e Complexity::L,\n                \"xl\" =\u003e Complexity::XL,\n                _ =\u003e return Ok(CallToolResult::text_content(\n                    vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                        \"error\": format!(\"Invalid complexity '{}'. Must be: s, m, l, xl\", complexity)\n                    })).map_err(CallToolError::new)?)]\n                ))\n            };\n            context = context.with_complexity(complexity_level);\n        }\n\n        if let Some(decision_maker) = \u0026self.decision_maker {\n            context = context.with_decision_maker(decision_maker.clone());\n        }\n\n        if let Some(stakeholders) = \u0026self.stakeholders {\n            context = context.with_stakeholders(stakeholders.clone());\n        }\n\n        // Validate context for document type\n        if let Err(validation_error) = context.validate_for_type(\u0026doc_type) {\n            return Ok(CallToolResult::text_content(vec![TextContent::from(\n                serde_json::to_string_pretty(\u0026serde_json::json!({\n                    \"error\": \"Document validation failed\",\n                    \"validation_error\": format!(\"{}\", validation_error)\n                }))\n                .map_err(CallToolError::new)?,\n            )]));\n        }\n\n        // Render document using metis-core render function\n        match render(doc_type.clone(), context, \u0026project_path).await {\n            Ok(file_path) =\u003e {\n                // Store document in database\n                let db_path = project_path.join(\".metis.db\");\n                match DocumentStore::new(db_path.to_str().unwrap()).await {\n                    Ok(store) =\u003e {\n                        // Sync the created document to database\n                        let sync_engine = metis_core::SyncEngine::new(store);\n                        if let Err(e) = sync_engine.sync_from_filesystem(\u0026project_path).await {\n                            eprintln!(\"Warning: Failed to sync document to database: {}\", e);\n                        }\n\n                        let response = serde_json::json!({\n                            \"message\": format!(\"{} '{}' created successfully\", doc_type, self.title),\n                            \"file_path\": file_path.to_string_lossy(),\n                            \"document_type\": self.document_type\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to connect to database: {}\", e)\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to create document '{}': {}\", self.title, e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"validate_document\",\n    description = \"Validate a Metis document's structure and content\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct ValidateDocumentTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n}\n\nimpl ValidateDocumentTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        // Read the document file\n        match tokio::fs::read_to_string(\u0026document_path).await {\n            Ok(_content) =\u003e {\n                // Validate the document using metis-core\n                match validate(\u0026document_path).await {\n                    Ok(validation_result) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Document validation {}: {}\",\n                                if validation_result.is_valid { \"passed\" } else { \"failed\" },\n                                if validation_result.is_valid {\n                                    \"Document is valid\".to_string()\n                                } else {\n                                    format!(\"{} errors found\", validation_result.frontmatter_errors.len())\n                                }),\n                            \"is_valid\": validation_result.is_valid,\n                            \"document_type\": validation_result.document_type,\n                            \"frontmatter_errors\": validation_result.frontmatter_errors,\n                            \"project_path\": self.project_path,\n                            \"document_path\": self.document_path\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to validate document: {}\", e),\n                            \"project_path\": self.project_path,\n                            \"document_path\": self.document_path\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to read document file: {}\", e),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":6}},{"line":52,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":6}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":10}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":115,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":119,"address":[],"length":0,"stats":{"Line":6}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":127,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}}],"covered":23,"coverable":96},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","mod.rs"],"content":"pub mod all_tools;\npub mod document;\npub mod obsidian;\npub mod phase;\npub mod project;\npub mod query;\npub mod update;\n\npub use all_tools::MetisTools;\npub use document::*;\npub use obsidian::*;\npub use phase::*;\npub use project::*;\npub use query::*;\npub use update::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","obsidian.rs"],"content":"use rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\n\n#[mcp_tool(\n    name = \"open_vault_in_obsidian\",\n    description = \"Open a metis project vault in Obsidian by configuring it as a known vault and launching Obsidian\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct OpenVaultInObsidianTool {\n    /// Path to the project directory to open as an Obsidian vault\n    pub project_path: String,\n}\n\nimpl OpenVaultInObsidianTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n\n        // Ensure the project path exists\n        if !project_path.exists() {\n            return Ok(CallToolResult::text_content(vec![TextContent::from(\n                serde_json::to_string_pretty(\u0026serde_json::json!({\n                    \"error\": format!(\"Project path does not exist: {}\", self.project_path)\n                }))\n                .map_err(CallToolError::new)?,\n            )]));\n        }\n\n        // Detect operating system and set appropriate configuration\n        let os_info = get_os_info();\n\n        match open_obsidian_vault(\u0026project_path, \u0026os_info) {\n            Ok(message) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": message,\n                    \"project_path\": self.project_path,\n                    \"os\": os_info.name\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to open vault in Obsidian: {}\", e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct OsInfo {\n    name: String,\n    config_path: PathBuf,\n    close_command: Vec\u003cString\u003e,\n    open_command: Vec\u003cString\u003e,\n}\n\nfn get_os_info() -\u003e OsInfo {\n    #[cfg(target_os = \"macos\")]\n    {\n        let home = std::env::var(\"HOME\").unwrap_or_default();\n        OsInfo {\n            name: \"macOS\".to_string(),\n            config_path: PathBuf::from(home)\n                .join(\"Library/Application Support/obsidian/obsidian.json\"),\n            close_command: vec![\n                \"osascript\".to_string(),\n                \"-e\".to_string(),\n                \"quit app \\\"Obsidian\\\"\".to_string(),\n            ],\n            open_command: vec![\"open\".to_string(), \"-a\".to_string(), \"Obsidian\".to_string()],\n        }\n    }\n\n    #[cfg(target_os = \"linux\")]\n    {\n        // Try multiple possible config locations for different installation methods\n        let config_path = get_linux_config_path();\n        OsInfo {\n            name: \"Linux\".to_string(),\n            config_path,\n            close_command: vec![\"killall\".to_string(), \"obsidian\".to_string()],\n            open_command: vec![\"obsidian\".to_string()],\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        let appdata = std::env::var(\"APPDATA\").unwrap_or_default();\n        OsInfo {\n            name: \"Windows\".to_string(),\n            config_path: PathBuf::from(appdata).join(\"Obsidian/obsidian.json\"), // Note: capital O\n            close_command: vec![\n                \"taskkill\".to_string(),\n                \"/F\".to_string(),\n                \"/IM\".to_string(),\n                \"Obsidian.exe\".to_string(),\n            ],\n            open_command: get_windows_obsidian_command(),\n        }\n    }\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"linux\", target_os = \"windows\")))]\n    {\n        OsInfo {\n            name: \"Unknown\".to_string(),\n            config_path: PathBuf::from(\"obsidian.json\"),\n            close_command: vec![],\n            open_command: vec![\"obsidian\".to_string()],\n        }\n    }\n}\n\n#[cfg(target_os = \"linux\")]\nfn get_linux_config_path() -\u003e PathBuf {\n    let home = std::env::var(\"HOME\").unwrap_or_default();\n\n    // Check multiple possible locations based on installation method\n    let possible_paths = vec![\n        // Standard location\n        PathBuf::from(\u0026home).join(\".config/obsidian/obsidian.json\"),\n        // Flatpak location\n        PathBuf::from(\u0026home).join(\".var/app/md.obsidian.Obsidian/config/obsidian/obsidian.json\"),\n        // Snap location (pattern - actual path varies by revision)\n        // We'll check for this dynamically below\n    ];\n\n    // Check standard and Flatpak locations\n    for path in \u0026possible_paths {\n        if path.exists() {\n            return path.clone();\n        }\n    }\n\n    // Check for Snap installation (dynamic revision)\n    let snap_base = PathBuf::from(\u0026home).join(\"snap/obsidian\");\n    if snap_base.exists() {\n        if let Ok(entries) = fs::read_dir(\u0026snap_base) {\n            for entry in entries.flatten() {\n                let config_path = entry.path().join(\".config/obsidian/obsidian.json\");\n                if config_path.exists() {\n                    return config_path;\n                }\n            }\n        }\n    }\n\n    // Default to standard location if none found\n    PathBuf::from(\u0026home).join(\".config/obsidian/obsidian.json\")\n}\n\n#[cfg(target_os = \"windows\")]\nfn get_windows_obsidian_command() -\u003e Vec\u003cString\u003e {\n    // Try to find Obsidian executable in common locations\n    let local_appdata = std::env::var(\"LOCALAPPDATA\").unwrap_or_default();\n    let possible_paths = vec![\n        PathBuf::from(\u0026local_appdata).join(\"Obsidian/Obsidian.exe\"),\n        // Could add other possible installation paths here\n    ];\n\n    for path in possible_paths {\n        if path.exists() {\n            return vec![\n                \"cmd\".to_string(),\n                \"/C\".to_string(),\n                \"start\".to_string(),\n                \"\".to_string(),\n                path.to_string_lossy().to_string(),\n            ];\n        }\n    }\n\n    // Fallback to hoping it's in PATH or using start with obsidian\n    vec![\n        \"cmd\".to_string(),\n        \"/C\".to_string(),\n        \"start\".to_string(),\n        \"obsidian\".to_string(),\n    ]\n}\n\nfn format_path_for_os(path: \u0026Path, _os_name: \u0026str) -\u003e Result\u003cString, Box\u003cdyn std::error::Error\u003e\u003e {\n    let path_str = path.to_string_lossy().to_string();\n\n    // On Windows, ensure we use backslashes for the JSON config\n    // (the JSON library will properly escape them when serializing)\n    #[cfg(target_os = \"windows\")]\n    {\n        Ok(path_str.replace(\"/\", \"\\\\\"))\n    }\n\n    // On Unix-like systems, use forward slashes\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        Ok(path_str)\n    }\n}\n\nfn open_obsidian_vault(\n    project_path: \u0026Path,\n    os_info: \u0026OsInfo,\n) -\u003e Result\u003cString, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Step 1: Close Obsidian if running\n    if !os_info.close_command.is_empty() {\n        let _ = Command::new(\u0026os_info.close_command[0])\n            .args(\u0026os_info.close_command[1..])\n            .output(); // Ignore errors - app might not be running\n\n        // Small delay to ensure app closes\n        std::thread::sleep(std::time::Duration::from_millis(500));\n    }\n\n    // Step 2: Get absolute path and format appropriately for OS\n    let vault_path = project_path.canonicalize()?;\n    let vault_path_str = format_path_for_os(\u0026vault_path, \u0026os_info.name)?;\n\n    // Step 3: Initialize .obsidian directory if needed\n    let obsidian_dir = vault_path.join(\".obsidian\");\n    if !obsidian_dir.exists() {\n        fs::create_dir_all(\u0026obsidian_dir)?;\n    }\n\n    // Step 4: Ensure config directory exists\n    if let Some(config_dir) = os_info.config_path.parent() {\n        fs::create_dir_all(config_dir)?;\n    }\n\n    // Step 5: Update Obsidian configuration\n    update_obsidian_config(\u0026os_info.config_path, \u0026vault_path_str)?;\n\n    // Step 6: Open Obsidian with the vault\n    if !os_info.open_command.is_empty() {\n        let mut cmd = Command::new(\u0026os_info.open_command[0]);\n        cmd.args(\u0026os_info.open_command[1..]);\n        cmd.arg(\u0026vault_path_str);\n\n        let output = cmd.output()?;\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            return Err(format!(\"Failed to open Obsidian: {}\", stderr).into());\n        }\n    }\n\n    Ok(format!(\n        \"Successfully opened vault '{}' in Obsidian\",\n        vault_path_str\n    ))\n}\n\nfn update_obsidian_config(\n    config_path: \u0026PathBuf,\n    vault_path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Read existing config or create new one\n    let mut config: serde_json::Value = if config_path.exists() {\n        let content = fs::read_to_string(config_path)?;\n        if content.trim().is_empty() {\n            serde_json::json!({})\n        } else {\n            serde_json::from_str(\u0026content).unwrap_or_else(|_| serde_json::json!({}))\n        }\n    } else {\n        serde_json::json!({})\n    };\n\n    // Ensure vaults object exists\n    if !config.is_object() {\n        config = serde_json::json!({});\n    }\n\n    let config_obj = config.as_object_mut().unwrap();\n    if !config_obj.contains_key(\"vaults\") {\n        config_obj.insert(\"vaults\".to_string(), serde_json::json!({}));\n    }\n\n    // Generate vault ID (16-character hex string based on path)\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    let mut hasher = DefaultHasher::new();\n    vault_path.hash(\u0026mut hasher);\n    let hash = hasher.finish();\n    let vault_id = format!(\"{:016x}\", hash)[..16].to_string();\n\n    // Add vault entry (check if it already exists)\n    let vaults = config_obj\n        .get_mut(\"vaults\")\n        .unwrap()\n        .as_object_mut()\n        .unwrap();\n\n    // Only add if vault doesn't already exist\n    if !vaults.contains_key(\u0026vault_id) {\n        vaults.insert(\n            vault_id,\n            serde_json::json!({\n                \"path\": vault_path,\n                \"ts\": std::time::SystemTime::now()\n                    .duration_since(std::time::UNIX_EPOCH)\n                    .unwrap()\n                    .as_millis() as u64,\n                \"open\": true\n            }),\n        );\n    } else {\n        // Update existing entry to mark as open and update timestamp\n        if let Some(vault_entry) = vaults.get_mut(\u0026vault_id) {\n            if let Some(vault_obj) = vault_entry.as_object_mut() {\n                vault_obj.insert(\"open\".to_string(), serde_json::json!(true));\n                vault_obj.insert(\n                    \"ts\".to_string(),\n                    serde_json::json!(std::time::SystemTime::now()\n                        .duration_since(std::time::UNIX_EPOCH)\n                        .unwrap()\n                        .as_millis() as u64),\n                );\n            }\n        }\n    }\n\n    // Write config back\n    let config_str = serde_json::to_string_pretty(\u0026config)?;\n    let mut file = fs::File::create(config_path)?;\n    file.write_all(config_str.as_bytes())?;\n\n    Ok(())\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":12}},{"line":27,"address":[],"length":0,"stats":{"Line":6}},{"line":30,"address":[],"length":0,"stats":{"Line":6}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":50,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":4}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":4}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":199,"address":[],"length":0,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":4}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":222,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":4}},{"line":227,"address":[],"length":0,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":8}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":4}},{"line":241,"address":[],"length":0,"stats":{"Line":8}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":4}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":250,"address":[],"length":0,"stats":{"Line":4}},{"line":251,"address":[],"length":0,"stats":{"Line":4}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":4}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":267,"address":[],"length":0,"stats":{"Line":4}},{"line":272,"address":[],"length":0,"stats":{"Line":8}},{"line":273,"address":[],"length":0,"stats":{"Line":8}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":4}},{"line":311,"address":[],"length":0,"stats":{"Line":4}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":314,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[],"length":0,"stats":{"Line":4}},{"line":318,"address":[],"length":0,"stats":{"Line":4}},{"line":319,"address":[],"length":0,"stats":{"Line":4}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":4}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":4}}],"covered":74,"coverable":108},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","phase.rs"],"content":"use metis_core::{transition_phase, validate_exit_criteria};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n#[mcp_tool(\n    name = \"transition_phase\",\n    description = \"Transition a document to a new phase\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct TransitionPhaseTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// New phase to transition to\n    pub new_phase: String,\n\n    /// Force transition even if exit criteria aren't met\n    pub force: Option\u003cbool\u003e,\n}\n\nimpl TransitionPhaseTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n        let force = self.force.unwrap_or(false);\n\n        match transition_phase(\u0026document_path, \u0026self.new_phase, force).await {\n            Ok(_) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Document transitioned to phase '{}' successfully\", self.new_phase),\n                    \"document_path\": self.document_path,\n                    \"new_phase\": self.new_phase,\n                    \"project_path\": self.project_path,\n                    \"force\": force\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to transition phase: {}\", e),\n                    \"document_path\": self.document_path,\n                    \"new_phase\": self.new_phase,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"check_phase_transition\",\n    description = \"Check if a document can transition to a new phase\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct CheckPhaseTransitionTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// Phase to check transition to\n    pub target_phase: String,\n}\n\nimpl CheckPhaseTransitionTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        // Note: can_transition_phase function doesn't exist in metis-core, using validate_exit_criteria instead\n        match validate_exit_criteria(\u0026document_path).await {\n            Ok(validation_result) =\u003e {\n                let can_transition = validation_result.met;\n                let response = serde_json::json!({\n                    \"can_transition\": can_transition,\n                    \"message\": if can_transition {\n                        format!(\"Document can transition to phase '{}'\", self.target_phase)\n                    } else {\n                        format!(\"Document cannot transition to phase '{}' - exit criteria not met\", self.target_phase)\n                    },\n                    \"document_path\": self.document_path,\n                    \"target_phase\": self.target_phase,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to check phase transition: {}\", e),\n                    \"document_path\": self.document_path,\n                    \"target_phase\": self.target_phase,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"validate_exit_criteria\",\n    description = \"Validate if a document's exit criteria are completed\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct ValidateExitCriteriaTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n}\n\nimpl ValidateExitCriteriaTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        match validate_exit_criteria(\u0026document_path).await {\n            Ok(validation_result) =\u003e {\n                let response = serde_json::json!({\n                    \"is_complete\": validation_result.met,\n                    \"total_criteria\": validation_result.total_criteria,\n                    \"completed_criteria\": validation_result.completed_criteria,\n                    \"missing_criteria\": validation_result.missing_criteria,\n                    \"message\": if validation_result.met {\n                        \"All exit criteria are completed\"\n                    } else {\n                        \"Some exit criteria are still pending\"\n                    },\n                    \"document_path\": self.document_path,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to validate exit criteria: {}\", e),\n                    \"document_path\": self.document_path,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":69},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","project.rs"],"content":"use metis_core::{initialize_project, ProjectConfig};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n// list_projects tool removed - direct path approach doesn't need project discovery\n\n#[mcp_tool(\n    name = \"initialize_project\",\n    description = \"Initialize a new Metis project by creating a 'metis' subdirectory at the specified path\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct InitializeProjectTool {\n    /// Path where the 'metis' subdirectory will be created (e.g., \"/path/to/my-project\" creates \"/path/to/my-project/metis/\")\n    pub project_path: String,\n\n    /// Name of the project\n    pub project_name: String,\n\n    /// Optional description for the project\n    pub description: Option\u003cString\u003e,\n}\n\nimpl InitializeProjectTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let base_path = PathBuf::from(\u0026self.project_path);\n\n        let config = ProjectConfig {\n            root_path: base_path,\n            name: self.project_name.clone(),\n            description: self.description.clone(),\n        };\n\n        match initialize_project(config).await {\n            Ok(metadata) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Project '{}' initialized successfully\", self.project_name),\n                    \"project_path\": metadata.project_path,\n                    \"database_path\": metadata.database_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to initialize project '{}': {}\", self.project_name, e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":30}},{"line":33,"address":[],"length":0,"stats":{"Line":10}},{"line":37,"address":[],"length":0,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":10}},{"line":42,"address":[],"length":0,"stats":{"Line":10}},{"line":43,"address":[],"length":0,"stats":{"Line":10}},{"line":44,"address":[],"length":0,"stats":{"Line":10}},{"line":45,"address":[],"length":0,"stats":{"Line":10}},{"line":46,"address":[],"length":0,"stats":{"Line":10}},{"line":49,"address":[],"length":0,"stats":{"Line":10}},{"line":50,"address":[],"length":0,"stats":{"Line":10}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":17},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","query.rs"],"content":"use chrono::{DateTime, Utc};\nuse metis_core::{Document, DocumentStore, DocumentType, SearchResult};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse std::str::FromStr;\n\n/// Document summary without content field for list operations\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DocumentSummary {\n    pub id: String,\n    pub filepath: String,\n    pub document_type: DocumentType,\n    pub level: DocumentType,\n    pub status: String,\n    pub parent_id: Option\u003cString\u003e,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub updated_at: DateTime\u003cUtc\u003e,\n    pub content_hash: String,\n    pub frontmatter: serde_json::Value,\n    pub exit_criteria_met: bool,\n    pub file_size: Option\u003ci64\u003e,\n    pub file_modified_at: Option\u003cf64\u003e,\n}\n\nimpl From\u003cDocument\u003e for DocumentSummary {\n    fn from(doc: Document) -\u003e Self {\n        Self {\n            id: doc.id,\n            filepath: doc.filepath,\n            document_type: doc.document_type,\n            level: doc.level,\n            status: doc.status,\n            parent_id: doc.parent_id,\n            created_at: doc.created_at,\n            updated_at: doc.updated_at,\n            content_hash: doc.content_hash,\n            frontmatter: doc.frontmatter,\n            exit_criteria_met: doc.exit_criteria_met,\n            file_size: doc.file_size,\n            file_modified_at: doc.file_modified_at,\n        }\n    }\n}\n\n/// Search result summary without content field for search operations\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SearchResultSummary {\n    pub document: DocumentSummary,\n    pub rank: f64,\n    pub snippet: String,\n}\n\nimpl From\u003cSearchResult\u003e for SearchResultSummary {\n    fn from(result: SearchResult) -\u003e Self {\n        Self {\n            document: DocumentSummary::from(result.document),\n            rank: result.rank,\n            snippet: result.snippet,\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"list_documents\",\n    description = \"List documents in a project with optional filtering\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct ListDocumentsTool {\n    /// Path to the .metis folder to list documents from\n    pub project_path: String,\n\n    /// Filter by document type (vision, strategy, initiative, task, adr)\n    pub document_type: Option\u003cString\u003e,\n\n    /// Filter by phase (draft, review, published, etc.)\n    pub phase: Option\u003cString\u003e,\n\n    /// Maximum number of results to return\n    pub limit: Option\u003cu32\u003e,\n}\n\nimpl ListDocumentsTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let db_path = project_path.join(\".metis.db\");\n\n        match DocumentStore::new(db_path.to_str().unwrap()).await {\n            Ok(store) =\u003e {\n                let query_service = store.query_service();\n\n                // Parse document type filter if provided\n                let doc_type_filter = if let Some(type_str) = \u0026self.document_type {\n                    match DocumentType::from_str(type_str) {\n                        Ok(doc_type) =\u003e Some(doc_type),\n                        Err(_) =\u003e return Ok(CallToolResult::text_content(\n                            vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                                \"error\": format!(\"Invalid document type '{}'. Must be: vision, strategy, initiative, task, adr\", type_str)\n                            })).map_err(CallToolError::new)?)]\n                        ))\n                    }\n                } else {\n                    None\n                };\n\n                // Query documents\n                let documents =\n                    if let Some(doc_type) = doc_type_filter {\n                        match query_service.find_documents_by_type(doc_type).await {\n                            Ok(docs) =\u003e docs,\n                            Err(e) =\u003e {\n                                return Ok(CallToolResult::text_content(vec![TextContent::from(\n                                    serde_json::to_string_pretty(\u0026serde_json::json!({\n                                        \"error\": format!(\"Failed to query documents: {}\", e)\n                                    }))\n                                    .map_err(CallToolError::new)?,\n                                )]))\n                            }\n                        }\n                    } else if let Some(phase) = \u0026self.phase {\n                        match query_service.find_documents_by_phase(phase).await {\n                        Ok(docs) =\u003e docs,\n                        Err(e) =\u003e return Ok(CallToolResult::text_content(\n                            vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                                \"error\": format!(\"Failed to query documents by phase: {}\", e)\n                            })).map_err(CallToolError::new)?)]\n                        ))\n                    }\n                    } else {\n                        // List all documents - use a generic query approach\n                        match query_service\n                            .find_documents_by_type(DocumentType::Vision)\n                            .await\n                        {\n                            Ok(mut all_docs) =\u003e {\n                                // Get documents of other types and combine\n                                for doc_type in [\n                                    DocumentType::Strategy,\n                                    DocumentType::Initiative,\n                                    DocumentType::Task,\n                                    DocumentType::Adr,\n                                ] {\n                                    if let Ok(docs) =\n                                        query_service.find_documents_by_type(doc_type).await\n                                    {\n                                        all_docs.extend(docs);\n                                    }\n                                }\n                                all_docs\n                            }\n                            Err(e) =\u003e {\n                                return Ok(CallToolResult::text_content(vec![TextContent::from(\n                                    serde_json::to_string_pretty(\u0026serde_json::json!({\n                                        \"error\": format!(\"Failed to query documents: {}\", e)\n                                    }))\n                                    .map_err(CallToolError::new)?,\n                                )]))\n                            }\n                        }\n                    };\n\n                // Apply limit if specified and convert to summaries\n                let limited_docs: Vec\u003cDocumentSummary\u003e = if let Some(limit) = self.limit {\n                    documents\n                        .into_iter()\n                        .take(limit as usize)\n                        .map(DocumentSummary::from)\n                        .collect()\n                } else {\n                    documents.into_iter().map(DocumentSummary::from).collect()\n                };\n\n                let response = serde_json::json!({\n                    \"message\": format!(\"Found {} documents\", limited_docs.len()),\n                    \"documents\": limited_docs,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to connect to database: {}\", e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"search_documents\",\n    description = \"Search documents by content with optional filtering\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct SearchDocumentsTool {\n    /// Path to the .metis folder to search documents in\n    pub project_path: String,\n\n    /// Search query to match against document content\n    pub query: String,\n\n    /// Filter by document type (vision, strategy, initiative, task, adr)\n    pub document_type: Option\u003cString\u003e,\n\n    /// Maximum number of results to return\n    pub limit: Option\u003cu32\u003e,\n}\n\nimpl SearchDocumentsTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let db_path = project_path.join(\".metis.db\");\n\n        match DocumentStore::new(db_path.to_str().unwrap()).await {\n            Ok(store) =\u003e {\n                let query_service = store.query_service();\n\n                // Perform the search with a reasonable default limit\n                let limit = self.limit.unwrap_or(100) as usize;\n                match query_service.search_content(\u0026self.query, limit).await {\n                    Ok(documents) =\u003e {\n                        // Filter by document type if specified\n                        let filtered_docs = if let Some(type_str) = \u0026self.document_type {\n                            match DocumentType::from_str(type_str) {\n                                Ok(doc_type) =\u003e {\n                                    documents.into_iter()\n                                        .filter(|doc| doc.document.document_type == doc_type)\n                                        .collect()\n                                }\n                                Err(_) =\u003e return Ok(CallToolResult::text_content(\n                                    vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                                        \"error\": format!(\"Invalid document type '{}'. Must be: vision, strategy, initiative, task, adr\", type_str)\n                                    })).map_err(CallToolError::new)?)]\n                                ))\n                            }\n                        } else {\n                            documents\n                        };\n\n                        // Apply limit if specified and convert to summaries\n                        let limited_docs: Vec\u003cSearchResultSummary\u003e = if let Some(limit) = self.limit\n                        {\n                            filtered_docs\n                                .into_iter()\n                                .take(limit as usize)\n                                .map(SearchResultSummary::from)\n                                .collect()\n                        } else {\n                            filtered_docs\n                                .into_iter()\n                                .map(SearchResultSummary::from)\n                                .collect()\n                        };\n\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Found {} documents matching '{}'\", limited_docs.len(), self.query),\n                            \"documents\": limited_docs,\n                            \"query\": self.query,\n                            \"project_path\": self.project_path\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Search failed: {}\", e)\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to connect to database: {}\", e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":16}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":16}},{"line":151,"address":[],"length":0,"stats":{"Line":16}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}}],"covered":46,"coverable":123},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","update.rs"],"content":"use metis_core::{update_blocked_by, update_document_content, update_exit_criterion};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n#[mcp_tool(\n    name = \"update_document_content\",\n    description = \"Update content of a specific H2 section in a document\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct UpdateDocumentContentTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// Section heading to update - must be an H2 level heading (e.g., \"Problem Statement\" targets \"## Problem Statement\")\n    pub section_heading: String,\n\n    /// New content for the section\n    pub new_content: String,\n}\n\nimpl UpdateDocumentContentTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        match update_document_content(\u0026document_path, \u0026self.section_heading, \u0026self.new_content)\n            .await\n        {\n            Ok(_) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Successfully updated section '{}' in document\", self.section_heading),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"section_heading\": self.section_heading\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to update document content: {}\", e),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"section_heading\": self.section_heading\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"update_exit_criterion\",\n    description = \"Update the completion status of an exit criterion\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct UpdateExitCriterionTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// Title of the exit criterion to update\n    pub criterion_title: String,\n\n    /// New completion status (true/false)\n    pub completed: bool,\n\n    /// Optional notes or evidence for the completion\n    pub notes: Option\u003cString\u003e,\n}\n\nimpl UpdateExitCriterionTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        match update_exit_criterion(\u0026document_path, \u0026self.criterion_title, self.completed).await {\n            Ok(_) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Successfully updated exit criterion '{}' to {}\",\n                        self.criterion_title,\n                        if self.completed { \"completed\" } else { \"pending\" }\n                    ),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"criterion_title\": self.criterion_title,\n                    \"completed\": self.completed\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to update exit criterion: {}\", e),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"criterion_title\": self.criterion_title\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"update_blocked_by\",\n    description = \"Update the blocked_by relationship for a document\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct UpdateBlockedByTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// List of document titles that this document is blocked by\n    pub blocked_by: Vec\u003cString\u003e,\n}\n\nimpl UpdateBlockedByTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        match update_blocked_by(\u0026document_path, self.blocked_by.clone()).await {\n            Ok(_) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Successfully updated blocked_by for document (now blocked by {} items)\", self.blocked_by.len()),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"blocked_by\": self.blocked_by\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to update blocked_by: {}\", e),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}}],"covered":13,"coverable":60}]};
        var previousData = {"files":[{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","context.rs"],"content":"//! Document context and related types for template rendering\n\nuse crate::{DocumentType, MetisError, Result};\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n/// Context for document creation containing all template variables\n#[derive(Debug, Clone, Serialize)]\npub struct DocumentContext {\n    // Core fields for all documents\n    pub title: String,\n    pub slug: String,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub updated_at: DateTime\u003cUtc\u003e,\n    pub parent_title: Option\u003cString\u003e,\n    pub blocked_by: Vec\u003cString\u003e,\n\n    // Document-type specific fields\n    pub risk_level: Option\u003cRiskLevel\u003e,        // Strategy\n    pub stakeholders: Vec\u003cString\u003e,            // Strategy, Vision\n    pub technical_lead: Option\u003cString\u003e,       // Initiative\n    pub complexity: Option\u003cComplexity\u003e,       // Initiative\n    pub decision_maker: Option\u003cString\u003e,       // ADR\n    pub decision_date: Option\u003cDateTime\u003cUtc\u003e\u003e, // ADR\n    pub number: Option\u003cu32\u003e,                  // ADR\n}\n\n/// Risk level for strategies\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum RiskLevel {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\n/// Complexity level for initiatives\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum Complexity {\n    S,  // Small\n    M,  // Medium\n    L,  // Large\n    XL, // Extra Large\n}\n\nimpl DocumentContext {\n    /// Create a new DocumentContext with required fields\n    pub fn new(title: String) -\u003e Self {\n        let slug = Self::title_to_slug(\u0026title);\n        let now = Utc::now();\n\n        Self {\n            title,\n            slug,\n            created_at: now,\n            updated_at: now,\n            parent_title: None,\n            blocked_by: Vec::new(),\n            risk_level: None,\n            stakeholders: Vec::new(),\n            technical_lead: None,\n            complexity: None,\n            decision_maker: None,\n            decision_date: None,\n            number: None,\n        }\n    }\n\n    /// Validate context for a specific document type\n    pub fn validate_for_type(\u0026self, doc_type: \u0026DocumentType) -\u003e Result\u003c()\u003e {\n        match doc_type {\n            DocumentType::Strategy =\u003e {\n                if self.risk_level.is_none() {\n                    return Err(MetisError::MissingRequiredField {\n                        field: \"risk_level\".to_string(),\n                    });\n                }\n            }\n            DocumentType::Initiative =\u003e {\n                if self.complexity.is_none() {\n                    return Err(MetisError::MissingRequiredField {\n                        field: \"complexity\".to_string(),\n                    });\n                }\n            }\n            DocumentType::Adr =\u003e {\n                if self.decision_maker.is_none() {\n                    return Err(MetisError::MissingRequiredField {\n                        field: \"decision_maker\".to_string(),\n                    });\n                }\n                if self.number.is_none() {\n                    return Err(MetisError::MissingRequiredField {\n                        field: \"number\".to_string(),\n                    });\n                }\n            }\n            DocumentType::Vision | DocumentType::Task =\u003e {\n                // No additional required fields\n            }\n        }\n        Ok(())\n    }\n\n    /// Convert title to URL-friendly slug\n    pub fn title_to_slug(title: \u0026str) -\u003e String {\n        title\n            .to_lowercase()\n            .chars()\n            .map(|c| if c.is_alphanumeric() { c } else { '-' })\n            .collect::\u003cString\u003e()\n            .split('-')\n            .filter(|s| !s.is_empty())\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"-\")\n    }\n\n    /// Builder pattern methods for setting optional fields\n    pub fn with_parent(mut self, parent_title: String) -\u003e Self {\n        self.parent_title = Some(parent_title);\n        self\n    }\n\n    pub fn with_blocked_by(mut self, blocked_by: Vec\u003cString\u003e) -\u003e Self {\n        self.blocked_by = blocked_by;\n        self\n    }\n\n    pub fn with_risk_level(mut self, risk_level: RiskLevel) -\u003e Self {\n        self.risk_level = Some(risk_level);\n        self\n    }\n\n    pub fn with_stakeholders(mut self, stakeholders: Vec\u003cString\u003e) -\u003e Self {\n        self.stakeholders = stakeholders;\n        self\n    }\n\n    pub fn with_technical_lead(mut self, technical_lead: String) -\u003e Self {\n        self.technical_lead = Some(technical_lead);\n        self\n    }\n\n    pub fn with_complexity(mut self, complexity: Complexity) -\u003e Self {\n        self.complexity = Some(complexity);\n        self\n    }\n\n    pub fn with_decision_maker(mut self, decision_maker: String) -\u003e Self {\n        self.decision_maker = Some(decision_maker);\n        self\n    }\n\n    pub fn with_decision_date(mut self, decision_date: DateTime\u003cUtc\u003e) -\u003e Self {\n        self.decision_date = Some(decision_date);\n        self\n    }\n\n    pub fn with_number(mut self, number: u32) -\u003e Self {\n        self.number = Some(number);\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::Utc;\n\n    #[test]\n    fn test_title_to_slug() {\n        assert_eq!(\n            DocumentContext::title_to_slug(\"Core Document Management Library\"),\n            \"core-document-management-library\"\n        );\n        assert_eq!(\n            DocumentContext::title_to_slug(\"ADR-001: Document Format\"),\n            \"adr-001-document-format\"\n        );\n        assert_eq!(\n            DocumentContext::title_to_slug(\"Storage \u0026 Indexing System\"),\n            \"storage-indexing-system\"\n        );\n    }\n\n    #[test]\n    fn test_new_context() {\n        let ctx = DocumentContext::new(\"Test Document\".to_string());\n        assert_eq!(ctx.title, \"Test Document\");\n        assert_eq!(ctx.slug, \"test-document\");\n        assert!(ctx.created_at \u003c= Utc::now());\n        assert!(ctx.updated_at \u003c= Utc::now());\n    }\n\n    #[test]\n    fn test_strategy_validation() {\n        let ctx = DocumentContext::new(\"Test Strategy\".to_string());\n\n        // Should fail without risk_level\n        assert!(ctx.validate_for_type(\u0026DocumentType::Strategy).is_err());\n\n        // Should pass with risk_level\n        let ctx_with_risk = ctx.with_risk_level(RiskLevel::Medium);\n        assert!(ctx_with_risk\n            .validate_for_type(\u0026DocumentType::Strategy)\n            .is_ok());\n    }\n\n    #[test]\n    fn test_initiative_validation() {\n        let ctx = DocumentContext::new(\"Test Initiative\".to_string());\n\n        // Should fail without complexity\n        assert!(ctx.validate_for_type(\u0026DocumentType::Initiative).is_err());\n\n        // Should pass with complexity\n        let ctx_with_complexity = ctx.with_complexity(Complexity::M);\n        assert!(ctx_with_complexity\n            .validate_for_type(\u0026DocumentType::Initiative)\n            .is_ok());\n    }\n\n    #[test]\n    fn test_adr_validation() {\n        let ctx = DocumentContext::new(\"Test ADR\".to_string());\n\n        // Should fail without decision_maker and number\n        assert!(ctx.validate_for_type(\u0026DocumentType::Adr).is_err());\n\n        // Should pass with required fields\n        let ctx_complete = ctx\n            .with_decision_maker(\"Engineering Team\".to_string())\n            .with_number(1);\n        assert!(ctx_complete.validate_for_type(\u0026DocumentType::Adr).is_ok());\n    }\n\n    #[test]\n    fn test_vision_and_task_validation() {\n        let ctx = DocumentContext::new(\"Test Document\".to_string());\n\n        // Vision and Task have no additional requirements\n        assert!(ctx.validate_for_type(\u0026DocumentType::Vision).is_ok());\n        assert!(ctx.validate_for_type(\u0026DocumentType::Task).is_ok());\n    }\n\n    #[test]\n    fn test_builder_pattern() {\n        let ctx = DocumentContext::new(\"Test Document\".to_string())\n            .with_parent(\"Parent Document\".to_string())\n            .with_blocked_by(vec![\"Blocker 1\".to_string(), \"Blocker 2\".to_string()])\n            .with_stakeholders(vec![\"Alice\".to_string(), \"Bob\".to_string()]);\n\n        assert_eq!(ctx.parent_title, Some(\"Parent Document\".to_string()));\n        assert_eq!(ctx.blocked_by.len(), 2);\n        assert_eq!(ctx.stakeholders.len(), 2);\n    }\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":52}},{"line":51,"address":[],"length":0,"stats":{"Line":52}},{"line":52,"address":[],"length":0,"stats":{"Line":52}},{"line":60,"address":[],"length":0,"stats":{"Line":52}},{"line":62,"address":[],"length":0,"stats":{"Line":52}},{"line":72,"address":[],"length":0,"stats":{"Line":67}},{"line":73,"address":[],"length":0,"stats":{"Line":67}},{"line":75,"address":[],"length":0,"stats":{"Line":15}},{"line":76,"address":[],"length":0,"stats":{"Line":3}},{"line":77,"address":[],"length":0,"stats":{"Line":3}},{"line":82,"address":[],"length":0,"stats":{"Line":18}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":28}},{"line":104,"address":[],"length":0,"stats":{"Line":60}},{"line":108,"address":[],"length":0,"stats":{"Line":61}},{"line":109,"address":[],"length":0,"stats":{"Line":61}},{"line":112,"address":[],"length":0,"stats":{"Line":3266}},{"line":115,"address":[],"length":0,"stats":{"Line":286}},{"line":121,"address":[],"length":0,"stats":{"Line":10}},{"line":122,"address":[],"length":0,"stats":{"Line":10}},{"line":123,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":6}},{"line":136,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":7}},{"line":147,"address":[],"length":0,"stats":{"Line":7}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":151,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":4}}],"covered":47,"coverable":52},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","core.rs"],"content":"//! Core document management functions for the Metis methodology\n//!\n//! This module provides the main public API for document creation, validation,\n//! and rendering. It re-exports types and functions from specialized modules.\n\n// Re-export main types and functions\npub use crate::context::{Complexity, DocumentContext, RiskLevel};\npub use crate::exit_criteria::{\n    validate_exit_criteria, validate_exit_criteria_content, ExitCriteriaResult,\n};\npub use crate::phases::{can_transition_to_phase, transition_phase};\npub use crate::render::render;\npub use crate::template::TemplateEngine;\npub use crate::validation::{validate, validate_content, ValidationResult};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","database","mod.rs"],"content":"//! Database operations for document storage and retrieval\n\npub mod query;\n\nuse crate::{Document, DocumentType, MetisError, Result};\nuse chrono::{DateTime, Utc};\nuse gray_matter;\nuse sha2::{Digest, Sha256};\nuse sqlx::{migrate::MigrateDatabase, SqlitePool};\nuse std::fs;\nuse std::path::Path;\n\n// Re-export query types\npub use query::{QueryService, Relationship, RelationshipDirection, SearchResult};\n\n#[derive(Clone)]\npub struct DocumentStore {\n    pool: SqlitePool,\n}\n\nimpl DocumentStore {\n    /// Create a new DocumentStore with automatic database creation and migrations\n    pub async fn new(database_url: \u0026str) -\u003e Result\u003cSelf\u003e {\n        // Create database if it doesn't exist\n        if !sqlx::Sqlite::database_exists(database_url).await? {\n            sqlx::Sqlite::create_database(database_url).await?;\n        }\n\n        let pool = SqlitePool::connect(database_url).await?;\n\n        // Run migrations\n        sqlx::migrate!(\"./src/migrations\").run(\u0026pool).await?;\n\n        Ok(Self { pool })\n    }\n\n    /// Create a DocumentStore from an existing pool (useful for testing)\n    pub async fn from_pool(pool: SqlitePool) -\u003e Result\u003cSelf\u003e {\n        let store = Self { pool };\n\n        // Run migrations\n        sqlx::migrate!(\"./src/migrations\").run(\u0026store.pool).await?;\n\n        Ok(store)\n    }\n\n    /// Get the underlying database pool\n    pub fn pool(\u0026self) -\u003e \u0026SqlitePool {\n        \u0026self.pool\n    }\n\n    /// Create a QueryService using this DocumentStore's database pool\n    pub fn query_service(\u0026self) -\u003e QueryService {\n        QueryService::new(self.pool.clone())\n    }\n\n    /// Store a document by reading and parsing the file at the given path\n    pub async fn store_document(\u0026self, filepath: \u0026Path) -\u003e Result\u003cDocument\u003e {\n        // Read file contents\n        let raw_content = fs::read_to_string(filepath).map_err(MetisError::Io)?;\n\n        // Parse frontmatter and content\n        let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026raw_content);\n\n        // Extract frontmatter as JSON\n        let frontmatter: serde_json::Value = if let Some(data) = parsed.data {\n            // gray_matter returns a Pod which we need to convert to serde_json::Value\n            match data {\n                gray_matter::Pod::Hash(map) =\u003e {\n                    let mut json_map = serde_json::Map::new();\n                    for (key, value) in map {\n                        let json_value = match value {\n                            gray_matter::Pod::String(s) =\u003e serde_json::Value::String(s),\n                            gray_matter::Pod::Integer(i) =\u003e {\n                                serde_json::Value::Number(serde_json::Number::from(i))\n                            }\n                            gray_matter::Pod::Float(f) =\u003e serde_json::Value::Number(\n                                serde_json::Number::from_f64(f)\n                                    .unwrap_or(serde_json::Number::from(0)),\n                            ),\n                            gray_matter::Pod::Boolean(b) =\u003e serde_json::Value::Bool(b),\n                            gray_matter::Pod::Array(arr) =\u003e {\n                                let json_arr: Vec\u003cserde_json::Value\u003e = arr\n                                    .into_iter()\n                                    .map(|item| match item {\n                                        gray_matter::Pod::String(s) =\u003e serde_json::Value::String(s),\n                                        _ =\u003e serde_json::Value::String(format!(\"{:?}\", item)),\n                                    })\n                                    .collect();\n                                serde_json::Value::Array(json_arr)\n                            }\n                            _ =\u003e serde_json::Value::String(format!(\"{:?}\", value)),\n                        };\n                        json_map.insert(key, json_value);\n                    }\n                    serde_json::Value::Object(json_map)\n                }\n                _ =\u003e serde_json::Value::Object(serde_json::Map::new()),\n            }\n        } else {\n            serde_json::Value::Object(serde_json::Map::new())\n        };\n\n        // Calculate content hash\n        let mut hasher = Sha256::new();\n        hasher.update(raw_content.as_bytes());\n        let content_hash = format!(\"{:x}\", hasher.finalize());\n\n        // Extract document metadata from frontmatter\n        let id = frontmatter\n            .get(\"id\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| MetisError::MissingRequiredField {\n                field: \"id\".to_string(),\n            })?\n            .to_string();\n\n        let document_type_str = frontmatter\n            .get(\"level\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| MetisError::MissingRequiredField {\n                field: \"level\".to_string(),\n            })?;\n        let document_type: DocumentType = document_type_str.parse()?;\n\n        let status = frontmatter\n            .get(\"status\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| MetisError::MissingRequiredField {\n                field: \"status\".to_string(),\n            })?\n            .to_string();\n\n        // Force parent_id to None for vision and ADR documents since they can't have parents\n        let parent_id = if document_type_str == \"vision\" || document_type_str == \"adr\" {\n            None\n        } else {\n            frontmatter\n                .get(\"parent\")\n                .and_then(|v| if v.is_null() { None } else { v.as_str() })\n                .filter(|s| !s.trim().is_empty())\n                .map(|s| s.to_string())\n        };\n\n        let exit_criteria_met = frontmatter\n            .get(\"exit_criteria_met\")\n            .and_then(|v| v.as_bool())\n            .unwrap_or(false);\n\n        let created_at = frontmatter\n            .get(\"created_at\")\n            .and_then(|v| v.as_str())\n            .and_then(|s| DateTime::parse_from_rfc3339(s).ok())\n            .map(|dt| dt.with_timezone(\u0026Utc))\n            .unwrap_or_else(Utc::now);\n\n        let updated_at = frontmatter\n            .get(\"updated_at\")\n            .and_then(|v| v.as_str())\n            .and_then(|s| DateTime::parse_from_rfc3339(s).ok())\n            .map(|dt| dt.with_timezone(\u0026Utc))\n            .unwrap_or_else(Utc::now);\n\n        // Get file metadata for new fields\n        let metadata = std::fs::metadata(filepath).map_err(MetisError::Io)?;\n        let file_size = metadata.len() as i64;\n        let file_modified_at = metadata\n            .modified()\n            .map_err(MetisError::Io)?\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_secs_f64();\n\n        // Create Document struct\n        let document = Document {\n            id: id.clone(),\n            filepath: filepath.to_string_lossy().to_string(),\n            document_type: document_type.clone(),\n            level: document_type,\n            status,\n            parent_id,\n            created_at,\n            updated_at,\n            content_hash,\n            frontmatter: frontmatter.clone(),\n            exit_criteria_met,\n            content: Some(parsed.content),\n            file_size: Some(file_size),\n            file_modified_at: Some(file_modified_at),\n        };\n\n        // Store in database - create bindings to avoid temporary value issues\n        let doc_type_str = document.document_type.to_string();\n        let level_str = document.level.to_string();\n        let created_at_timestamp = document.created_at.timestamp_millis() as f64 / 1000.0;\n        let updated_at_timestamp = document.updated_at.timestamp_millis() as f64 / 1000.0;\n        let frontmatter_json = serde_json::to_string(\u0026document.frontmatter)?;\n\n        sqlx::query!(\n            r#\"\n            INSERT OR REPLACE INTO documents \n            (id, filepath, document_type, level, status, parent_id, \n             created_at, updated_at, content_hash, frontmatter_json, \n             exit_criteria_met, content, file_size, file_modified_at)\n            VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14)\n            \"#,\n            document.id,\n            document.filepath,\n            doc_type_str,\n            level_str,\n            document.status,\n            document.parent_id,\n            created_at_timestamp,\n            updated_at_timestamp,\n            document.content_hash,\n            frontmatter_json,\n            document.exit_criteria_met,\n            document.content,\n            document.file_size,\n            document.file_modified_at\n        )\n        .execute(\u0026self.pool)\n        .await?;\n\n        // Extract and store properties for efficient queries\n        self.update_properties(\u0026document.id, \u0026frontmatter).await?;\n\n        Ok(document)\n    }\n\n    /// Get a document by ID\n    pub async fn get_document(\u0026self, document_id: \u0026str) -\u003e Result\u003cOption\u003cDocument\u003e\u003e {\n        let record = sqlx::query!(\n            r#\"\n            SELECT id, filepath, document_type, level, status, parent_id, \n                   created_at, updated_at, content_hash, frontmatter_json, \n                   exit_criteria_met, content, file_size, file_modified_at\n            FROM documents \n            WHERE id = ?\n            \"#,\n            document_id\n        )\n        .fetch_optional(\u0026self.pool)\n        .await?;\n\n        if let Some(row) = record {\n            let document_type: DocumentType = row.document_type.parse()?;\n            let level: DocumentType = row.level.parse()?;\n            let frontmatter: serde_json::Value = serde_json::from_str(\u0026row.frontmatter_json)?;\n            let created_at =\n                DateTime::from_timestamp(row.created_at as i64, 0).unwrap_or_else(Utc::now);\n            let updated_at =\n                DateTime::from_timestamp(row.updated_at as i64, 0).unwrap_or_else(Utc::now);\n\n            Ok(Some(Document {\n                id: row.id.unwrap_or_default(),\n                filepath: row.filepath,\n                document_type,\n                level,\n                status: row.status,\n                parent_id: row.parent_id,\n                created_at,\n                updated_at,\n                content_hash: row.content_hash,\n                frontmatter,\n                exit_criteria_met: row.exit_criteria_met.unwrap_or(false),\n                content: row.content,\n                file_size: row.file_size,\n                file_modified_at: row.file_modified_at,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Update an existing document by re-reading the file\n    pub async fn update_document(\u0026self, filepath: \u0026Path) -\u003e Result\u003cDocument\u003e {\n        // For updates, we just re-store the document which will replace it\n        self.store_document(filepath).await\n    }\n\n    /// Delete a document by ID\n    pub async fn delete_document(\u0026self, document_id: \u0026str) -\u003e Result\u003cbool\u003e {\n        let result = sqlx::query!(\"DELETE FROM documents WHERE id = ?\", document_id)\n            .execute(\u0026self.pool)\n            .await?;\n\n        Ok(result.rows_affected() \u003e 0)\n    }\n\n    /// Extract frontmatter properties and store them for efficient querying\n    async fn update_properties(\n        \u0026self,\n        document_id: \u0026str,\n        frontmatter: \u0026serde_json::Value,\n    ) -\u003e Result\u003c()\u003e {\n        // First, delete existing properties for this document\n        sqlx::query!(\n            \"DELETE FROM document_properties WHERE document_id = ?\",\n            document_id\n        )\n        .execute(\u0026self.pool)\n        .await?;\n\n        // Extract properties from frontmatter\n        if let serde_json::Value::Object(map) = frontmatter {\n            for (key, value) in map {\n                let (prop_value, prop_type) = match value {\n                    serde_json::Value::String(s) =\u003e (s.clone(), \"text\".to_string()),\n                    serde_json::Value::Number(n) =\u003e (n.to_string(), \"number\".to_string()),\n                    serde_json::Value::Bool(b) =\u003e (b.to_string(), \"boolean\".to_string()),\n                    serde_json::Value::Array(_) =\u003e (value.to_string(), \"array\".to_string()),\n                    _ =\u003e (value.to_string(), \"text\".to_string()),\n                };\n\n                sqlx::query!(\n                    r#\"\n                    INSERT INTO document_properties \n                    (document_id, property_name, property_value, property_type)\n                    VALUES (?1, ?2, ?3, ?4)\n                    \"#,\n                    document_id,\n                    key,\n                    prop_value,\n                    prop_type\n                )\n                .execute(\u0026self.pool)\n                .await?;\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use sqlx::SqlitePool;\n    use std::fs;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    async fn create_test_store() -\u003e DocumentStore {\n        let pool = SqlitePool::connect(\":memory:\").await.unwrap();\n        DocumentStore::from_pool(pool).await.unwrap()\n    }\n\n    fn create_test_document_file(content: \u0026str) -\u003e NamedTempFile {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        temp_file.write_all(content.as_bytes()).unwrap();\n        temp_file.flush().unwrap();\n        temp_file\n    }\n\n    #[tokio::test]\n    async fn test_document_store_creation() {\n        let pool = SqlitePool::connect(\":memory:\").await.unwrap();\n        let store = DocumentStore::from_pool(pool).await.unwrap();\n\n        // Verify tables were created by checking the schema\n        let tables: Vec\u003c(String,)\u003e =\n            sqlx::query_as(\"SELECT name FROM sqlite_master WHERE type='table' ORDER BY name\")\n                .fetch_all(store.pool())\n                .await\n                .unwrap();\n\n        let table_names: Vec\u003cString\u003e = tables.into_iter().map(|(name,)| name).collect();\n\n        assert!(table_names.contains(\u0026\"documents\".to_string()));\n        assert!(table_names.contains(\u0026\"document_relationships\".to_string()));\n        assert!(table_names.contains(\u0026\"document_properties\".to_string()));\n        assert!(table_names.contains(\u0026\"document_search\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_store_document() {\n        let store = create_test_store().await;\n\n        let document_content = r##\"---\nid: test-vision-document\nlevel: vision\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\ntags:\n  - \"#vision\"\n  - \"#phase/shaping\"\n---\n\n# Test Vision Document\n\nThis is a test vision document for testing purposes.\n\n## Goals\n\n- Test goal 1\n- Test goal 2\n\"##;\n\n        let temp_file = create_test_document_file(document_content);\n        let result = store.store_document(temp_file.path()).await;\n\n        assert!(result.is_ok());\n        let document = result.unwrap();\n\n        assert_eq!(document.id, \"test-vision-document\");\n        assert_eq!(document.document_type, DocumentType::Vision);\n        assert_eq!(document.status, \"draft\");\n        // Phase is now in tags, not a separate field\n        assert!(document.content.is_some());\n        assert!(document\n            .content\n            .as_ref()\n            .unwrap()\n            .contains(\"Test Vision Document\"));\n    }\n\n    #[tokio::test]\n    async fn test_get_document() {\n        let store = create_test_store().await;\n\n        let document_content = r#\"---\nid: test-get-document\nlevel: strategy\nstatus: active\nphase: design\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\n---\n\n# Test Strategy Document\n\nContent for get test.\n\"#;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Store the document first\n        store.store_document(temp_file.path()).await.unwrap();\n\n        // Now get it\n        let result = store.get_document(\"test-get-document\").await;\n        assert!(result.is_ok());\n\n        let document = result.unwrap();\n        assert!(document.is_some());\n\n        let doc = document.unwrap();\n        assert_eq!(doc.id, \"test-get-document\");\n        assert_eq!(doc.document_type, DocumentType::Strategy);\n        assert_eq!(doc.status, \"active\");\n        // Phase is now in tags, not a separate field\n    }\n\n    #[tokio::test]\n    async fn test_get_nonexistent_document() {\n        let store = create_test_store().await;\n\n        let result = store.get_document(\"nonexistent-document\").await;\n        assert!(result.is_ok());\n        assert!(result.unwrap().is_none());\n    }\n\n    #[tokio::test]\n    async fn test_update_document() {\n        let store = create_test_store().await;\n\n        let initial_content = r#\"---\nid: test-update-document\nlevel: task\nstatus: todo\nphase: todo\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\n---\n\n# Initial Content\n\"#;\n\n        let updated_content = r#\"---\nid: test-update-document\nlevel: task\nstatus: doing\nphase: doing\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T19:00:00Z\nexit_criteria_met: false\n---\n\n# Updated Content\n\nThis content has been updated.\n\"#;\n\n        let temp_file = create_test_document_file(initial_content);\n\n        // Store initial document\n        let initial_doc = store.store_document(temp_file.path()).await.unwrap();\n        assert_eq!(initial_doc.status, \"todo\");\n\n        // Update the file content\n        fs::write(temp_file.path(), updated_content).unwrap();\n\n        // Update the document\n        let updated_doc = store.update_document(temp_file.path()).await.unwrap();\n        assert_eq!(updated_doc.status, \"doing\");\n        assert!(updated_doc\n            .content\n            .as_ref()\n            .unwrap()\n            .contains(\"Updated Content\"));\n\n        // Verify it was updated in the database\n        let retrieved_doc = store\n            .get_document(\"test-update-document\")\n            .await\n            .unwrap()\n            .unwrap();\n        assert_eq!(retrieved_doc.status, \"doing\");\n    }\n\n    #[tokio::test]\n    async fn test_delete_document() {\n        let store = create_test_store().await;\n\n        let document_content = r#\"---\nid: test-delete-document\nlevel: adr\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\n---\n\n# Document to Delete\n\"#;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Store the document\n        store.store_document(temp_file.path()).await.unwrap();\n\n        // Verify it exists\n        let doc = store.get_document(\"test-delete-document\").await.unwrap();\n        assert!(doc.is_some());\n\n        // Delete it\n        let deleted = store.delete_document(\"test-delete-document\").await.unwrap();\n        assert!(deleted);\n\n        // Verify it's gone\n        let doc_after = store.get_document(\"test-delete-document\").await.unwrap();\n        assert!(doc_after.is_none());\n\n        // Try to delete again - should return false\n        let deleted_again = store.delete_document(\"test-delete-document\").await.unwrap();\n        assert!(!deleted_again);\n    }\n\n    #[tokio::test]\n    async fn test_properties_extraction() {\n        let store = create_test_store().await;\n\n        let document_content = r##\"---\nid: test-properties-document\nlevel: initiative\nstatus: active\nphase: design\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\ntechnical_lead: john.doe\nestimated_complexity: l\npriority: high\ntags:\n  - \"#initiative\"\n  - \"#phase/design\"\n---\n\n# Test Properties Document\n\"##;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Store the document\n        store.store_document(temp_file.path()).await.unwrap();\n\n        // Check that properties were extracted\n        let properties: Vec\u003c(String, String, String)\u003e = sqlx::query_as(\n            \"SELECT property_name, property_value, property_type FROM document_properties WHERE document_id = ? ORDER BY property_name\"\n        )\n        .bind(\"test-properties-document\")\n        .fetch_all(store.pool())\n        .await\n        .unwrap();\n\n        // Should have extracted multiple properties\n        assert!(!properties.is_empty());\n\n        // Check for specific properties\n        let technical_lead = properties\n            .iter()\n            .find(|(name, _, _)| name == \"technical_lead\");\n        assert!(technical_lead.is_some());\n        assert_eq!(technical_lead.unwrap().1, \"john.doe\");\n\n        let complexity = properties\n            .iter()\n            .find(|(name, _, _)| name == \"estimated_complexity\");\n        assert!(complexity.is_some());\n        assert_eq!(complexity.unwrap().1, \"l\");\n    }\n\n    #[tokio::test]\n    async fn test_missing_required_fields() {\n        let store = create_test_store().await;\n\n        let document_content = r#\"---\nstatus: draft\nphase: shaping\n---\n\n# Document Missing Required Fields\n\"#;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Should fail due to missing id field\n        let result = store.store_document(temp_file.path()).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::MissingRequiredField { field }) = result {\n            assert_eq!(field, \"id\");\n        } else {\n            panic!(\"Expected MissingRequiredField error\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_content_hash_calculation() {\n        let store = create_test_store().await;\n\n        let document_content = r#\"---\nid: test-hash-document\nlevel: vision\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-02T18:00:00Z\nupdated_at: 2025-07-02T18:00:00Z\nexit_criteria_met: false\n---\n\n# Test Hash Document\n\nContent for hash testing.\n\"#;\n\n        let temp_file = create_test_document_file(document_content);\n\n        // Store the document\n        let doc1 = store.store_document(temp_file.path()).await.unwrap();\n\n        // Store the same document again\n        let doc2 = store.store_document(temp_file.path()).await.unwrap();\n\n        // Content hashes should be the same\n        assert_eq!(doc1.content_hash, doc2.content_hash);\n        assert!(!doc1.content_hash.is_empty());\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":66}},{"line":25,"address":[],"length":0,"stats":{"Line":33}},{"line":26,"address":[],"length":0,"stats":{"Line":21}},{"line":29,"address":[],"length":0,"stats":{"Line":66}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":33}},{"line":40,"address":[],"length":0,"stats":{"Line":40}},{"line":41,"address":[],"length":0,"stats":{"Line":20}},{"line":44,"address":[],"length":0,"stats":{"Line":20}},{"line":45,"address":[],"length":0,"stats":{"Line":20}},{"line":46,"address":[],"length":0,"stats":{"Line":20}},{"line":48,"address":[],"length":0,"stats":{"Line":20}},{"line":52,"address":[],"length":0,"stats":{"Line":24}},{"line":53,"address":[],"length":0,"stats":{"Line":24}},{"line":57,"address":[],"length":0,"stats":{"Line":20}},{"line":58,"address":[],"length":0,"stats":{"Line":20}},{"line":62,"address":[],"length":0,"stats":{"Line":74}},{"line":64,"address":[],"length":0,"stats":{"Line":74}},{"line":65,"address":[],"length":0,"stats":{"Line":74}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":37}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":37}},{"line":75,"address":[],"length":0,"stats":{"Line":37}},{"line":76,"address":[],"length":0,"stats":{"Line":663}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":220}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":36}},{"line":82,"address":[],"length":0,"stats":{"Line":36}},{"line":83,"address":[],"length":0,"stats":{"Line":74}},{"line":84,"address":[],"length":0,"stats":{"Line":38}},{"line":85,"address":[],"length":0,"stats":{"Line":38}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":74}},{"line":89,"address":[],"length":0,"stats":{"Line":36}},{"line":91,"address":[],"length":0,"stats":{"Line":20}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":36}},{"line":110,"address":[],"length":0,"stats":{"Line":36}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":114,"address":[],"length":0,"stats":{"Line":36}},{"line":115,"address":[],"length":0,"stats":{"Line":36}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":36}},{"line":119,"address":[],"length":0,"stats":{"Line":36}},{"line":120,"address":[],"length":0,"stats":{"Line":36}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":25}},{"line":126,"address":[],"length":0,"stats":{"Line":12}},{"line":128,"address":[],"length":0,"stats":{"Line":24}},{"line":129,"address":[],"length":0,"stats":{"Line":33}},{"line":130,"address":[],"length":0,"stats":{"Line":9}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":9}},{"line":136,"address":[],"length":0,"stats":{"Line":9}},{"line":137,"address":[],"length":0,"stats":{"Line":9}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":36}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":36}},{"line":146,"address":[],"length":0,"stats":{"Line":36}},{"line":147,"address":[],"length":0,"stats":{"Line":36}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":36}},{"line":152,"address":[],"length":0,"stats":{"Line":36}},{"line":153,"address":[],"length":0,"stats":{"Line":36}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":36}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":36}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":36}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":8}},{"line":217,"address":[],"length":0,"stats":{"Line":30}},{"line":219,"address":[],"length":0,"stats":{"Line":26}},{"line":223,"address":[],"length":0,"stats":{"Line":18}},{"line":224,"address":[],"length":0,"stats":{"Line":18}},{"line":232,"address":[],"length":0,"stats":{"Line":9}},{"line":234,"address":[],"length":0,"stats":{"Line":9}},{"line":235,"address":[],"length":0,"stats":{"Line":9}},{"line":237,"address":[],"length":0,"stats":{"Line":6}},{"line":238,"address":[],"length":0,"stats":{"Line":6}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":8}},{"line":275,"address":[],"length":0,"stats":{"Line":8}},{"line":277,"address":[],"length":0,"stats":{"Line":4}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":56}},{"line":288,"address":[],"length":0,"stats":{"Line":28}},{"line":290,"address":[],"length":0,"stats":{"Line":28}},{"line":292,"address":[],"length":0,"stats":{"Line":28}},{"line":293,"address":[],"length":0,"stats":{"Line":30}},{"line":296,"address":[],"length":0,"stats":{"Line":52}},{"line":297,"address":[],"length":0,"stats":{"Line":420}},{"line":298,"address":[],"length":0,"stats":{"Line":394}},{"line":299,"address":[],"length":0,"stats":{"Line":156}},{"line":300,"address":[],"length":0,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":26}},{"line":302,"address":[],"length":0,"stats":{"Line":14}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":197}},{"line":312,"address":[],"length":0,"stats":{"Line":197}},{"line":313,"address":[],"length":0,"stats":{"Line":197}},{"line":314,"address":[],"length":0,"stats":{"Line":197}},{"line":315,"address":[],"length":0,"stats":{"Line":197}},{"line":317,"address":[],"length":0,"stats":{"Line":197}},{"line":318,"address":[],"length":0,"stats":{"Line":197}},{"line":322,"address":[],"length":0,"stats":{"Line":26}}],"covered":98,"coverable":172},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","database","query.rs"],"content":"//! Query operations for document discovery and search\n\nuse crate::{Document, DocumentType, RelationshipType, Result};\nuse sqlx::SqlitePool;\n\n/// Search result with ranking and snippet\n#[derive(Debug, Clone, serde::Serialize)]\npub struct SearchResult {\n    pub document: Document,\n    pub rank: f64,\n    pub snippet: String,\n}\n\n/// Direction for relationship queries\n#[derive(Debug, Clone)]\npub enum RelationshipDirection {\n    /// Relationships where this document is the source (outgoing)\n    Outgoing,\n    /// Relationships where this document is the target (incoming)\n    Incoming,\n    /// All relationships involving this document\n    Both,\n}\n\n/// Document relationship with metadata\n#[derive(Debug, Clone, serde::Serialize)]\npub struct Relationship {\n    pub from_id: String,\n    pub to_id: String,\n    pub relationship_type: RelationshipType,\n    pub created_at: chrono::DateTime\u003cchrono::Utc\u003e,\n}\n\n/// Query service for document operations\n#[derive(Clone)]\npub struct QueryService {\n    pool: SqlitePool,\n}\n\nimpl QueryService {\n    /// Create a new QueryService with the given database pool\n    pub fn new(pool: SqlitePool) -\u003e Self {\n        Self { pool }\n    }\n\n    /// Find documents by document type\n    pub async fn find_documents_by_type(\u0026self, doc_type: DocumentType) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        self.find_documents_by_type_paginated(doc_type, None, None)\n            .await\n    }\n\n    /// Find documents by document type with pagination\n    pub async fn find_documents_by_type_paginated(\n        \u0026self,\n        doc_type: DocumentType,\n        limit: Option\u003cusize\u003e,\n        offset: Option\u003cusize\u003e,\n    ) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let doc_type_str = doc_type.to_string();\n\n        let sql = format!(\n            r#\"\n            SELECT id, filepath, document_type, level, status, parent_id, \n                   created_at, updated_at, content_hash, frontmatter_json, \n                   exit_criteria_met, content, file_size, file_modified_at\n            FROM documents \n            WHERE document_type = ?\n            ORDER BY updated_at DESC\n            {}\n            \"#,\n            match (limit, offset) {\n                (Some(l), Some(o)) =\u003e format!(\"LIMIT {} OFFSET {}\", l, o),\n                (Some(l), None) =\u003e format!(\"LIMIT {}\", l),\n                (None, Some(o)) =\u003e format!(\"OFFSET {}\", o),\n                (None, None) =\u003e String::new(),\n            }\n        );\n\n        let records = sqlx::query(\u0026sql)\n            .bind(\u0026doc_type_str)\n            .fetch_all(\u0026self.pool)\n            .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            use sqlx::Row;\n            documents.push(self.record_to_document(\n                row.try_get::\u003cOption\u003cString\u003e, _\u003e(\"id\")?.unwrap_or_default(),\n                row.try_get(\"filepath\")?,\n                row.try_get(\"document_type\")?,\n                row.try_get(\"level\")?,\n                row.try_get(\"status\")?,\n                row.try_get(\"parent_id\")?,\n                row.try_get(\"created_at\")?,\n                row.try_get(\"updated_at\")?,\n                row.try_get(\"content_hash\")?,\n                row.try_get(\"frontmatter_json\")?,\n                row.try_get(\"exit_criteria_met\")?,\n                row.try_get(\"content\")?,\n                row.try_get(\"file_size\")?,\n                row.try_get(\"file_modified_at\")?,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Find documents by phase tag (e.g., \"draft\", \"review\", \"published\")\n    pub async fn find_documents_by_phase(\u0026self, phase: \u0026str) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let phase_tag = format!(\"#phase/{}\", phase);\n        let search_pattern = format!(\"%{}%\", phase_tag);\n        let records = sqlx::query!(\n            r#\"\n            SELECT id, filepath, document_type, level, status, parent_id, \n                   created_at, updated_at, content_hash, frontmatter_json, \n                   exit_criteria_met, content, file_size, file_modified_at\n            FROM documents \n            WHERE frontmatter_json LIKE ?\n            ORDER BY updated_at DESC\n            \"#,\n            search_pattern\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            documents.push(self.record_to_document(\n                row.id.unwrap_or_default(),\n                row.filepath,\n                row.document_type,\n                row.level,\n                row.status,\n                row.parent_id,\n                row.created_at,\n                row.updated_at,\n                row.content_hash,\n                row.frontmatter_json,\n                row.exit_criteria_met,\n                row.content,\n                row.file_size,\n                row.file_modified_at,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Find documents by parent ID\n    pub async fn find_documents_by_parent(\u0026self, parent_id: \u0026str) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let records = sqlx::query!(\n            r#\"\n            SELECT id, filepath, document_type, level, status, parent_id, \n                   created_at, updated_at, content_hash, frontmatter_json, \n                   exit_criteria_met, content, file_size, file_modified_at\n            FROM documents \n            WHERE parent_id = ?\n            ORDER BY updated_at DESC\n            \"#,\n            parent_id\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            documents.push(self.record_to_document(\n                row.id.unwrap_or_default(),\n                row.filepath,\n                row.document_type,\n                row.level,\n                row.status,\n                row.parent_id,\n                row.created_at,\n                row.updated_at,\n                row.content_hash,\n                row.frontmatter_json,\n                row.exit_criteria_met,\n                row.content,\n                row.file_size,\n                row.file_modified_at,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Find orphaned documents (documents with parent_id that doesn't exist)\n    pub async fn find_orphaned_documents(\u0026self) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let records = sqlx::query!(\n            r#\"\n            SELECT d.id, d.filepath, d.document_type, d.level, d.status, d.parent_id, \n                   d.created_at, d.updated_at, d.content_hash, d.frontmatter_json, \n                   d.exit_criteria_met, d.content, d.file_size, d.file_modified_at\n            FROM documents d\n            LEFT JOIN documents p ON d.parent_id = p.id\n            WHERE d.parent_id IS NOT NULL AND p.id IS NULL\n            ORDER BY d.updated_at DESC\n            \"#\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            documents.push(self.record_to_document(\n                row.id.unwrap_or_default(),\n                row.filepath,\n                row.document_type,\n                row.level,\n                row.status,\n                row.parent_id,\n                row.created_at,\n                row.updated_at,\n                row.content_hash,\n                row.frontmatter_json,\n                row.exit_criteria_met,\n                row.content,\n                row.file_size,\n                row.file_modified_at,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Get all property names used in documents\n    pub async fn get_all_property_names(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let records = sqlx::query!(\n            \"SELECT DISTINCT property_name FROM document_properties ORDER BY property_name\"\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        Ok(records.into_iter().map(|row| row.property_name).collect())\n    }\n\n    /// Get all values for a specific property with usage counts\n    pub async fn get_property_values(\u0026self, prop_name: \u0026str) -\u003e Result\u003cVec\u003c(String, usize)\u003e\u003e {\n        let records = sqlx::query!(\n            r#\"\n            SELECT property_value, COUNT(*) as count \n            FROM document_properties \n            WHERE property_name = ? \n            GROUP BY property_value \n            ORDER BY count DESC, property_value\n            \"#,\n            prop_name\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        Ok(records\n            .into_iter()\n            .map(|row| (row.property_value.unwrap_or_default(), row.count as usize))\n            .collect())\n    }\n\n    /// Search documents by property value (equals only for now)\n    pub async fn search_by_property(\u0026self, prop_name: \u0026str, value: \u0026str) -\u003e Result\u003cVec\u003cDocument\u003e\u003e {\n        let records = sqlx::query!(\n            r#\"\n            SELECT DISTINCT d.id, d.filepath, d.document_type, d.level, d.status, d.parent_id, \n                           d.created_at, d.updated_at, d.content_hash, d.frontmatter_json, \n                           d.exit_criteria_met, d.content, d.file_size, d.file_modified_at\n            FROM documents d\n            JOIN document_properties p ON d.id = p.document_id\n            WHERE p.property_name = ? AND p.property_value = ?\n            ORDER BY d.updated_at DESC\n            \"#,\n            prop_name,\n            value\n        )\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut documents = Vec::new();\n        for row in records {\n            documents.push(self.record_to_document(\n                row.id.unwrap_or_default(),\n                row.filepath,\n                row.document_type,\n                row.level,\n                row.status,\n                row.parent_id,\n                row.created_at,\n                row.updated_at,\n                row.content_hash,\n                row.frontmatter_json,\n                row.exit_criteria_met,\n                row.content,\n                row.file_size,\n                row.file_modified_at,\n            )?);\n        }\n        Ok(documents)\n    }\n\n    /// Full-text search using FTS5 with ranking and snippets\n    pub async fn search_content(\u0026self, query: \u0026str, limit: usize) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n        use sqlx::Row;\n\n        let records = sqlx::query(\n            r#\"\n            SELECT d.id, d.filepath, d.document_type, d.level, d.status, d.parent_id, \n                   d.created_at, d.updated_at, d.content_hash, d.frontmatter_json, \n                   d.exit_criteria_met, d.content, d.file_size, d.file_modified_at,\n                   bm25(document_search) as rank,\n                   snippet(document_search, -1, '\u003cmark\u003e', '\u003c/mark\u003e', '...', 64) as snippet\n            FROM document_search\n            JOIN documents d ON document_search.document_id = d.id\n            WHERE document_search MATCH ?\n            ORDER BY rank\n            LIMIT ?\n            \"#,\n        )\n        .bind(query)\n        .bind(limit as i64)\n        .fetch_all(\u0026self.pool)\n        .await?;\n\n        let mut results = Vec::new();\n        for row in records {\n            let document = self.record_to_document(\n                row.try_get::\u003cOption\u003cString\u003e, _\u003e(\"id\")?.unwrap_or_default(),\n                row.try_get(\"filepath\")?,\n                row.try_get(\"document_type\")?,\n                row.try_get(\"level\")?,\n                row.try_get(\"status\")?,\n                row.try_get(\"parent_id\")?,\n                row.try_get(\"created_at\")?,\n                row.try_get(\"updated_at\")?,\n                row.try_get(\"content_hash\")?,\n                row.try_get(\"frontmatter_json\")?,\n                row.try_get(\"exit_criteria_met\")?,\n                row.try_get(\"content\")?,\n                row.try_get(\"file_size\")?,\n                row.try_get(\"file_modified_at\")?,\n            )?;\n\n            let search_result = SearchResult {\n                document,\n                rank: row.try_get::\u003cf64, _\u003e(\"rank\").unwrap_or(0.0),\n                snippet: row.try_get::\u003cString, _\u003e(\"snippet\").unwrap_or_default(),\n            };\n            results.push(search_result);\n        }\n        Ok(results)\n    }\n\n    /// Get relationships for a document\n    pub async fn get_relationships(\n        \u0026self,\n        document_id: \u0026str,\n        direction: RelationshipDirection,\n    ) -\u003e Result\u003cVec\u003cRelationship\u003e\u003e {\n        use sqlx::Row;\n\n        let (sql, bind_params): (String, Vec\u003c\u0026str\u003e) = match direction {\n            RelationshipDirection::Outgoing =\u003e (\n                \"SELECT from_id, to_id, relationship_type, created_at FROM document_relationships WHERE from_id = ? ORDER BY created_at DESC\".to_string(),\n                vec![document_id]\n            ),\n            RelationshipDirection::Incoming =\u003e (\n                \"SELECT from_id, to_id, relationship_type, created_at FROM document_relationships WHERE to_id = ? ORDER BY created_at DESC\".to_string(),\n                vec![document_id]\n            ),\n            RelationshipDirection::Both =\u003e (\n                \"SELECT from_id, to_id, relationship_type, created_at FROM document_relationships WHERE from_id = ? OR to_id = ? ORDER BY created_at DESC\".to_string(),\n                vec![document_id, document_id]\n            ),\n        };\n\n        let mut query = sqlx::query(\u0026sql);\n        for param in bind_params {\n            query = query.bind(param);\n        }\n\n        let records = query.fetch_all(\u0026self.pool).await?;\n\n        let mut relationships = Vec::new();\n        for row in records {\n            let relationship_type_str: String = row.try_get(\"relationship_type\")?;\n            let relationship_type: RelationshipType = match relationship_type_str.as_str() {\n                \"parent\" =\u003e RelationshipType::Parent,\n                \"blocks\" =\u003e RelationshipType::Blocks,\n                \"supersedes\" =\u003e RelationshipType::Supersedes,\n                \"related\" =\u003e RelationshipType::Related,\n                _ =\u003e continue, // Skip unknown relationship types\n            };\n\n            let created_at_timestamp: f64 = row.try_get(\"created_at\")?;\n            let created_at = chrono::DateTime::from_timestamp(created_at_timestamp as i64, 0)\n                .unwrap_or_else(chrono::Utc::now);\n\n            relationships.push(Relationship {\n                from_id: row.try_get(\"from_id\")?,\n                to_id: row.try_get(\"to_id\")?,\n                relationship_type,\n                created_at,\n            });\n        }\n\n        Ok(relationships)\n    }\n\n    /// Helper function to convert record fields to Document\n    #[allow(clippy::too_many_arguments)]\n    fn record_to_document(\n        \u0026self,\n        id: String,\n        filepath: String,\n        document_type_str: String,\n        level_str: String,\n        status: String,\n        parent_id: Option\u003cString\u003e,\n        created_at: f64,\n        updated_at: f64,\n        content_hash: String,\n        frontmatter_json: String,\n        exit_criteria_met: Option\u003cbool\u003e,\n        content: Option\u003cString\u003e,\n        file_size: Option\u003ci64\u003e,\n        file_modified_at: Option\u003cf64\u003e,\n    ) -\u003e Result\u003cDocument\u003e {\n        use chrono::{DateTime, Utc};\n\n        let document_type: DocumentType = document_type_str.parse()?;\n        let level: DocumentType = level_str.parse()?;\n        let frontmatter: serde_json::Value = serde_json::from_str(\u0026frontmatter_json)?;\n        let created_at_dt = DateTime::from_timestamp(created_at as i64, 0).unwrap_or_else(Utc::now);\n        let updated_at_dt = DateTime::from_timestamp(updated_at as i64, 0).unwrap_or_else(Utc::now);\n\n        Ok(Document {\n            id,\n            filepath,\n            document_type,\n            level,\n            status,\n            parent_id,\n            created_at: created_at_dt,\n            updated_at: updated_at_dt,\n            content_hash,\n            frontmatter,\n            exit_criteria_met: exit_criteria_met.unwrap_or(false),\n            content,\n            file_size,\n            file_modified_at,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::database::DocumentStore;\n    use sqlx::SqlitePool;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    async fn create_test_setup() -\u003e (DocumentStore, QueryService) {\n        let pool = SqlitePool::connect(\":memory:\").await.unwrap();\n        let store = DocumentStore::from_pool(pool.clone()).await.unwrap();\n        let query_service = QueryService::new(pool);\n        (store, query_service)\n    }\n\n    fn create_test_document_file(content: \u0026str) -\u003e NamedTempFile {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        temp_file.write_all(content.as_bytes()).unwrap();\n        temp_file.flush().unwrap();\n        temp_file\n    }\n\n    #[tokio::test]\n    async fn test_find_documents_by_type() {\n        let (store, query_service) = create_test_setup().await;\n\n        // Create test documents of different types\n        let vision_content = r##\"---\nid: test-vision\nlevel: vision\nstatus: draft\ntags:\n  - \"#phase/shaping\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Vision\n\"##;\n\n        let strategy_content = r##\"---\nid: test-strategy\nlevel: strategy\nstatus: active\ntags:\n  - \"#phase/design\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Strategy\n\"##;\n\n        let vision_file = create_test_document_file(vision_content);\n        let strategy_file = create_test_document_file(strategy_content);\n\n        store.store_document(vision_file.path()).await.unwrap();\n        store.store_document(strategy_file.path()).await.unwrap();\n\n        // Query for vision documents\n        let visions = query_service\n            .find_documents_by_type(DocumentType::Vision)\n            .await\n            .unwrap();\n        assert_eq!(visions.len(), 1);\n        assert_eq!(visions[0].id, \"test-vision\");\n\n        // Query for strategy documents\n        let strategies = query_service\n            .find_documents_by_type(DocumentType::Strategy)\n            .await\n            .unwrap();\n        assert_eq!(strategies.len(), 1);\n        assert_eq!(strategies[0].id, \"test-strategy\");\n    }\n\n    #[tokio::test]\n    async fn test_find_documents_by_phase() {\n        let (store, query_service) = create_test_setup().await;\n\n        let shaping_content = r##\"---\nid: test-shaping\nlevel: task\nstatus: todo\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\ntags:\n  - \"#phase/shaping\"\n---\n\n# Shaping Task\n\"##;\n\n        let design_content = r##\"---\nid: test-design\nlevel: task\nstatus: active\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\ntags:\n  - \"#phase/design\"\n---\n\n# Design Task\n\"##;\n\n        let shaping_file = create_test_document_file(shaping_content);\n        let design_file = create_test_document_file(design_content);\n\n        store.store_document(shaping_file.path()).await.unwrap();\n        store.store_document(design_file.path()).await.unwrap();\n\n        // Query by phase\n        let shaping_docs = query_service\n            .find_documents_by_phase(\"shaping\")\n            .await\n            .unwrap();\n        assert_eq!(shaping_docs.len(), 1);\n        assert_eq!(shaping_docs[0].id, \"test-shaping\");\n\n        let design_docs = query_service\n            .find_documents_by_phase(\"design\")\n            .await\n            .unwrap();\n        assert_eq!(design_docs.len(), 1);\n        assert_eq!(design_docs[0].id, \"test-design\");\n    }\n\n    #[tokio::test]\n    async fn test_search_by_property() {\n        let (store, query_service) = create_test_setup().await;\n\n        let doc_content = r##\"---\nid: test-properties\nlevel: initiative\nstatus: active\ntags:\n  - \"#phase/design\"\ntechnical_lead: john.doe\npriority: high\nestimated_complexity: l\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Properties\n\"##;\n\n        let doc_file = create_test_document_file(doc_content);\n        store.store_document(doc_file.path()).await.unwrap();\n\n        // Search by exact match\n        let results = query_service\n            .search_by_property(\"technical_lead\", \"john.doe\")\n            .await\n            .unwrap();\n        assert_eq!(results.len(), 1);\n        assert_eq!(results[0].id, \"test-properties\");\n\n        // Search for non-match\n        let results = query_service\n            .search_by_property(\"technical_lead\", \"jane.doe\")\n            .await\n            .unwrap();\n        assert_eq!(results.len(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_property_names_and_values() {\n        let (store, query_service) = create_test_setup().await;\n\n        let doc_content = r##\"---\nid: test-props\nlevel: task\nstatus: todo\ntags:\n  - \"#phase/todo\"\npriority: high\nestimated_hours: 8\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Props\n\"##;\n\n        let doc_file = create_test_document_file(doc_content);\n        store.store_document(doc_file.path()).await.unwrap();\n\n        // Get all property names\n        let prop_names = query_service.get_all_property_names().await.unwrap();\n        assert!(prop_names.contains(\u0026\"priority\".to_string()));\n        assert!(prop_names.contains(\u0026\"estimated_hours\".to_string()));\n\n        // Get values for specific property\n        let priority_values = query_service.get_property_values(\"priority\").await.unwrap();\n        assert_eq!(priority_values.len(), 1);\n        assert_eq!(priority_values[0].0, \"high\");\n        assert_eq!(priority_values[0].1, 1); // count\n    }\n\n    #[tokio::test]\n    async fn test_search_content_fts() {\n        let (store, query_service) = create_test_setup().await;\n\n        let doc1_content = r##\"---\nid: test-search-1\nlevel: vision\nstatus: draft\ntags:\n  - \"#phase/shaping\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Document Management Vision\n\nThis vision outlines our approach to document management using Rust and SQLite.\n\"##;\n\n        let doc2_content = r##\"---\nid: test-search-2\nlevel: strategy\nstatus: active\ntags:\n  - \"#phase/design\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Storage Strategy\n\nOur storage strategy focuses on SQLite performance and indexing capabilities.\n\"##;\n\n        let doc1_file = create_test_document_file(doc1_content);\n        let doc2_file = create_test_document_file(doc2_content);\n\n        store.store_document(doc1_file.path()).await.unwrap();\n        store.store_document(doc2_file.path()).await.unwrap();\n\n        // Search for documents containing \"SQLite\"\n        let results = query_service.search_content(\"SQLite\", 10).await.unwrap();\n        assert_eq!(results.len(), 2);\n\n        // Verify search results have proper structure\n        for result in \u0026results {\n            assert!(!result.document.id.is_empty());\n            // BM25 scores can be negative, so just check it's a valid number\n            assert!(!result.rank.is_nan());\n            assert!(!result.snippet.is_empty());\n        }\n\n        // Search for specific term that should match only one document\n        let mgmt_results = query_service\n            .search_content(\"management\", 10)\n            .await\n            .unwrap();\n        assert_eq!(mgmt_results.len(), 1);\n        assert_eq!(mgmt_results[0].document.id, \"test-search-1\");\n\n        // Search for term that doesn't exist\n        let no_results = query_service\n            .search_content(\"nonexistent\", 10)\n            .await\n            .unwrap();\n        assert_eq!(no_results.len(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_get_relationships() {\n        let (store, query_service) = create_test_setup().await;\n\n        // Create test documents\n        let doc1_content = r##\"---\nid: parent-doc\nlevel: strategy\nstatus: active\ntags:\n  - \"#phase/design\"\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Parent Document\n\"##;\n\n        let doc2_content = r##\"---\nid: child-doc\nlevel: task\nstatus: todo\ntags:\n  - \"#phase/todo\"\nparent: parent-doc\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Child Document\n\"##;\n\n        let doc1_file = create_test_document_file(doc1_content);\n        let doc2_file = create_test_document_file(doc2_content);\n\n        store.store_document(doc1_file.path()).await.unwrap();\n        store.store_document(doc2_file.path()).await.unwrap();\n\n        // Manually insert a relationship for testing\n        sqlx::query(\n            \"INSERT INTO document_relationships (from_id, to_id, relationship_type, created_at) VALUES (?, ?, ?, ?)\"\n        )\n        .bind(\"parent-doc\")\n        .bind(\"child-doc\")\n        .bind(\"blocks\")\n        .bind(chrono::Utc::now().timestamp() as f64)\n        .execute(store.pool())\n        .await\n        .unwrap();\n\n        // Test outgoing relationships\n        let outgoing = query_service\n            .get_relationships(\"parent-doc\", RelationshipDirection::Outgoing)\n            .await\n            .unwrap();\n        assert_eq!(outgoing.len(), 1);\n        assert_eq!(outgoing[0].from_id, \"parent-doc\");\n        assert_eq!(outgoing[0].to_id, \"child-doc\");\n\n        // Test incoming relationships\n        let incoming = query_service\n            .get_relationships(\"child-doc\", RelationshipDirection::Incoming)\n            .await\n            .unwrap();\n        assert_eq!(incoming.len(), 1);\n        assert_eq!(incoming[0].from_id, \"parent-doc\");\n        assert_eq!(incoming[0].to_id, \"child-doc\");\n\n        // Test both directions\n        let both = query_service\n            .get_relationships(\"parent-doc\", RelationshipDirection::Both)\n            .await\n            .unwrap();\n        assert_eq!(both.len(), 1);\n\n        // Test no relationships\n        let none = query_service\n            .get_relationships(\"nonexistent\", RelationshipDirection::Both)\n            .await\n            .unwrap();\n        assert_eq!(none.len(), 0);\n    }\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":26}},{"line":47,"address":[],"length":0,"stats":{"Line":184}},{"line":48,"address":[],"length":0,"stats":{"Line":92}},{"line":52,"address":[],"length":0,"stats":{"Line":92}},{"line":58,"address":[],"length":0,"stats":{"Line":92}},{"line":60,"address":[],"length":0,"stats":{"Line":92}},{"line":70,"address":[],"length":0,"stats":{"Line":92}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":92}},{"line":78,"address":[],"length":0,"stats":{"Line":184}},{"line":79,"address":[],"length":0,"stats":{"Line":92}},{"line":80,"address":[],"length":0,"stats":{"Line":92}},{"line":81,"address":[],"length":0,"stats":{"Line":92}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":149}},{"line":86,"address":[],"length":0,"stats":{"Line":19}},{"line":87,"address":[],"length":0,"stats":{"Line":38}},{"line":88,"address":[],"length":0,"stats":{"Line":19}},{"line":89,"address":[],"length":0,"stats":{"Line":19}},{"line":90,"address":[],"length":0,"stats":{"Line":19}},{"line":91,"address":[],"length":0,"stats":{"Line":19}},{"line":92,"address":[],"length":0,"stats":{"Line":19}},{"line":93,"address":[],"length":0,"stats":{"Line":19}},{"line":94,"address":[],"length":0,"stats":{"Line":19}},{"line":95,"address":[],"length":0,"stats":{"Line":19}},{"line":96,"address":[],"length":0,"stats":{"Line":19}},{"line":97,"address":[],"length":0,"stats":{"Line":19}},{"line":98,"address":[],"length":0,"stats":{"Line":19}},{"line":99,"address":[],"length":0,"stats":{"Line":19}},{"line":100,"address":[],"length":0,"stats":{"Line":19}},{"line":103,"address":[],"length":0,"stats":{"Line":92}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":2}},{"line":138,"address":[],"length":0,"stats":{"Line":2}},{"line":139,"address":[],"length":0,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":9}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":1}},{"line":246,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":256,"address":[],"length":0,"stats":{"Line":4}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":1}},{"line":280,"address":[],"length":0,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":1}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":285,"address":[],"length":0,"stats":{"Line":1}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":287,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":2}},{"line":294,"address":[],"length":0,"stats":{"Line":10}},{"line":311,"address":[],"length":0,"stats":{"Line":5}},{"line":312,"address":[],"length":0,"stats":{"Line":5}},{"line":313,"address":[],"length":0,"stats":{"Line":5}},{"line":314,"address":[],"length":0,"stats":{"Line":5}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":11}},{"line":318,"address":[],"length":0,"stats":{"Line":6}},{"line":319,"address":[],"length":0,"stats":{"Line":6}},{"line":320,"address":[],"length":0,"stats":{"Line":3}},{"line":321,"address":[],"length":0,"stats":{"Line":3}},{"line":322,"address":[],"length":0,"stats":{"Line":3}},{"line":323,"address":[],"length":0,"stats":{"Line":3}},{"line":324,"address":[],"length":0,"stats":{"Line":3}},{"line":325,"address":[],"length":0,"stats":{"Line":3}},{"line":326,"address":[],"length":0,"stats":{"Line":3}},{"line":327,"address":[],"length":0,"stats":{"Line":3}},{"line":328,"address":[],"length":0,"stats":{"Line":3}},{"line":329,"address":[],"length":0,"stats":{"Line":3}},{"line":330,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":3}},{"line":332,"address":[],"length":0,"stats":{"Line":3}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":5}},{"line":346,"address":[],"length":0,"stats":{"Line":4}},{"line":353,"address":[],"length":0,"stats":{"Line":8}},{"line":354,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":1}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":1}},{"line":359,"address":[],"length":0,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":1}},{"line":362,"address":[],"length":0,"stats":{"Line":2}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":4}},{"line":369,"address":[],"length":0,"stats":{"Line":16}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":8}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":10}},{"line":377,"address":[],"length":0,"stats":{"Line":6}},{"line":378,"address":[],"length":0,"stats":{"Line":3}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":6}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":3}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":3}},{"line":393,"address":[],"length":0,"stats":{"Line":3}},{"line":394,"address":[],"length":0,"stats":{"Line":3}},{"line":398,"address":[],"length":0,"stats":{"Line":4}},{"line":402,"address":[],"length":0,"stats":{"Line":25}},{"line":410,"address":[],"length":0,"stats":{"Line":50}},{"line":411,"address":[],"length":0,"stats":{"Line":25}},{"line":412,"address":[],"length":0,"stats":{"Line":25}}],"covered":138,"coverable":203},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","error.rs"],"content":"//! Error types for Metis operations\n\nuse thiserror::Error;\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, MetisError\u003e;\n\n#[derive(Debug, Error)]\npub enum MetisError {\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n\n    #[error(\"Migration error: {0}\")]\n    Migration(#[from] sqlx::migrate::MigrateError),\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"JSON serialization error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"YAML parsing error: {0}\")]\n    Yaml(#[from] serde_yaml::Error),\n\n    #[error(\"Document not found: {id}\")]\n    DocumentNotFound { id: String },\n\n    #[error(\"Invalid document type: {document_type}\")]\n    InvalidDocumentType { document_type: String },\n\n    #[error(\"Invalid phase transition from {from} to {to} for document type {doc_type}\")]\n    InvalidPhaseTransition {\n        from: String,\n        to: String,\n        doc_type: String,\n    },\n\n    #[error(\"Missing required field: {field}\")]\n    MissingRequiredField { field: String },\n\n    #[error(\"Template not found: {template}\")]\n    TemplateNotFound { template: String },\n\n    #[error(\"Validation failed: {message}\")]\n    ValidationFailed { message: String },\n\n    #[error(\"Exit criteria not met: {missing_count} of {total_count} criteria incomplete\")]\n    ExitCriteriaNotMet {\n        missing_count: usize,\n        total_count: usize,\n    },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","exit_criteria.rs"],"content":"//! Exit criteria validation for documents\n\nuse crate::{MetisError, Result};\nuse std::path::Path;\nuse tokio::fs;\n\n/// Result of exit criteria validation containing detailed completion status\n#[derive(Debug, Clone)]\npub struct ExitCriteriaResult {\n    pub met: bool,\n    pub total_criteria: usize,\n    pub completed_criteria: usize,\n    pub missing_criteria: Vec\u003cString\u003e,\n}\n\nimpl ExitCriteriaResult {\n    /// Create a new result with no criteria found\n    pub fn empty() -\u003e Self {\n        Self {\n            met: true, // No criteria means all criteria are met\n            total_criteria: 0,\n            completed_criteria: 0,\n            missing_criteria: Vec::new(),\n        }\n    }\n}\n\n/// Validate exit criteria from a file path\npub async fn validate_exit_criteria(document_path: \u0026Path) -\u003e Result\u003cExitCriteriaResult\u003e {\n    let content = fs::read_to_string(document_path)\n        .await\n        .map_err(MetisError::Io)?;\n    validate_exit_criteria_content(\u0026content)\n}\n\n/// Validate exit criteria from document content\npub fn validate_exit_criteria_content(content: \u0026str) -\u003e Result\u003cExitCriteriaResult\u003e {\n    let criteria = parse_exit_criteria(content);\n\n    if criteria.is_empty() {\n        return Ok(ExitCriteriaResult::empty());\n    }\n\n    let completed_criteria = criteria.iter().filter(|c| c.completed).count();\n    let missing_criteria: Vec\u003cString\u003e = criteria\n        .iter()\n        .filter(|c| !c.completed)\n        .map(|c| c.text.clone())\n        .collect();\n\n    Ok(ExitCriteriaResult {\n        met: missing_criteria.is_empty(),\n        total_criteria: criteria.len(),\n        completed_criteria,\n        missing_criteria,\n    })\n}\n\n/// Individual exit criterion with completion status\n#[derive(Debug, Clone)]\nstruct ExitCriterion {\n    text: String,\n    completed: bool,\n}\n\n/// Parse exit criteria from markdown content\nfn parse_exit_criteria(content: \u0026str) -\u003e Vec\u003cExitCriterion\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let mut criteria = Vec::new();\n    let mut in_exit_criteria = false;\n\n    for line in lines {\n        let trimmed = line.trim();\n\n        // Look for the exit criteria section\n        if trimmed.starts_with(\"## Exit Criteria\") {\n            in_exit_criteria = true;\n            continue;\n        }\n\n        // Stop parsing if we hit another section\n        if in_exit_criteria \u0026\u0026 trimmed.starts_with(\"##\") \u0026\u0026 !trimmed.starts_with(\"## Exit Criteria\")\n        {\n            break;\n        }\n\n        // Parse checkbox items\n        if in_exit_criteria {\n            if let Some(criterion) = parse_checkbox_line(trimmed) {\n                criteria.push(criterion);\n            }\n        }\n    }\n\n    criteria\n}\n\n/// Parse a single line for checkbox format\nfn parse_checkbox_line(line: \u0026str) -\u003e Option\u003cExitCriterion\u003e {\n    let trimmed = line.trim();\n\n    // Check for incomplete checkbox: - [ ]\n    if let Some(text) = trimmed.strip_prefix(\"- [ ]\") {\n        return Some(ExitCriterion {\n            text: text.trim().to_string(),\n            completed: false,\n        });\n    }\n\n    // Check for completed checkbox: - [x] or - [X]\n    if let Some(text) = trimmed.strip_prefix(\"- [x]\") {\n        return Some(ExitCriterion {\n            text: text.trim().to_string(),\n            completed: true,\n        });\n    }\n\n    if let Some(text) = trimmed.strip_prefix(\"- [X]\") {\n        return Some(ExitCriterion {\n            text: text.trim().to_string(),\n            completed: true,\n        });\n    }\n\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn test_parse_checkbox_line() {\n        // Incomplete checkbox\n        let incomplete = parse_checkbox_line(\"- [ ] This is incomplete\");\n        assert!(incomplete.is_some());\n        let criterion = incomplete.unwrap();\n        assert_eq!(criterion.text, \"This is incomplete\");\n        assert!(!criterion.completed);\n\n        // Completed checkbox (lowercase x)\n        let completed = parse_checkbox_line(\"- [x] This is complete\");\n        assert!(completed.is_some());\n        let criterion = completed.unwrap();\n        assert_eq!(criterion.text, \"This is complete\");\n        assert!(criterion.completed);\n\n        // Completed checkbox (uppercase X)\n        let completed_upper = parse_checkbox_line(\"- [X] This is also complete\");\n        assert!(completed_upper.is_some());\n        let criterion = completed_upper.unwrap();\n        assert_eq!(criterion.text, \"This is also complete\");\n        assert!(criterion.completed);\n\n        // Not a checkbox\n        let not_checkbox = parse_checkbox_line(\"- This is just a list item\");\n        assert!(not_checkbox.is_none());\n\n        // Not a checkbox either\n        let also_not = parse_checkbox_line(\"Some regular text\");\n        assert!(also_not.is_none());\n    }\n\n    #[test]\n    fn test_parse_exit_criteria() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\nSome content here.\n\n## Exit Criteria\n\n- [ ] First incomplete criterion\n- [x] Second completed criterion\n- [ ] Third incomplete criterion\n- [X] Fourth completed criterion (uppercase)\n\n## Some Other Section\n\n- [ ] This should not be parsed\n\";\n\n        let criteria = parse_exit_criteria(content);\n        assert_eq!(criteria.len(), 4);\n\n        assert_eq!(criteria[0].text, \"First incomplete criterion\");\n        assert!(!criteria[0].completed);\n\n        assert_eq!(criteria[1].text, \"Second completed criterion\");\n        assert!(criteria[1].completed);\n\n        assert_eq!(criteria[2].text, \"Third incomplete criterion\");\n        assert!(!criteria[2].completed);\n\n        assert_eq!(criteria[3].text, \"Fourth completed criterion (uppercase)\");\n        assert!(criteria[3].completed);\n    }\n\n    #[test]\n    fn test_validate_exit_criteria_content() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\n- [x] Complete criterion\n- [ ] Incomplete criterion 1  \n- [ ] Incomplete criterion 2\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(!result.met);\n        assert_eq!(result.total_criteria, 3);\n        assert_eq!(result.completed_criteria, 1);\n        assert_eq!(result.missing_criteria.len(), 2);\n        assert_eq!(result.missing_criteria[0], \"Incomplete criterion 1\");\n        assert_eq!(result.missing_criteria[1], \"Incomplete criterion 2\");\n    }\n\n    #[test]\n    fn test_validate_all_criteria_complete() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\n- [x] First criterion\n- [x] Second criterion\n- [X] Third criterion\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(result.met);\n        assert_eq!(result.total_criteria, 3);\n        assert_eq!(result.completed_criteria, 3);\n        assert!(result.missing_criteria.is_empty());\n    }\n\n    #[test]\n    fn test_validate_no_exit_criteria() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\nSome content without exit criteria.\n\n## Some Other Section\n\nRegular content here.\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(result.met); // No criteria means all criteria are met\n        assert_eq!(result.total_criteria, 0);\n        assert_eq!(result.completed_criteria, 0);\n        assert!(result.missing_criteria.is_empty());\n    }\n\n    #[test]\n    fn test_validate_empty_exit_criteria_section() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\n## Next Section\n\nSome other content.\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(result.met);\n        assert_eq!(result.total_criteria, 0);\n        assert_eq!(result.completed_criteria, 0);\n        assert!(result.missing_criteria.is_empty());\n    }\n\n    #[test]\n    fn test_mixed_content_in_exit_criteria() {\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\nHere are the criteria:\n\n- [x] Complete this task\n- [ ] Review the implementation\n\nSome explanatory text here.\n\n- [x] Write tests\n- [ ] Update documentation\n\nMore text.\n\";\n\n        let result = validate_exit_criteria_content(content).unwrap();\n        assert!(!result.met);\n        assert_eq!(result.total_criteria, 4);\n        assert_eq!(result.completed_criteria, 2);\n        assert_eq!(result.missing_criteria.len(), 2);\n        assert_eq!(result.missing_criteria[0], \"Review the implementation\");\n        assert_eq!(result.missing_criteria[1], \"Update documentation\");\n    }\n\n    #[tokio::test]\n    async fn test_validate_exit_criteria_from_file() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-doc\nlevel: task\n---\n\n# Test Document\n\n## Exit Criteria\n\n- [x] Criterion 1\n- [ ] Criterion 2\n- [x] Criterion 3\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        let result = validate_exit_criteria(file_path).await.unwrap();\n        assert!(!result.met);\n        assert_eq!(result.total_criteria, 3);\n        assert_eq!(result.completed_criteria, 2);\n        assert_eq!(result.missing_criteria.len(), 1);\n        assert_eq!(result.missing_criteria[0], \"Criterion 2\");\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":2}},{"line":30,"address":[],"length":0,"stats":{"Line":4}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":17}},{"line":45,"address":[],"length":0,"stats":{"Line":13}},{"line":46,"address":[],"length":0,"stats":{"Line":5}},{"line":65,"address":[],"length":0,"stats":{"Line":7}},{"line":66,"address":[],"length":0,"stats":{"Line":7}},{"line":67,"address":[],"length":0,"stats":{"Line":7}},{"line":68,"address":[],"length":0,"stats":{"Line":7}},{"line":70,"address":[],"length":0,"stats":{"Line":195}},{"line":71,"address":[],"length":0,"stats":{"Line":95}},{"line":74,"address":[],"length":0,"stats":{"Line":95}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":124}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":87}},{"line":86,"address":[],"length":0,"stats":{"Line":48}},{"line":92,"address":[],"length":0,"stats":{"Line":7}},{"line":96,"address":[],"length":0,"stats":{"Line":36}},{"line":97,"address":[],"length":0,"stats":{"Line":36}},{"line":100,"address":[],"length":0,"stats":{"Line":44}},{"line":108,"address":[],"length":0,"stats":{"Line":37}},{"line":115,"address":[],"length":0,"stats":{"Line":22}},{"line":122,"address":[],"length":0,"stats":{"Line":16}}],"covered":31,"coverable":32},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","lib.rs"],"content":"//! Metis - A design-first software development documentation system\n//!\n//! Metis implements the Flight Levels methodology for hierarchical documentation\n//! management, providing core functions for creating, validating, and transitioning\n//! documents through their defined phases.\n\npub mod context;\npub mod core;\npub mod database;\npub mod error;\npub mod exit_criteria;\npub mod models;\npub mod phases;\npub mod project;\npub mod render;\npub mod sync;\npub mod template;\npub mod updates;\npub mod validation;\n\n// Re-export main types for convenience\npub use core::{\n    can_transition_to_phase, render, transition_phase, validate, validate_content,\n    validate_exit_criteria, validate_exit_criteria_content, Complexity, DocumentContext,\n    ExitCriteriaResult, RiskLevel, TemplateEngine, ValidationResult,\n};\npub use database::{\n    DocumentStore, QueryService, Relationship, RelationshipDirection, SearchResult,\n};\npub use error::{MetisError, Result};\npub use models::*;\npub use project::{initialize_project, ProjectConfig, ProjectMetadata};\npub use sync::{SyncEngine, SyncError, SyncResult};\npub use updates::{update_blocked_by, update_document_content, update_exit_criterion};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","main.rs"],"content":"// Placeholder main.rs for now\nfn main() {\n    println!(\"Metis - Document management system\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","models","document.rs"],"content":"//! Document model definitions\n\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type, PartialEq, Default)]\n#[sqlx(rename_all = \"lowercase\")]\npub enum DocumentType {\n    #[default]\n    Task,\n    Vision,\n    Strategy,\n    Initiative,\n    Adr,\n}\n\nimpl std::fmt::Display for DocumentType {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            DocumentType::Vision =\u003e write!(f, \"vision\"),\n            DocumentType::Strategy =\u003e write!(f, \"strategy\"),\n            DocumentType::Initiative =\u003e write!(f, \"initiative\"),\n            DocumentType::Task =\u003e write!(f, \"task\"),\n            DocumentType::Adr =\u003e write!(f, \"adr\"),\n        }\n    }\n}\n\nimpl std::str::FromStr for DocumentType {\n    type Err = crate::MetisError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_lowercase().as_str() {\n            \"vision\" =\u003e Ok(DocumentType::Vision),\n            \"strategy\" =\u003e Ok(DocumentType::Strategy),\n            \"initiative\" =\u003e Ok(DocumentType::Initiative),\n            \"task\" =\u003e Ok(DocumentType::Task),\n            \"adr\" =\u003e Ok(DocumentType::Adr),\n            _ =\u003e Err(crate::MetisError::InvalidDocumentType {\n                document_type: s.to_string(),\n            }),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Document {\n    pub id: String,\n    pub filepath: String,\n    pub document_type: DocumentType,\n    pub level: DocumentType, // Same as document_type\n    pub status: String,\n    pub parent_id: Option\u003cString\u003e,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub updated_at: DateTime\u003cUtc\u003e,\n    pub content_hash: String,\n    pub frontmatter: serde_json::Value,\n    pub exit_criteria_met: bool,\n    pub content: Option\u003cString\u003e, // Body without frontmatter\n    pub file_size: Option\u003ci64\u003e,\n    pub file_modified_at: Option\u003cf64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n#[sqlx(rename_all = \"lowercase\")]\npub enum RiskLevel {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n#[sqlx(rename_all = \"lowercase\")]\npub enum Complexity {\n    S,  // Small\n    M,  // Medium\n    L,  // Large\n    XL, // Extra Large\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]\n#[sqlx(rename_all = \"lowercase\")]\npub enum RelationshipType {\n    Parent,\n    Blocks,\n    Supersedes,\n    Related,\n}\n\n#[derive(Debug, Clone)]\npub struct DocumentRelationship {\n    pub from_id: String,\n    pub to_id: String,\n    pub relationship_type: RelationshipType,\n    pub created_at: DateTime\u003cUtc\u003e,\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":170}},{"line":19,"address":[],"length":0,"stats":{"Line":170}},{"line":20,"address":[],"length":0,"stats":{"Line":41}},{"line":21,"address":[],"length":0,"stats":{"Line":39}},{"line":22,"address":[],"length":0,"stats":{"Line":34}},{"line":23,"address":[],"length":0,"stats":{"Line":36}},{"line":24,"address":[],"length":0,"stats":{"Line":20}},{"line":32,"address":[],"length":0,"stats":{"Line":112}},{"line":33,"address":[],"length":0,"stats":{"Line":112}},{"line":34,"address":[],"length":0,"stats":{"Line":159}},{"line":35,"address":[],"length":0,"stats":{"Line":86}},{"line":36,"address":[],"length":0,"stats":{"Line":56}},{"line":37,"address":[],"length":0,"stats":{"Line":61}},{"line":38,"address":[],"length":0,"stats":{"Line":6}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":16},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","models","mod.rs"],"content":"//! Data models for the Metis document management system\n\npub mod document;\n\n// Re-export main types for convenience\npub use document::{Complexity, Document, DocumentType, RelationshipType, RiskLevel};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","phases.rs"],"content":"//! Phase transition management for documents\n\nuse crate::validation::validate_content;\nuse crate::{DocumentType, MetisError, Result};\nuse std::path::Path;\nuse tokio::fs;\n\n/// Transition a document to a new phase with validation and file updates\npub async fn transition_phase(\n    document_path: \u0026Path,\n    new_phase: \u0026str,\n    force: bool,\n) -\u003e Result\u003cString\u003e {\n    // Read current document content\n    let content = fs::read_to_string(document_path)\n        .await\n        .map_err(MetisError::Io)?;\n\n    // Validate current document and extract document type\n    let validation_result = validate_content(\u0026content)?;\n    if !validation_result.is_valid \u0026\u0026 !force {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\n                \"Document validation failed: {:?}\",\n                validation_result.frontmatter_errors\n            ),\n        });\n    }\n\n    let doc_type = validation_result\n        .document_type\n        .ok_or_else(|| MetisError::ValidationFailed {\n            message: \"Cannot determine document type\".to_string(),\n        })?;\n\n    // Extract current phase from content\n    let current_phase = extract_current_phase(\u0026content)?;\n\n    // Check if transition is valid (unless forced)\n    if !force \u0026\u0026 !is_valid_transition(\u0026doc_type, \u0026current_phase, new_phase) {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\n                \"Invalid phase transition from '{}' to '{}' for {} document. Valid transitions: {}\",\n                current_phase,\n                new_phase,\n                format!(\"{:?}\", doc_type).to_lowercase(),\n                get_valid_transitions(\u0026doc_type, \u0026current_phase).join(\", \")\n            ),\n        });\n    }\n\n    // Update document content with new phase\n    let updated_content = update_phase_in_content(\u0026content, \u0026current_phase, new_phase)?;\n\n    // Write updated content back to file\n    fs::write(document_path, \u0026updated_content)\n        .await\n        .map_err(MetisError::Io)?;\n\n    Ok(updated_content)\n}\n\n/// Check if a phase transition is allowed without making changes\npub async fn can_transition_to_phase(document_path: \u0026Path, target_phase: \u0026str) -\u003e Result\u003cbool\u003e {\n    // Read current document content\n    let content = fs::read_to_string(document_path)\n        .await\n        .map_err(MetisError::Io)?;\n\n    // Validate current document and extract document type\n    let validation_result = validate_content(\u0026content)?;\n    if !validation_result.is_valid {\n        return Ok(false);\n    }\n\n    let doc_type = validation_result\n        .document_type\n        .ok_or_else(|| MetisError::ValidationFailed {\n            message: \"Cannot determine document type\".to_string(),\n        })?;\n\n    // Extract current phase from content\n    let current_phase = extract_current_phase(\u0026content)?;\n\n    // Check if transition is valid\n    Ok(is_valid_transition(\u0026doc_type, \u0026current_phase, target_phase))\n}\n\n/// Extract the current active phase from document content\nfn extract_current_phase(content: \u0026str) -\u003e Result\u003cString\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let mut in_frontmatter = false;\n    let mut in_tags = false;\n\n    for line in lines {\n        let trimmed = line.trim();\n\n        if trimmed == \"---\" {\n            if !in_frontmatter {\n                in_frontmatter = true;\n                continue;\n            } else {\n                break; // End of frontmatter\n            }\n        }\n\n        if !in_frontmatter {\n            continue;\n        }\n\n        if trimmed == \"tags:\" {\n            in_tags = true;\n            continue;\n        }\n\n        if in_tags {\n            // Look for active phase tag (not commented out)\n            if trimmed.starts_with(\"- \\\"#phase/\") \u0026\u0026 !trimmed.starts_with(\"# \") {\n                if let Some(phase_start) = trimmed.find(\"#phase/\") {\n                    let phase_part = \u0026trimmed[phase_start + 7..]; // Skip \"#phase/\"\n                    if let Some(end_quote) = phase_part.find('\"') {\n                        return Ok(phase_part[..end_quote].to_string());\n                    }\n                }\n            }\n\n            // If we hit a line that doesn't start with spaces/dashes, we're out of tags\n            if !trimmed.is_empty() \u0026\u0026 !trimmed.starts_with(\"-\") \u0026\u0026 !trimmed.starts_with(\"#\") {\n                break;\n            }\n        }\n    }\n\n    Err(MetisError::ValidationFailed {\n        message: \"No active phase tag found in document\".to_string(),\n    })\n}\n\n/// Update the phase in document content using comment/uncomment logic\nfn update_phase_in_content(content: \u0026str, current_phase: \u0026str, new_phase: \u0026str) -\u003e Result\u003cString\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let mut updated_lines = Vec::new();\n    let mut in_frontmatter = false;\n    let mut in_tags = false;\n\n    for line in lines {\n        let trimmed = line.trim();\n\n        if trimmed == \"---\" {\n            updated_lines.push(line.to_string());\n            if !in_frontmatter {\n                in_frontmatter = true;\n            } else {\n                in_frontmatter = false; // End of frontmatter\n                in_tags = false;\n            }\n            continue;\n        }\n\n        if !in_frontmatter {\n            updated_lines.push(line.to_string());\n            continue;\n        }\n\n        if trimmed == \"tags:\" {\n            updated_lines.push(line.to_string());\n            in_tags = true;\n            continue;\n        }\n\n        if in_tags {\n            // Handle phase tag lines\n            if trimmed.contains(\"#phase/\") {\n                let is_current_phase = trimmed.contains(\u0026format!(\"#phase/{}\", current_phase));\n                let is_target_phase = trimmed.contains(\u0026format!(\"#phase/{}\", new_phase));\n\n                if is_current_phase \u0026\u0026 !trimmed.starts_with(\"#\") {\n                    // Comment out the current phase\n                    let spaces = line.len() - line.trim_start().len();\n                    updated_lines.push(format!(\"{}# {}\", \" \".repeat(spaces), trimmed));\n                } else if is_target_phase \u0026\u0026 trimmed.starts_with(\"#\") {\n                    // Uncomment the target phase\n                    let uncommented = trimmed.strip_prefix(\"# \").unwrap_or(trimmed);\n                    let spaces = line.len() - line.trim_start().len();\n                    updated_lines.push(format!(\"{}{}\", \" \".repeat(spaces), uncommented));\n                } else {\n                    // Keep other phase tags as-is\n                    updated_lines.push(line.to_string());\n                }\n            } else {\n                updated_lines.push(line.to_string());\n                // If we hit a line that doesn't start with spaces/dashes, we're out of tags\n                if !trimmed.is_empty() \u0026\u0026 !trimmed.starts_with(\"-\") \u0026\u0026 !trimmed.starts_with(\"#\") {\n                    in_tags = false;\n                }\n            }\n        } else {\n            updated_lines.push(line.to_string());\n        }\n    }\n\n    Ok(updated_lines.join(\"\\n\"))\n}\n\n/// Check if a phase transition is valid according to business rules\nfn is_valid_transition(doc_type: \u0026DocumentType, current_phase: \u0026str, target_phase: \u0026str) -\u003e bool {\n    let valid_transitions = get_valid_transitions(doc_type, current_phase);\n    valid_transitions.contains(\u0026target_phase.to_string())\n}\n\n/// Get valid next phases for a document type and current phase\nfn get_valid_transitions(doc_type: \u0026DocumentType, current_phase: \u0026str) -\u003e Vec\u003cString\u003e {\n    match doc_type {\n        DocumentType::Vision =\u003e match current_phase {\n            \"draft\" =\u003e vec![\"review\".to_string()],\n            \"review\" =\u003e vec![\"draft\".to_string(), \"published\".to_string()],\n            \"published\" =\u003e vec![\"review\".to_string()], // Can go back for updates\n            _ =\u003e vec![],\n        },\n        DocumentType::Strategy =\u003e match current_phase {\n            \"shaping\" =\u003e vec![\"design\".to_string()],\n            \"design\" =\u003e vec![\"shaping\".to_string(), \"ready\".to_string()],\n            \"ready\" =\u003e vec![\"design\".to_string(), \"active\".to_string()],\n            \"active\" =\u003e vec![\"ready\".to_string(), \"completed\".to_string()],\n            \"completed\" =\u003e vec![\"active\".to_string()], // Can reopen if needed\n            _ =\u003e vec![],\n        },\n        DocumentType::Initiative =\u003e match current_phase {\n            \"discovery\" =\u003e vec![\"design\".to_string()],\n            \"design\" =\u003e vec![\"discovery\".to_string(), \"ready\".to_string()],\n            \"ready\" =\u003e vec![\"design\".to_string(), \"decompose\".to_string()],\n            \"decompose\" =\u003e vec![\"ready\".to_string(), \"active\".to_string()],\n            \"active\" =\u003e vec![\"decompose\".to_string(), \"completed\".to_string()],\n            \"completed\" =\u003e vec![\"active\".to_string()], // Can reopen if needed\n            _ =\u003e vec![],\n        },\n        DocumentType::Task =\u003e match current_phase {\n            \"todo\" =\u003e vec![\"doing\".to_string()],\n            \"doing\" =\u003e vec![\"todo\".to_string(), \"completed\".to_string()],\n            \"completed\" =\u003e vec![\"doing\".to_string()], // Can reopen if needed\n            _ =\u003e vec![],\n        },\n        DocumentType::Adr =\u003e match current_phase {\n            \"draft\" =\u003e vec![\"discussion\".to_string()],\n            \"discussion\" =\u003e vec![\"draft\".to_string(), \"decided\".to_string()],\n            \"decided\" =\u003e vec![\"superseded\".to_string()],\n            \"superseded\" =\u003e vec![], // Terminal state\n            _ =\u003e vec![],\n        },\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn test_extract_current_phase() {\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  # - \\\"#phase/shaping\\\"\n  # - \\\"#phase/design\\\"\n  - \\\"#phase/active\\\"\n  # - \\\"#phase/completed\\\"\n---\n\n# Test Strategy\n\nContent here...\n\";\n\n        let phase = extract_current_phase(content).unwrap();\n        assert_eq!(phase, \"active\");\n    }\n\n    #[test]\n    fn test_extract_current_phase_no_active() {\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ntags:\n  - \\\"#strategy\\\"\n  # - \\\"#phase/shaping\\\"\n  # - \\\"#phase/design\\\"\n  # - \\\"#phase/active\\\"\n---\n\n# Test Strategy\n\";\n\n        let result = extract_current_phase(content);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_update_phase_in_content() {\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ntags:\n  - \\\"#strategy\\\"\n  # - \\\"#phase/shaping\\\"\n  # - \\\"#phase/design\\\"\n  - \\\"#phase/active\\\"\n  # - \\\"#phase/completed\\\"\n---\n\n# Test Strategy\n\nContent here...\n\";\n\n        let updated = update_phase_in_content(content, \"active\", \"completed\").unwrap();\n\n        assert!(updated.contains(\"# - \\\"#phase/active\\\"\"));\n        assert!(updated.contains(\"- \\\"#phase/completed\\\"\"));\n        assert!(!updated.contains(\"# - \\\"#phase/completed\\\"\"));\n    }\n\n    #[test]\n    fn test_valid_strategy_transitions() {\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"shaping\",\n            \"design\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"design\",\n            \"ready\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"ready\",\n            \"active\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"active\",\n            \"completed\"\n        ));\n\n        // Backward transitions\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"design\",\n            \"shaping\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"ready\",\n            \"design\"\n        ));\n\n        // Invalid transitions\n        assert!(!is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"shaping\",\n            \"active\"\n        ));\n        assert!(!is_valid_transition(\n            \u0026DocumentType::Strategy,\n            \"completed\",\n            \"shaping\"\n        ));\n    }\n\n    #[test]\n    fn test_valid_task_transitions() {\n        assert!(is_valid_transition(\u0026DocumentType::Task, \"todo\", \"doing\"));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Task,\n            \"doing\",\n            \"completed\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Task,\n            \"completed\",\n            \"doing\"\n        ));\n\n        // Invalid transitions\n        assert!(!is_valid_transition(\n            \u0026DocumentType::Task,\n            \"todo\",\n            \"completed\"\n        ));\n    }\n\n    #[test]\n    fn test_valid_adr_transitions() {\n        assert!(is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"draft\",\n            \"discussion\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"discussion\",\n            \"decided\"\n        ));\n        assert!(is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"decided\",\n            \"superseded\"\n        ));\n\n        // Backward transition\n        assert!(is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"discussion\",\n            \"draft\"\n        ));\n\n        // Invalid transitions\n        assert!(!is_valid_transition(\u0026DocumentType::Adr, \"draft\", \"decided\"));\n        assert!(!is_valid_transition(\n            \u0026DocumentType::Adr,\n            \"superseded\",\n            \"decided\"\n        ));\n    }\n\n    #[tokio::test]\n    async fn test_transition_phase_file() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  # - \\\"#phase/shaping\\\"\n  # - \\\"#phase/design\\\"\n  - \\\"#phase/active\\\"\n  # - \\\"#phase/completed\\\"\nrisk_level: medium\n---\n\n# Test Strategy\n\nContent here...\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        // Transition from active to completed\n        let result = transition_phase(file_path, \"completed\", false).await;\n        assert!(result.is_ok());\n\n        let updated_content = result.unwrap();\n        assert!(updated_content.contains(\"# - \\\"#phase/active\\\"\"));\n        assert!(updated_content.contains(\"- \\\"#phase/completed\\\"\"));\n\n        // Verify file was actually updated\n        let file_content = fs::read_to_string(file_path).await.unwrap();\n        assert_eq!(file_content, updated_content);\n    }\n\n    #[tokio::test]\n    async fn test_invalid_transition_rejected() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/active\\\"\nrisk_level: medium\n---\n\n# Test Strategy\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        // Try invalid transition from active to shaping\n        let result = transition_phase(file_path, \"shaping\", false).await;\n        assert!(result.is_err());\n\n        // Verify file was not changed\n        let file_content = fs::read_to_string(file_path).await.unwrap();\n        assert_eq!(file_content, content);\n    }\n\n    #[tokio::test]\n    async fn test_force_invalid_transition() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/active\\\"\n  # - \\\"#phase/shaping\\\"\nrisk_level: medium\n---\n\n# Test Strategy\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        // Force invalid transition from active to shaping\n        let result = transition_phase(file_path, \"shaping\", true).await;\n        assert!(result.is_ok());\n\n        let updated_content = result.unwrap();\n        assert!(updated_content.contains(\"# - \\\"#phase/active\\\"\"));\n        assert!(updated_content.contains(\"- \\\"#phase/shaping\\\"\"));\n    }\n\n    #[tokio::test]\n    async fn test_can_transition_to_phase() {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        let content = \"---\nid: test-strategy\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/active\\\"\nrisk_level: medium\n---\n\n# Test Strategy\n\";\n\n        temp_file.write_all(content.as_bytes()).unwrap();\n        let file_path = temp_file.path();\n\n        // Can transition to completed\n        let can_complete = can_transition_to_phase(file_path, \"completed\")\n            .await\n            .unwrap();\n        assert!(can_complete);\n\n        // Cannot transition to shaping\n        let can_shape = can_transition_to_phase(file_path, \"shaping\").await.unwrap();\n        assert!(!can_shape);\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":3}},{"line":15,"address":[],"length":0,"stats":{"Line":12}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":8}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":7}},{"line":85,"address":[],"length":0,"stats":{"Line":7}},{"line":86,"address":[],"length":0,"stats":{"Line":7}},{"line":87,"address":[],"length":0,"stats":{"Line":7}},{"line":89,"address":[],"length":0,"stats":{"Line":136}},{"line":90,"address":[],"length":0,"stats":{"Line":68}},{"line":92,"address":[],"length":0,"stats":{"Line":68}},{"line":93,"address":[],"length":0,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":7}},{"line":95,"address":[],"length":0,"stats":{"Line":7}},{"line":97,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[],"length":0,"stats":{"Line":60}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":60}},{"line":106,"address":[],"length":0,"stats":{"Line":7}},{"line":107,"address":[],"length":0,"stats":{"Line":7}},{"line":110,"address":[],"length":0,"stats":{"Line":53}},{"line":112,"address":[],"length":0,"stats":{"Line":26}},{"line":113,"address":[],"length":0,"stats":{"Line":12}},{"line":115,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":35}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":3}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":97}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":9}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":151,"address":[],"length":0,"stats":{"Line":6}},{"line":154,"address":[],"length":0,"stats":{"Line":41}},{"line":155,"address":[],"length":0,"stats":{"Line":10}},{"line":156,"address":[],"length":0,"stats":{"Line":10}},{"line":159,"address":[],"length":0,"stats":{"Line":31}},{"line":160,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":3}},{"line":162,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":28}},{"line":167,"address":[],"length":0,"stats":{"Line":15}},{"line":168,"address":[],"length":0,"stats":{"Line":10}},{"line":169,"address":[],"length":0,"stats":{"Line":10}},{"line":171,"address":[],"length":0,"stats":{"Line":16}},{"line":173,"address":[],"length":0,"stats":{"Line":3}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":175,"address":[],"length":0,"stats":{"Line":16}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":5}},{"line":187,"address":[],"length":0,"stats":{"Line":14}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":192,"address":[],"length":0,"stats":{"Line":13}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":22}},{"line":201,"address":[],"length":0,"stats":{"Line":22}},{"line":202,"address":[],"length":0,"stats":{"Line":22}},{"line":206,"address":[],"length":0,"stats":{"Line":23}},{"line":207,"address":[],"length":0,"stats":{"Line":23}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":13}},{"line":215,"address":[],"length":0,"stats":{"Line":15}},{"line":216,"address":[],"length":0,"stats":{"Line":13}},{"line":217,"address":[],"length":0,"stats":{"Line":11}},{"line":218,"address":[],"length":0,"stats":{"Line":13}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":6}},{"line":233,"address":[],"length":0,"stats":{"Line":3}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":6}},{"line":238,"address":[],"length":0,"stats":{"Line":8}},{"line":239,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":3}},{"line":241,"address":[],"length":0,"stats":{"Line":2}},{"line":242,"address":[],"length":0,"stats":{"Line":0}}],"covered":99,"coverable":127},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","project.rs"],"content":"//! Project initialization functionality\n\nuse crate::{DocumentContext, DocumentStore, DocumentType, MetisError, Result, TemplateEngine};\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// Configuration for initializing a new Metis project\n#[derive(Debug, Clone)]\npub struct ProjectConfig {\n    pub name: String,\n    pub description: Option\u003cString\u003e,\n    pub root_path: PathBuf,\n}\n\n/// Metadata returned after successful project initialization\n#[derive(Debug, Clone)]\npub struct ProjectMetadata {\n    pub project_path: PathBuf,\n    pub database_path: PathBuf,\n}\n\n/// Initialize a new Metis project (idempotent and non-destructive)\npub async fn initialize_project(config: ProjectConfig) -\u003e Result\u003cProjectMetadata\u003e {\n    let project_path = config.root_path.join(\"metis\");\n    let database_path = project_path.join(\".metis.db\");\n\n    // 1. Validate project name (filesystem safety)\n    if !is_valid_project_name(\u0026config.name) {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\"Invalid project name '{}'. Use only alphanumeric characters, hyphens, and underscores.\", config.name),\n        });\n    }\n\n    // 2. Validate parent directory exists and is writable\n    if !config.root_path.exists() {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\n                \"Parent directory does not exist: {}\",\n                config.root_path.display()\n            ),\n        });\n    }\n\n    if !config.root_path.is_dir() {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\"Path is not a directory: {}\", config.root_path.display()),\n        });\n    }\n\n    // 3. Create metis directory if it doesn't exist\n    if !project_path.exists() {\n        fs::create_dir_all(\u0026project_path).map_err(|e| MetisError::ValidationFailed {\n            message: format!(\"Failed to create metis directory: {}\", e),\n        })?;\n    }\n\n    // 4. Test write permissions by creating and removing a temporary file\n    let temp_file = project_path.join(\".metis_temp_test\");\n    if let Err(e) = fs::write(\u0026temp_file, \"\") {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\"Directory is not writable: {}\", e),\n        });\n    }\n    let _ = fs::remove_file(temp_file); // Ignore errors on cleanup\n\n    // 5. Create directory structure if it doesn't exist\n    create_directory_structure(\u0026project_path)?;\n\n    // 6. Initialize database if it doesn't exist\n    if !database_path.exists() {\n        let database_url = format!(\"sqlite:{}\", database_path.display());\n        let _store = DocumentStore::new(\u0026database_url).await?;\n    }\n\n    // 7. Create initial vision document if it doesn't exist\n    create_initial_vision(\u0026project_path, \u0026config.name, config.description.as_deref())?;\n\n    Ok(ProjectMetadata {\n        project_path,\n        database_path,\n    })\n}\n\n/// Create the standard Metis directory structure (idempotent)\nfn create_directory_structure(project_path: \u0026Path) -\u003e Result\u003c()\u003e {\n    let strategies_dir = project_path.join(\"strategies\");\n    let decisions_dir = project_path.join(\"decisions\");\n\n    // create_dir_all is already idempotent - it won't fail if directories exist\n    fs::create_dir_all(\u0026strategies_dir).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to create strategies directory: {}\", e),\n    })?;\n\n    fs::create_dir_all(\u0026decisions_dir).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to create decisions directory: {}\", e),\n    })?;\n\n    Ok(())\n}\n\n/// Create the initial vision document using the template system (non-destructive)\nfn create_initial_vision(\n    project_path: \u0026Path,\n    project_name: \u0026str,\n    description: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003c()\u003e {\n    let vision_path = project_path.join(\"vision.md\");\n\n    // Only create vision document if it doesn't already exist\n    if vision_path.exists() {\n        return Ok(());\n    }\n\n    let template_engine = TemplateEngine::new()?;\n\n    // Create context for vision document\n    let vision_context = DocumentContext::new(format!(\"{} Vision\", project_name));\n\n    // Render the vision document\n    let vision_content = template_engine.render_document(\u0026DocumentType::Vision, \u0026vision_context)?;\n\n    // Customize content if description is provided\n    let final_content = if let Some(desc) = description {\n        // Replace the placeholder purpose section with the provided description\n        vision_content.replace(\"{Why this vision exists and what it aims to achieve}\", desc)\n    } else {\n        vision_content\n    };\n\n    // Write vision document to project root\n    fs::write(\u0026vision_path, final_content).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to create vision document: {}\", e),\n    })?;\n\n    Ok(())\n}\n\n/// Validate that a project name is safe for filesystem use\nfn is_valid_project_name(name: \u0026str) -\u003e bool {\n    if name.is_empty() || name.len() \u003e 255 {\n        return false;\n    }\n\n    // Only allow alphanumeric characters, hyphens, underscores, and spaces\n    name.chars()\n        .all(|c| c.is_alphanumeric() || c == '-' || c == '_' || c == ' ')\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_is_valid_project_name() {\n        assert!(is_valid_project_name(\"my-project\"));\n        assert!(is_valid_project_name(\"my_project\"));\n        assert!(is_valid_project_name(\"MyProject123\"));\n        assert!(is_valid_project_name(\"My Project\"));\n\n        assert!(!is_valid_project_name(\"\"));\n        assert!(!is_valid_project_name(\"my/project\"));\n        assert!(!is_valid_project_name(\"my\\\\project\"));\n        assert!(!is_valid_project_name(\"my\u003cproject\u003e\"));\n        assert!(!is_valid_project_name(\"my|project\"));\n\n        // Test very long name\n        let long_name = \"a\".repeat(256);\n        assert!(!is_valid_project_name(\u0026long_name));\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_success() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        let config = ProjectConfig {\n            name: \"Test Project\".to_string(),\n            description: Some(\"A test project for validation\".to_string()),\n            root_path: project_path.clone(),\n        };\n\n        let result = initialize_project(config).await;\n        assert!(result.is_ok());\n\n        let metadata = result.unwrap();\n        assert_eq!(metadata.project_path, project_path.join(\"metis\"));\n        assert_eq!(\n            metadata.database_path,\n            project_path.join(\"metis\").join(\".metis.db\")\n        );\n\n        // Verify directory structure was created\n        assert!(project_path.join(\"metis\").join(\"strategies\").exists());\n        assert!(project_path.join(\"metis\").join(\"decisions\").exists());\n\n        // Verify database was created\n        assert!(project_path.join(\"metis\").join(\".metis.db\").exists());\n\n        // Verify vision document was created\n        let vision_path = project_path.join(\"metis\").join(\"vision.md\");\n        assert!(vision_path.exists());\n\n        let vision_content = fs::read_to_string(vision_path).unwrap();\n        assert!(vision_content.contains(\"Test Project Vision\"));\n        assert!(vision_content.contains(\"A test project for validation\"));\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_already_exists() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        // Create existing metis directory and .metis.db file\n        fs::create_dir_all(project_path.join(\"metis\")).unwrap();\n        fs::write(project_path.join(\"metis\").join(\".metis.db\"), \"\").unwrap();\n\n        let config = ProjectConfig {\n            name: \"Test Project\".to_string(),\n            description: None,\n            root_path: project_path.clone(),\n        };\n\n        // Should succeed because initialization is now idempotent\n        let result = initialize_project(config).await;\n        assert!(result.is_ok());\n\n        let metadata = result.unwrap();\n        assert_eq!(metadata.project_path, project_path.join(\"metis\"));\n        assert_eq!(\n            metadata.database_path,\n            project_path.join(\"metis\").join(\".metis.db\")\n        );\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_twice() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        let config = ProjectConfig {\n            name: \"Test Project\".to_string(),\n            description: Some(\"A test project for double initialization\".to_string()),\n            root_path: project_path.clone(),\n        };\n\n        // First initialization should succeed\n        let result1 = initialize_project(config.clone()).await;\n        assert!(result1.is_ok());\n\n        // Verify it was created properly\n        assert!(project_path.join(\"metis\").join(\".metis.db\").exists());\n        assert!(project_path.join(\"metis\").join(\"vision.md\").exists());\n\n        // Second initialization should succeed (idempotent)\n        let result2 = initialize_project(config).await;\n        assert!(result2.is_ok());\n\n        let metadata2 = result2.unwrap();\n        assert_eq!(metadata2.project_path, project_path.join(\"metis\"));\n        assert_eq!(\n            metadata2.database_path,\n            project_path.join(\"metis\").join(\".metis.db\")\n        );\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_invalid_name() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        let config = ProjectConfig {\n            name: \"invalid/name\".to_string(), // Contains slash\n            description: None,\n            root_path: project_path.clone(),\n        };\n\n        let result = initialize_project(config).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Invalid project name\"));\n        } else {\n            panic!(\"Expected ValidationFailed error\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_nonexistent_directory() {\n        let nonexistent_path = PathBuf::from(\"/nonexistent/directory\");\n\n        let config = ProjectConfig {\n            name: \"Test Project\".to_string(),\n            description: None,\n            root_path: nonexistent_path,\n        };\n\n        let result = initialize_project(config).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Parent directory does not exist\"));\n        } else {\n            panic!(\"Expected ValidationFailed error\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_initialize_project_without_description() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path().to_path_buf();\n\n        let config = ProjectConfig {\n            name: \"Simple Project\".to_string(),\n            description: None,\n            root_path: project_path.clone(),\n        };\n\n        let result = initialize_project(config).await;\n        assert!(result.is_ok());\n\n        // Verify vision document was created with default content\n        let vision_path = project_path.join(\"metis\").join(\"vision.md\");\n        assert!(vision_path.exists());\n\n        let vision_content = fs::read_to_string(vision_path).unwrap();\n        assert!(vision_content.contains(\"Simple Project Vision\"));\n        // Should contain the default placeholder text\n        assert!(vision_content.contains(\"{Why this vision exists and what it aims to achieve}\"));\n    }\n\n    #[test]\n    fn test_create_directory_structure() {\n        let temp_dir = TempDir::new().unwrap();\n        let project_path = temp_dir.path();\n\n        let result = create_directory_structure(project_path);\n        assert!(result.is_ok());\n\n        assert!(project_path.join(\"strategies\").exists());\n        assert!(project_path.join(\"decisions\").exists());\n        assert!(project_path.join(\"strategies\").is_dir());\n        assert!(project_path.join(\"decisions\").is_dir());\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":54}},{"line":24,"address":[],"length":0,"stats":{"Line":27}},{"line":25,"address":[],"length":0,"stats":{"Line":27}},{"line":28,"address":[],"length":0,"stats":{"Line":27}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":26}},{"line":36,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":25}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":25}},{"line":49,"address":[],"length":0,"stats":{"Line":21}},{"line":50,"address":[],"length":0,"stats":{"Line":21}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":25}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":25}},{"line":65,"address":[],"length":0,"stats":{"Line":25}},{"line":68,"address":[],"length":0,"stats":{"Line":25}},{"line":69,"address":[],"length":0,"stats":{"Line":21}},{"line":70,"address":[],"length":0,"stats":{"Line":21}},{"line":74,"address":[],"length":0,"stats":{"Line":25}},{"line":76,"address":[],"length":0,"stats":{"Line":25}},{"line":77,"address":[],"length":0,"stats":{"Line":25}},{"line":78,"address":[],"length":0,"stats":{"Line":25}},{"line":83,"address":[],"length":0,"stats":{"Line":26}},{"line":84,"address":[],"length":0,"stats":{"Line":26}},{"line":85,"address":[],"length":0,"stats":{"Line":26}},{"line":88,"address":[],"length":0,"stats":{"Line":26}},{"line":89,"address":[],"length":0,"stats":{"Line":26}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":26}},{"line":94,"address":[],"length":0,"stats":{"Line":26}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":26}},{"line":102,"address":[],"length":0,"stats":{"Line":25}},{"line":103,"address":[],"length":0,"stats":{"Line":25}},{"line":106,"address":[],"length":0,"stats":{"Line":25}},{"line":107,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":22}},{"line":116,"address":[],"length":0,"stats":{"Line":22}},{"line":119,"address":[],"length":0,"stats":{"Line":20}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":22}},{"line":139,"address":[],"length":0,"stats":{"Line":37}},{"line":140,"address":[],"length":0,"stats":{"Line":73}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":490}}],"covered":44,"coverable":54},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","render.rs"],"content":"//! Main render function for creating documents\n\nuse crate::context::DocumentContext;\nuse crate::template::TemplateEngine;\nuse crate::{DocumentType, MetisError, Result};\nuse std::path::{Path, PathBuf};\nuse tokio::fs;\n\n/// Main render function: create document from template and write to filesystem\npub async fn render(\n    document_type: DocumentType,\n    context: DocumentContext,\n    docs_root: \u0026Path,\n) -\u003e Result\u003cPathBuf\u003e {\n    // Create template engine\n    let engine = TemplateEngine::new()?;\n\n    // Validate context for document type\n    context.validate_for_type(\u0026document_type)?;\n\n    // Render document content\n    let content = engine.render_document(\u0026document_type, \u0026context)?;\n\n    // Generate destination path\n    let relative_path = engine.generate_destination_path(\u0026document_type, \u0026context);\n    let full_path = docs_root.join(\u0026relative_path);\n\n    // Create parent directories if they don't exist\n    if let Some(parent) = full_path.parent() {\n        fs::create_dir_all(parent).await.map_err(MetisError::Io)?;\n    }\n\n    // Write file to filesystem\n    fs::write(\u0026full_path, content)\n        .await\n        .map_err(MetisError::Io)?;\n\n    Ok(full_path)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::context::{Complexity, RiskLevel};\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_render_strategy_to_filesystem() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"Test Strategy\".to_string())\n            .with_risk_level(RiskLevel::High)\n            .with_stakeholders(vec![\"Engineering\".to_string(), \"Product\".to_string()]);\n\n        let result = render(DocumentType::Strategy, context, docs_root).await;\n        assert!(result.is_ok());\n\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n        assert!(file_path\n            .to_string_lossy()\n            .contains(\"strategies/test-strategy/strategy.md\"));\n\n        // Verify file contents\n        let content = std::fs::read_to_string(\u0026file_path).unwrap();\n        assert!(content.contains(\"---\\n\")); // Has frontmatter\n        assert!(content.contains(\"# Test Strategy Strategy\")); // Has content\n        assert!(content.contains(\"high\")); // Has risk level\n    }\n\n    #[tokio::test]\n    async fn test_render_initiative_with_parent() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"API Design\".to_string())\n            .with_parent(\"Core Platform Strategy\".to_string())\n            .with_complexity(Complexity::L)\n            .with_technical_lead(\"Alice Smith\".to_string());\n\n        let result = render(DocumentType::Initiative, context, docs_root).await;\n        assert!(result.is_ok());\n\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n        assert!(file_path\n            .to_string_lossy()\n            .contains(\"strategies/core-platform-strategy/initiatives/api-design/initiative.md\"));\n\n        // Verify file contents\n        let content = std::fs::read_to_string(\u0026file_path).unwrap();\n        assert!(content.contains(\"strategy-core-platform-strategy\")); // Has parent ID\n        assert!(content.contains(\"L\")); // Has complexity\n        assert!(content.contains(\"Alice Smith\")); // Has technical lead\n    }\n\n    #[tokio::test]\n    async fn test_render_adr_with_number() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"Use GraphQL\".to_string())\n            .with_decision_maker(\"Architecture Team\".to_string())\n            .with_number(42);\n\n        let result = render(DocumentType::Adr, context, docs_root).await;\n        assert!(result.is_ok());\n\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n        assert!(file_path\n            .to_string_lossy()\n            .contains(\"decisions/adr-042-use-graphql.md\"));\n\n        // Verify file contents\n        let content = std::fs::read_to_string(\u0026file_path).unwrap();\n        assert!(content.contains(\"ADR-42: Use GraphQL\")); // Has title\n        assert!(content.contains(\"Architecture Team\")); // Has decision maker\n    }\n\n    #[tokio::test]\n    async fn test_render_creates_directories() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"Deep Nested Strategy\".to_string())\n            .with_risk_level(RiskLevel::Medium);\n\n        // Ensure the directory doesn't exist initially\n        let expected_dir = docs_root.join(\"strategies/deep-nested-strategy\");\n        assert!(!expected_dir.exists());\n\n        let result = render(DocumentType::Strategy, context, docs_root).await;\n        assert!(result.is_ok());\n\n        // Verify directory was created\n        assert!(expected_dir.exists());\n        assert!(expected_dir.is_dir());\n\n        // Verify file was created\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n    }\n\n    #[tokio::test]\n    async fn test_render_validation_failure() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        // Strategy without required risk_level should fail\n        let context = DocumentContext::new(\"Invalid Strategy\".to_string());\n\n        let result = render(DocumentType::Strategy, context, docs_root).await;\n        assert!(result.is_err());\n\n        // Verify no file was created\n        let expected_path = docs_root.join(\"strategies/invalid-strategy/strategy.md\");\n        assert!(!expected_path.exists());\n    }\n\n    #[tokio::test]\n    async fn test_render_vision_single_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let docs_root = temp_dir.path();\n\n        let context = DocumentContext::new(\"Product Vision\".to_string())\n            .with_stakeholders(vec![\"Product\".to_string(), \"Engineering\".to_string()]);\n\n        let result = render(DocumentType::Vision, context, docs_root).await;\n        assert!(result.is_ok());\n\n        let file_path = result.unwrap();\n        assert!(file_path.exists());\n        assert_eq!(file_path, docs_root.join(\"vision.md\"));\n\n        // Verify file contents\n        let content = std::fs::read_to_string(\u0026file_path).unwrap();\n        assert!(content.contains(\"Product Vision\"));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":12}},{"line":16,"address":[],"length":0,"stats":{"Line":24}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":22}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":11}},{"line":30,"address":[],"length":0,"stats":{"Line":22}},{"line":34,"address":[],"length":0,"stats":{"Line":33}},{"line":36,"address":[],"length":0,"stats":{"Line":11}}],"covered":8,"coverable":10},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","sync.rs"],"content":"//! File synchronization engine for maintaining consistency between filesystem and database\n\nuse crate::{DocumentStore, MetisError, Result};\nuse gray_matter;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::time::SystemTime;\n\n/// Result of a sync operation\n#[derive(Debug, Clone)]\npub struct SyncResult {\n    pub files_processed: usize,\n    pub files_updated: usize,\n    pub files_deleted: usize,\n    pub errors: Vec\u003cSyncError\u003e,\n}\n\n/// Error during sync operation\n#[derive(Debug, Clone)]\npub struct SyncError {\n    pub file_path: PathBuf,\n    pub error: String,\n}\n\n/// File sync engine for vault operations\n#[derive(Clone)]\npub struct SyncEngine {\n    store: DocumentStore,\n}\n\nimpl SyncEngine {\n    /// Create a new sync engine with the given document store\n    pub fn new(store: DocumentStore) -\u003e Self {\n        Self { store }\n    }\n\n    /// Sync all markdown files from the filesystem into the database\n    pub async fn sync_from_filesystem(\u0026self, vault_path: \u0026Path) -\u003e Result\u003cSyncResult\u003e {\n        let mut result = SyncResult {\n            files_processed: 0,\n            files_updated: 0,\n            files_deleted: 0,\n            errors: Vec::new(),\n        };\n\n        // Find all markdown files in the vault\n        let markdown_files = self.find_markdown_files(vault_path)?;\n\n        // Process each file\n        for file_path in \u0026markdown_files {\n            result.files_processed += 1;\n\n            match self.process_file(file_path).await {\n                Ok(was_updated) =\u003e {\n                    if was_updated {\n                        result.files_updated += 1;\n                    }\n                }\n                Err(e) =\u003e {\n                    result.errors.push(SyncError {\n                        file_path: file_path.clone(),\n                        error: e.to_string(),\n                    });\n                }\n            }\n        }\n\n        // Handle orphan cleanup (files deleted from filesystem but still in database)\n        let orphaned = self.find_orphaned_documents(\u0026markdown_files).await?;\n        for orphan_id in orphaned {\n            // Document deletion event\n            println!(\"SYNC EVENT: Document deleted - {}\", orphan_id);\n\n            match self.store.delete_document(\u0026orphan_id).await {\n                Ok(true) =\u003e result.files_deleted += 1,\n                Ok(false) =\u003e {} // Document didn't exist\n                Err(e) =\u003e result.errors.push(SyncError {\n                    file_path: PathBuf::from(format!(\"orphan:{}\", orphan_id)),\n                    error: e.to_string(),\n                }),\n            }\n        }\n\n        Ok(result)\n    }\n\n    /// Process a single markdown file, updating database if needed\n    async fn process_file(\u0026self, file_path: \u0026Path) -\u003e Result\u003cbool\u003e {\n        // Get current file metadata\n        let metadata = fs::metadata(file_path).map_err(MetisError::Io)?;\n\n        let current_size = metadata.len();\n        let current_mtime = metadata.modified().map_err(MetisError::Io)?;\n        let current_mtime_secs = current_mtime\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_secs_f64();\n\n        // Check if document exists in database by filepath\n        let existing_doc = self.get_existing_document_by_path(file_path).await?;\n\n        let file_changed = match \u0026existing_doc {\n            None =\u003e {\n                // New file - always process\n                true\n            }\n            Some(doc) =\u003e {\n                // Compare with stored metadata\n                let stored_size = doc.file_size.unwrap_or(0) as u64;\n                let stored_mtime = doc.file_modified_at.unwrap_or(0.0);\n\n                current_size != stored_size || current_mtime_secs != stored_mtime\n            }\n        };\n\n        if !file_changed {\n            return Ok(false); // No changes detected\n        }\n\n        // File has changed or is new - process it\n        let is_new_document = existing_doc.is_none();\n\n        // Store/update the document (this will update file metadata too)\n        self.store.store_document(file_path).await?;\n\n        // Handle the three basic events\n        if is_new_document {\n            // Document creation event\n            println!(\"SYNC EVENT: Document created - {}\", file_path.display());\n        } else {\n            // Document modification event\n            println!(\"SYNC EVENT: Document changed - {}\", file_path.display());\n        }\n\n        Ok(true)\n    }\n\n    /// Find all markdown files in the vault directory\n    fn find_markdown_files(\u0026self, vault_path: \u0026Path) -\u003e Result\u003cVec\u003cPathBuf\u003e\u003e {\n        let mut markdown_files = Vec::new();\n        self.find_markdown_files_recursive(vault_path, \u0026mut markdown_files)?;\n        Ok(markdown_files)\n    }\n\n    /// Recursively find markdown files\n    #[allow(clippy::only_used_in_recursion)]\n    fn find_markdown_files_recursive(\u0026self, dir: \u0026Path, files: \u0026mut Vec\u003cPathBuf\u003e) -\u003e Result\u003c()\u003e {\n        let entries = fs::read_dir(dir).map_err(MetisError::Io)?;\n\n        for entry in entries {\n            let entry = entry.map_err(MetisError::Io)?;\n            let path = entry.path();\n\n            if path.is_dir() {\n                // Skip hidden directories\n                if let Some(dir_name) = path.file_name() {\n                    if dir_name.to_string_lossy().starts_with('.') {\n                        continue;\n                    }\n                }\n                self.find_markdown_files_recursive(\u0026path, files)?;\n            } else if path.extension().is_some_and(|ext| ext == \"md\") {\n                files.push(path);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get existing document from database by filepath\n    async fn get_existing_document_by_path(\n        \u0026self,\n        file_path: \u0026Path,\n    ) -\u003e Result\u003cOption\u003ccrate::Document\u003e\u003e {\n        // Convert path to string for database query\n        let filepath_str = file_path.to_string_lossy().to_string();\n\n        // Query database by filepath\n        let record = sqlx::query!(\n            \"SELECT id, filepath, document_type, level, status, parent_id, \n                    created_at, updated_at, content_hash, frontmatter_json, \n                    exit_criteria_met, content, file_size, file_modified_at\n             FROM documents WHERE filepath = ?\",\n            filepath_str\n        )\n        .fetch_optional(self.store.pool())\n        .await?;\n\n        if let Some(row) = record {\n            let document_type: crate::DocumentType = row.document_type.parse().unwrap_or_default();\n            let level: crate::DocumentType = row.level.parse().unwrap_or_default();\n            let frontmatter: serde_json::Value =\n                serde_json::from_str(\u0026row.frontmatter_json).unwrap_or_default();\n            let created_at =\n                chrono::DateTime::from_timestamp(row.created_at as i64, 0).unwrap_or_default();\n            let updated_at =\n                chrono::DateTime::from_timestamp(row.updated_at as i64, 0).unwrap_or_default();\n\n            Ok(Some(crate::Document {\n                id: row.id.unwrap_or_default(),\n                filepath: row.filepath,\n                document_type,\n                level,\n                status: row.status,\n                parent_id: row.parent_id,\n                created_at,\n                updated_at,\n                content_hash: row.content_hash,\n                frontmatter,\n                exit_criteria_met: row.exit_criteria_met.unwrap_or(false),\n                content: row.content,\n                file_size: row.file_size,\n                file_modified_at: row.file_modified_at,\n            }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Check if file has changed based on size, mtime, or content hash\n    #[allow(dead_code)]\n    async fn file_has_changed(\n        \u0026self,\n        existing_doc: \u0026crate::Document,\n        file_size: u64,\n        modified_time: SystemTime,\n    ) -\u003e Result\u003cbool\u003e {\n        // First check file size - if different, definitely changed\n        let existing_metadata = fs::metadata(\u0026existing_doc.filepath).map_err(MetisError::Io)?;\n\n        if file_size != existing_metadata.len() {\n            return Ok(true);\n        }\n\n        // Then check modification time - if newer, likely changed\n        let existing_modified = existing_metadata.modified().map_err(MetisError::Io)?;\n\n        if modified_time \u003e existing_modified {\n            return Ok(true);\n        }\n\n        // If size and time are the same, assume no change\n        Ok(false)\n    }\n\n    /// Find documents in database that no longer have corresponding files\n    async fn find_orphaned_documents(\u0026self, existing_files: \u0026[PathBuf]) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        // Get all documents from database\n        let query_service = self.store.query_service();\n\n        // For simplicity, we'll check all document types\n        // In practice, we might want a more efficient \"get all documents\" query\n        let mut all_docs = Vec::new();\n\n        use crate::DocumentType;\n        for doc_type in [\n            DocumentType::Vision,\n            DocumentType::Strategy,\n            DocumentType::Initiative,\n            DocumentType::Task,\n            DocumentType::Adr,\n        ] {\n            let docs = query_service.find_documents_by_type(doc_type).await?;\n            all_docs.extend(docs);\n        }\n\n        let mut orphaned = Vec::new();\n\n        for doc in all_docs {\n            let doc_path = PathBuf::from(\u0026doc.filepath);\n            if !existing_files.contains(\u0026doc_path) \u0026\u0026 !doc_path.exists() {\n                orphaned.push(doc.id);\n            }\n        }\n\n        Ok(orphaned)\n    }\n\n    /// Validate consistency between filesystem and database\n    pub async fn validate_consistency(\u0026self, _vault_path: \u0026Path) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        let issues = Vec::new();\n\n        // TODO: Implement consistency validation\n        // - Check all database documents have corresponding files\n        // - Check all markdown files are in database\n        // - Validate frontmatter schema compliance\n\n        Ok(issues)\n    }\n\n    /// Calculate content hash for a file\n    #[allow(dead_code)]\n    fn calculate_content_hash(\u0026self, content: \u0026str) -\u003e String {\n        use sha2::{Digest, Sha256};\n        let mut hasher = Sha256::new();\n        hasher.update(content.as_bytes());\n        format!(\"{:x}\", hasher.finalize())\n    }\n\n    /// Extract document ID from frontmatter\n    #[allow(dead_code)]\n    fn extract_document_id(\u0026self, content: \u0026str) -\u003e Option\u003cString\u003e {\n        let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(content);\n        if let Some(gray_matter::Pod::Hash(map)) = parsed.data {\n            if let Some(gray_matter::Pod::String(id)) = map.get(\"id\") {\n                return Some(id.clone());\n            }\n        }\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs;\n    use tempfile::TempDir;\n\n    async fn create_test_sync_engine() -\u003e (SyncEngine, TempDir) {\n        use sqlx::SqlitePool;\n        let pool = SqlitePool::connect(\":memory:\").await.unwrap();\n        let store = DocumentStore::from_pool(pool).await.unwrap();\n        let sync_engine = SyncEngine::new(store);\n        let temp_dir = TempDir::new().unwrap();\n        (sync_engine, temp_dir)\n    }\n\n    fn create_test_markdown_file(dir: \u0026Path, filename: \u0026str, content: \u0026str) -\u003e PathBuf {\n        let file_path = dir.join(filename);\n        fs::write(\u0026file_path, content).unwrap();\n        file_path\n    }\n\n    #[tokio::test]\n    async fn test_find_markdown_files() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        // Create test markdown files\n        create_test_markdown_file(temp_dir.path(), \"doc1.md\", \"# Test 1\");\n        create_test_markdown_file(temp_dir.path(), \"doc2.md\", \"# Test 2\");\n        create_test_markdown_file(temp_dir.path(), \"readme.txt\", \"Not markdown\"); // Should be ignored\n\n        // Create subdirectory with more files\n        let subdir = temp_dir.path().join(\"subdir\");\n        fs::create_dir(\u0026subdir).unwrap();\n        create_test_markdown_file(\u0026subdir, \"doc3.md\", \"# Test 3\");\n\n        let files = sync_engine.find_markdown_files(temp_dir.path()).unwrap();\n\n        assert_eq!(files.len(), 3);\n        assert!(files.iter().any(|p| p.file_name().unwrap() == \"doc1.md\"));\n        assert!(files.iter().any(|p| p.file_name().unwrap() == \"doc2.md\"));\n        assert!(files.iter().any(|p| p.file_name().unwrap() == \"doc3.md\"));\n    }\n\n    #[tokio::test]\n    async fn test_sync_from_filesystem() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        // Create test documents with proper frontmatter\n        let doc1_content = r#\"---\nid: test-doc-1\nlevel: vision\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Document 1\n\"#;\n\n        let doc2_content = r#\"---\nid: test-doc-2\nlevel: strategy\nstatus: active\nphase: design\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Document 2\n\"#;\n\n        create_test_markdown_file(temp_dir.path(), \"doc1.md\", doc1_content);\n        create_test_markdown_file(temp_dir.path(), \"doc2.md\", doc2_content);\n\n        let result = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n\n        assert_eq!(result.files_processed, 2);\n        assert_eq!(result.files_updated, 2);\n        assert_eq!(result.files_deleted, 0);\n        assert!(result.errors.is_empty());\n\n        // Verify documents were stored\n        let doc1 = sync_engine.store.get_document(\"test-doc-1\").await.unwrap();\n        assert!(doc1.is_some());\n        assert_eq!(doc1.unwrap().id, \"test-doc-1\");\n\n        let doc2 = sync_engine.store.get_document(\"test-doc-2\").await.unwrap();\n        assert!(doc2.is_some());\n        assert_eq!(doc2.unwrap().id, \"test-doc-2\");\n    }\n\n    #[tokio::test]\n    async fn test_orphan_cleanup() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        // Create initial document\n        let doc_content = r#\"---\nid: test-orphan\nlevel: task\nstatus: todo\nphase: todo\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Orphan Document\n\"#;\n\n        let doc_path = create_test_markdown_file(temp_dir.path(), \"orphan.md\", doc_content);\n\n        // First sync - document should be added\n        let result1 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result1.files_processed, 1);\n        assert_eq!(result1.files_updated, 1);\n        assert_eq!(result1.files_deleted, 0);\n\n        // Verify document exists\n        let doc = sync_engine.store.get_document(\"test-orphan\").await.unwrap();\n        assert!(doc.is_some());\n\n        // Delete the file from filesystem\n        fs::remove_file(\u0026doc_path).unwrap();\n\n        // Second sync - document should be removed from database\n        let result2 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result2.files_processed, 0); // No files to process\n        assert_eq!(result2.files_updated, 0);\n        assert_eq!(result2.files_deleted, 1); // One orphan removed\n\n        // Verify document no longer exists\n        let doc_after = sync_engine.store.get_document(\"test-orphan\").await.unwrap();\n        assert!(doc_after.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_incremental_sync() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        let doc_content = r#\"---\nid: test-incremental\nlevel: vision\nstatus: draft\nphase: shaping\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Incremental Document\n\"#;\n\n        create_test_markdown_file(temp_dir.path(), \"incremental.md\", doc_content);\n\n        // First sync\n        let result1 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result1.files_updated, 1);\n\n        // Second sync with no changes - sync engine should detect no changes\n        let result2 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result2.files_processed, 1);\n        assert_eq!(result2.files_updated, 0); // No changes detected, file not updated\n    }\n\n    #[tokio::test]\n    async fn test_sync_event_detection() {\n        let (sync_engine, temp_dir) = create_test_sync_engine().await;\n\n        let doc_content = r#\"---\nid: test-sync-events\nlevel: task\nstatus: todo\nphase: todo\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Sync Events Document\n\"#;\n\n        let doc_path = create_test_markdown_file(temp_dir.path(), \"events.md\", doc_content);\n\n        // First sync - should detect creation event\n        let result1 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result1.files_updated, 1);\n        assert_eq!(result1.files_deleted, 0);\n\n        // Modify the document content\n        let updated_content = r#\"---\nid: test-sync-events\nlevel: task\nstatus: doing\nphase: doing\ncreated_at: 2025-07-03T10:00:00Z\nupdated_at: 2025-07-03T10:00:00Z\nexit_criteria_met: false\n---\n\n# Test Sync Events Document\n\nThis content has been updated!\n\"#;\n\n        fs::write(\u0026doc_path, updated_content).unwrap();\n\n        // Second sync - should detect modification event\n        let result2 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result2.files_updated, 1);\n        assert_eq!(result2.files_deleted, 0);\n\n        // Delete the file\n        fs::remove_file(\u0026doc_path).unwrap();\n\n        // Third sync - should detect deletion event\n        let result3 = sync_engine\n            .sync_from_filesystem(temp_dir.path())\n            .await\n            .unwrap();\n        assert_eq!(result3.files_processed, 0); // No files to process\n        assert_eq!(result3.files_updated, 0);\n        assert_eq!(result3.files_deleted, 1); // One file deleted\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":11}},{"line":38,"address":[],"length":0,"stats":{"Line":28}},{"line":43,"address":[],"length":0,"stats":{"Line":14}},{"line":47,"address":[],"length":0,"stats":{"Line":28}},{"line":50,"address":[],"length":0,"stats":{"Line":56}},{"line":51,"address":[],"length":0,"stats":{"Line":21}},{"line":53,"address":[],"length":0,"stats":{"Line":21}},{"line":54,"address":[],"length":0,"stats":{"Line":11}},{"line":55,"address":[],"length":0,"stats":{"Line":19}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":59,"address":[],"length":0,"stats":{"Line":10}},{"line":60,"address":[],"length":0,"stats":{"Line":10}},{"line":61,"address":[],"length":0,"stats":{"Line":10}},{"line":62,"address":[],"length":0,"stats":{"Line":10}},{"line":69,"address":[],"length":0,"stats":{"Line":28}},{"line":70,"address":[],"length":0,"stats":{"Line":18}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":14}},{"line":88,"address":[],"length":0,"stats":{"Line":42}},{"line":90,"address":[],"length":0,"stats":{"Line":42}},{"line":91,"address":[],"length":0,"stats":{"Line":42}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":21}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":21}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":17}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":7}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":18}},{"line":124,"address":[],"length":0,"stats":{"Line":28}},{"line":127,"address":[],"length":0,"stats":{"Line":15}},{"line":129,"address":[],"length":0,"stats":{"Line":7}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":15}},{"line":140,"address":[],"length":0,"stats":{"Line":15}},{"line":141,"address":[],"length":0,"stats":{"Line":15}},{"line":142,"address":[],"length":0,"stats":{"Line":15}},{"line":146,"address":[],"length":0,"stats":{"Line":42}},{"line":147,"address":[],"length":0,"stats":{"Line":84}},{"line":148,"address":[],"length":0,"stats":{"Line":84}},{"line":150,"address":[],"length":0,"stats":{"Line":182}},{"line":151,"address":[],"length":0,"stats":{"Line":210}},{"line":156,"address":[],"length":0,"stats":{"Line":54}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":27}},{"line":162,"address":[],"length":0,"stats":{"Line":110}},{"line":163,"address":[],"length":0,"stats":{"Line":24}},{"line":167,"address":[],"length":0,"stats":{"Line":42}},{"line":171,"address":[],"length":0,"stats":{"Line":42}},{"line":173,"address":[],"length":0,"stats":{"Line":21}},{"line":176,"address":[],"length":0,"stats":{"Line":42}},{"line":181,"address":[],"length":0,"stats":{"Line":21}},{"line":183,"address":[],"length":0,"stats":{"Line":21}},{"line":184,"address":[],"length":0,"stats":{"Line":21}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":17}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":28}},{"line":245,"address":[],"length":0,"stats":{"Line":14}},{"line":249,"address":[],"length":0,"stats":{"Line":14}},{"line":252,"address":[],"length":0,"stats":{"Line":84}},{"line":253,"address":[],"length":0,"stats":{"Line":140}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":14}},{"line":259,"address":[],"length":0,"stats":{"Line":44}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}}],"covered":67,"coverable":125},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","template.rs"],"content":"//! Template engine for document rendering\n\nuse crate::context::DocumentContext;\nuse crate::{DocumentType, MetisError, Result};\nuse include_dir::{include_dir, Dir};\nuse std::collections::HashMap;\nuse tera::{Context, Tera};\n\n/// Template engine for rendering documents\nstatic TEMPLATES_DIR: Dir\u003c'_\u003e = include_dir!(\"$CARGO_MANIFEST_DIR/src/templates\");\n\npub struct TemplateEngine {\n    tera: Tera,\n}\n\nimpl TemplateEngine {\n    /// Create a new template engine with all bundled templates\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let mut tera = Tera::new(\"templates/**/*\").unwrap_or_default();\n\n        // Load templates from bundled directory\n        let mut templates = HashMap::new();\n\n        fn load_templates_recursive(\n            dir: \u0026Dir,\n            path_prefix: \u0026str,\n            templates: \u0026mut HashMap\u003cString, String\u003e,\n        ) -\u003e Result\u003c()\u003e {\n            for entry in dir.entries() {\n                match entry {\n                    include_dir::DirEntry::Dir(subdir) =\u003e {\n                        let new_prefix = if path_prefix.is_empty() {\n                            subdir\n                                .path()\n                                .file_name()\n                                .unwrap()\n                                .to_string_lossy()\n                                .to_string()\n                        } else {\n                            format!(\n                                \"{}/{}\",\n                                path_prefix,\n                                subdir.path().file_name().unwrap().to_string_lossy()\n                            )\n                        };\n                        load_templates_recursive(subdir, \u0026new_prefix, templates)?;\n                    }\n                    include_dir::DirEntry::File(file) =\u003e {\n                        let filename = file.path().file_name().unwrap().to_string_lossy();\n                        let template_name = if path_prefix.is_empty() {\n                            filename.to_string()\n                        } else {\n                            format!(\"{}/{}\", path_prefix, filename)\n                        };\n\n                        let content =\n                            file.contents_utf8()\n                                .ok_or_else(|| MetisError::ValidationFailed {\n                                    message: format!(\n                                        \"Template {} is not valid UTF-8\",\n                                        template_name\n                                    ),\n                                })?;\n\n                        templates.insert(template_name, content.to_string());\n                    }\n                }\n            }\n            Ok(())\n        }\n\n        load_templates_recursive(\u0026TEMPLATES_DIR, \"\", \u0026mut templates)?;\n\n        // Add templates to Tera\n        for (name, content) in templates {\n            tera.add_raw_template(\u0026name, \u0026content)\n                .map_err(|e| MetisError::ValidationFailed {\n                    message: format!(\"Failed to parse template {}: {}\", name, e),\n                })?;\n        }\n\n        Ok(Self { tera })\n    }\n\n    /// Render a complete document (frontmatter + content + postmatter)\n    pub fn render_document(\n        \u0026self,\n        doc_type: \u0026DocumentType,\n        context: \u0026DocumentContext,\n    ) -\u003e Result\u003cString\u003e {\n        // Validate context for document type\n        context.validate_for_type(doc_type)?;\n\n        let type_name = match doc_type {\n            DocumentType::Strategy =\u003e \"strategy\",\n            DocumentType::Initiative =\u003e \"initiative\",\n            DocumentType::Task =\u003e \"task\",\n            DocumentType::Vision =\u003e \"vision\",\n            DocumentType::Adr =\u003e \"adr\",\n        };\n\n        // Create Tera context\n        let mut tera_context = Context::new();\n        tera_context.insert(\"title\", \u0026context.title);\n        tera_context.insert(\"slug\", \u0026context.slug);\n        tera_context.insert(\n            \"created_at\",\n            \u0026context.created_at.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string(),\n        );\n        tera_context.insert(\n            \"updated_at\",\n            \u0026context.updated_at.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string(),\n        );\n\n        if let Some(ref parent) = context.parent_title {\n            tera_context.insert(\"parent_title\", parent);\n            // Generate parent ID based on the parent title\n            // For now, we'll infer the parent type from the document type hierarchy\n            let parent_id = match doc_type {\n                DocumentType::Strategy =\u003e \"metis-vision\".to_string(), // Strategies have vision as parent\n                DocumentType::Initiative =\u003e {\n                    format!(\"strategy-{}\", DocumentContext::title_to_slug(parent))\n                }\n                DocumentType::Task =\u003e {\n                    format!(\"initiative-{}\", DocumentContext::title_to_slug(parent))\n                }\n                _ =\u003e DocumentContext::title_to_slug(parent), // Default case\n            };\n            tera_context.insert(\"parent_id\", \u0026parent_id);\n        } else {\n            tera_context.insert(\"parent_title\", \"\");\n            tera_context.insert(\"parent_id\", \"\");\n        }\n\n        tera_context.insert(\"blocked_by\", \u0026context.blocked_by);\n        tera_context.insert(\"stakeholders\", \u0026context.stakeholders);\n\n        // Always provide these fields to templates even if empty\n        tera_context.insert(\n            \"technical_lead\",\n            \u0026context.technical_lead.as_deref().unwrap_or(\"\"),\n        );\n        tera_context.insert(\n            \"decision_maker\",\n            \u0026context.decision_maker.as_deref().unwrap_or(\"\"),\n        );\n        if let Some(decision_date) = context.decision_date {\n            tera_context.insert(\n                \"decision_date\",\n                \u0026decision_date.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string(),\n            );\n        } else {\n            tera_context.insert(\"decision_date\", \"\");\n        }\n        if let Some(number) = context.number {\n            tera_context.insert(\"number\", \u0026number);\n        } else {\n            tera_context.insert(\"number\", \u00260u32);\n        }\n        if let Some(complexity) = context.complexity {\n            tera_context.insert(\"complexity\", \u0026format!(\"{:?}\", complexity));\n        } else {\n            tera_context.insert(\"complexity\", \"\");\n        }\n        if let Some(risk_level) = context.risk_level {\n            tera_context.insert(\"risk_level\", \u0026format!(\"{:?}\", risk_level).to_lowercase());\n        } else {\n            tera_context.insert(\"risk_level\", \"medium\");\n        }\n\n        // Render each part\n        let frontmatter =\n            self.render_template(\u0026format!(\"{}/frontmatter.yaml\", type_name), \u0026tera_context)?;\n        let content = self.render_template(\u0026format!(\"{}/content.md\", type_name), \u0026tera_context)?;\n        let postmatter =\n            self.render_template(\u0026format!(\"{}/postmatter.md\", type_name), \u0026tera_context)?;\n\n        // Combine with proper YAML frontmatter formatting\n        Ok(format!(\n            \"---\\n{}\\n---\\n\\n{}\\n\\n{}\",\n            frontmatter, content, postmatter\n        ))\n    }\n\n    /// Render a specific template with context\n    pub fn render_template(\u0026self, template_name: \u0026str, context: \u0026Context) -\u003e Result\u003cString\u003e {\n        self.tera\n            .render(template_name, context)\n            .map_err(|e| MetisError::ValidationFailed {\n                message: format!(\"Template rendering failed for {}: {}\", template_name, e),\n            })\n    }\n\n    /// Generate destination path for a document based on type and context\n    pub fn generate_destination_path(\n        \u0026self,\n        doc_type: \u0026DocumentType,\n        context: \u0026DocumentContext,\n    ) -\u003e String {\n        match doc_type {\n            DocumentType::Vision =\u003e \"vision.md\".to_string(),\n            DocumentType::Strategy =\u003e {\n                format!(\"strategies/{}/strategy.md\", context.slug)\n            }\n            DocumentType::Initiative =\u003e {\n                if let Some(ref parent) = context.parent_title {\n                    let parent_slug = DocumentContext::title_to_slug(parent);\n                    format!(\n                        \"strategies/{}/initiatives/{}/initiative.md\",\n                        parent_slug, context.slug\n                    )\n                } else {\n                    format!(\"initiatives/{}/initiative.md\", context.slug)\n                }\n            }\n            DocumentType::Task =\u003e {\n                if let Some(ref parent) = context.parent_title {\n                    // For tasks, we need to traverse up to find the strategy\n                    // This is a simplified version - in practice we'd query the database\n                    let parent_slug = DocumentContext::title_to_slug(parent);\n                    format!(\n                        \"strategies/*/initiatives/{}/tasks/{}.md\",\n                        parent_slug, context.slug\n                    )\n                } else {\n                    format!(\"tasks/{}.md\", context.slug)\n                }\n            }\n            DocumentType::Adr =\u003e {\n                if let Some(number) = context.number {\n                    format!(\"decisions/adr-{:03}-{}.md\", number, context.slug)\n                } else {\n                    format!(\"decisions/{}.md\", context.slug)\n                }\n            }\n        }\n    }\n\n    /// List all available templates\n    pub fn list_templates(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.tera\n            .get_template_names()\n            .map(|s| s.to_string())\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::context::{Complexity, RiskLevel};\n\n    #[test]\n    fn test_template_engine_creation() {\n        let engine = TemplateEngine::new();\n        assert!(engine.is_ok());\n\n        let engine = engine.unwrap();\n        let templates = engine.list_templates();\n        eprintln!(\"Available templates: {:?}\", templates);\n        assert!(!templates.is_empty());\n\n        // Check that we have templates for all document types\n        assert!(templates.iter().any(|t| t.contains(\"strategy\")));\n        assert!(templates.iter().any(|t| t.contains(\"initiative\")));\n        assert!(templates.iter().any(|t| t.contains(\"task\")));\n        assert!(templates.iter().any(|t| t.contains(\"vision\")));\n        assert!(templates.iter().any(|t| t.contains(\"adr\")));\n    }\n\n    #[test]\n    fn test_strategy_document_rendering() {\n        let engine = TemplateEngine::new().unwrap();\n        let context = DocumentContext::new(\"Test Strategy\".to_string())\n            .with_risk_level(RiskLevel::High)\n            .with_stakeholders(vec![\"Engineering\".to_string(), \"Product\".to_string()]);\n\n        let result = engine.render_document(\u0026DocumentType::Strategy, \u0026context);\n        if let Err(ref e) = result {\n            eprintln!(\"Render error: {:?}\", e);\n        }\n        assert!(result.is_ok());\n\n        let rendered = result.unwrap();\n        assert!(rendered.contains(\"---\\n\")); // Has frontmatter\n        assert!(rendered.contains(\"# Test Strategy Strategy\")); // Has content\n        assert!(rendered.contains(\"test-strategy\")); // Has slug\n        assert!(rendered.contains(\"high\")); // Has risk level\n    }\n\n    #[test]\n    fn test_initiative_document_rendering() {\n        let engine = TemplateEngine::new().unwrap();\n        let context = DocumentContext::new(\"Test Initiative\".to_string())\n            .with_parent(\"Parent Strategy\".to_string())\n            .with_complexity(Complexity::L)\n            .with_technical_lead(\"Alice Smith\".to_string());\n\n        let result = engine.render_document(\u0026DocumentType::Initiative, \u0026context);\n        assert!(result.is_ok());\n\n        let rendered = result.unwrap();\n        assert!(rendered.contains(\"---\\n\")); // Has frontmatter\n        assert!(rendered.contains(\"# Test Initiative\")); // Has content\n        assert!(rendered.contains(\"strategy-parent-strategy\")); // Has parent ID\n        assert!(rendered.contains(\"L\")); // Has complexity\n        assert!(rendered.contains(\"Alice Smith\")); // Has technical lead\n    }\n\n    #[test]\n    fn test_adr_document_rendering() {\n        let engine = TemplateEngine::new().unwrap();\n        let context = DocumentContext::new(\"Use Database for Storage\".to_string())\n            .with_decision_maker(\"Architecture Team\".to_string())\n            .with_number(5);\n\n        let result = engine.render_document(\u0026DocumentType::Adr, \u0026context);\n        if let Err(ref e) = result {\n            eprintln!(\"ADR render error: {:?}\", e);\n        }\n        assert!(result.is_ok());\n\n        let rendered = result.unwrap();\n        assert!(rendered.contains(\"---\\n\")); // Has frontmatter\n        assert!(rendered.contains(\"Use Database for Storage\")); // Has title\n        assert!(rendered.contains(\"Architecture Team\")); // Has decision maker\n        assert!(rendered.contains(\"5\")); // Has ADR number\n    }\n\n    #[test]\n    fn test_validation_failure_on_missing_required_fields() {\n        let engine = TemplateEngine::new().unwrap();\n\n        // Strategy without risk_level should fail\n        let strategy_context = DocumentContext::new(\"Test Strategy\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Strategy, \u0026strategy_context);\n        assert!(result.is_err());\n\n        // Initiative without complexity should fail\n        let initiative_context = DocumentContext::new(\"Test Initiative\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Initiative, \u0026initiative_context);\n        assert!(result.is_err());\n\n        // ADR without decision_maker should fail\n        let adr_context = DocumentContext::new(\"Test ADR\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Adr, \u0026adr_context);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_destination_path_generation() {\n        let engine = TemplateEngine::new().unwrap();\n\n        // Vision\n        let vision_context = DocumentContext::new(\"Product Vision\".to_string());\n        assert_eq!(\n            engine.generate_destination_path(\u0026DocumentType::Vision, \u0026vision_context),\n            \"vision.md\"\n        );\n\n        // Strategy\n        let strategy_context = DocumentContext::new(\"Core Platform Strategy\".to_string());\n        assert_eq!(\n            engine.generate_destination_path(\u0026DocumentType::Strategy, \u0026strategy_context),\n            \"strategies/core-platform-strategy/strategy.md\"\n        );\n\n        // Initiative with parent\n        let initiative_context = DocumentContext::new(\"API Design\".to_string())\n            .with_parent(\"Core Platform Strategy\".to_string());\n        assert_eq!(\n            engine.generate_destination_path(\u0026DocumentType::Initiative, \u0026initiative_context),\n            \"strategies/core-platform-strategy/initiatives/api-design/initiative.md\"\n        );\n\n        // ADR with number\n        let adr_context = DocumentContext::new(\"Use GraphQL\".to_string()).with_number(42);\n        assert_eq!(\n            engine.generate_destination_path(\u0026DocumentType::Adr, \u0026adr_context),\n            \"decisions/adr-042-use-graphql.md\"\n        );\n    }\n\n    #[test]\n    fn test_vision_and_task_render_without_extra_fields() {\n        let engine = TemplateEngine::new().unwrap();\n\n        // Vision should render without any extra fields\n        let vision_context = DocumentContext::new(\"Product Vision\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Vision, \u0026vision_context);\n        assert!(result.is_ok());\n\n        // Task should render without any extra fields\n        let task_context = DocumentContext::new(\"Implement Feature\".to_string());\n        let result = engine.render_document(\u0026DocumentType::Task, \u0026task_context);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":41}},{"line":19,"address":[],"length":0,"stats":{"Line":41}},{"line":22,"address":[],"length":0,"stats":{"Line":41}},{"line":24,"address":[],"length":0,"stats":{"Line":246}},{"line":25,"address":[],"length":0,"stats":{"Line":1066}},{"line":26,"address":[],"length":0,"stats":{"Line":820}},{"line":27,"address":[],"length":0,"stats":{"Line":205}},{"line":29,"address":[],"length":0,"stats":{"Line":205}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":615}},{"line":36,"address":[],"length":0,"stats":{"Line":615}},{"line":37,"address":[],"length":0,"stats":{"Line":1230}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":615}},{"line":43,"address":[],"length":0,"stats":{"Line":1230}},{"line":44,"address":[],"length":0,"stats":{"Line":615}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":246}},{"line":55,"address":[],"length":0,"stats":{"Line":41}},{"line":58,"address":[],"length":0,"stats":{"Line":1271}},{"line":59,"address":[],"length":0,"stats":{"Line":615}},{"line":60,"address":[],"length":0,"stats":{"Line":615}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":41}},{"line":69,"address":[],"length":0,"stats":{"Line":41}},{"line":71,"address":[],"length":0,"stats":{"Line":44}},{"line":73,"address":[],"length":0,"stats":{"Line":38}},{"line":74,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":24}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":30}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":38}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":36}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":32}},{"line":115,"address":[],"length":0,"stats":{"Line":5}},{"line":118,"address":[],"length":0,"stats":{"Line":33}},{"line":122,"address":[],"length":0,"stats":{"Line":38}},{"line":123,"address":[],"length":0,"stats":{"Line":38}},{"line":124,"address":[],"length":0,"stats":{"Line":38}},{"line":131,"address":[],"length":0,"stats":{"Line":114}},{"line":132,"address":[],"length":0,"stats":{"Line":114}},{"line":133,"address":[],"length":0,"stats":{"Line":114}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":15}},{"line":140,"address":[],"length":0,"stats":{"Line":15}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":12}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":17}}],"covered":51,"coverable":62},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","updates.rs"],"content":"//! Document update operations for surgical content modifications\n\nuse crate::{validate_content, MetisError, Result};\nuse chrono::Utc;\nuse gray_matter;\nuse std::fs;\nuse std::path::Path;\n\n/// Update specific document sections using markdown heading navigation\npub async fn update_document_content(\n    document_path: \u0026Path,\n    section_heading: \u0026str,\n    new_content: \u0026str,\n) -\u003e Result\u003c()\u003e {\n    // Read the document file\n    let raw_content = fs::read_to_string(document_path).map_err(MetisError::Io)?;\n\n    // Parse frontmatter and content\n    let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026raw_content);\n    let frontmatter_yaml = if let Some(data) = parsed.data {\n        // Convert Pod to YAML string for reconstruction\n        match data {\n            gray_matter::Pod::Hash(_) =\u003e {\n                // Extract the original frontmatter YAML from the raw content\n                extract_frontmatter_yaml(\u0026raw_content)?\n            }\n            _ =\u003e String::new(),\n        }\n    } else {\n        String::new()\n    };\n\n    let content = parsed.content;\n\n    // Update the section content\n    let updated_content = update_section_in_content(\u0026content, section_heading, new_content)?;\n\n    // Reconstruct the document\n    let final_document = if frontmatter_yaml.is_empty() {\n        updated_content\n    } else {\n        format!(\"---\\n{}\\n---\\n\\n{}\", frontmatter_yaml, updated_content)\n    };\n\n    // Validate the updated document\n    validate_content(\u0026final_document).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Updated document failed validation: {}\", e),\n    })?;\n\n    // Write the updated document back atomically\n    write_file_atomic(document_path, \u0026final_document)?;\n\n    Ok(())\n}\n\n/// Update exit criteria checkbox completion status\npub async fn update_exit_criterion(\n    document_path: \u0026Path,\n    criterion_text: \u0026str,\n    completed: bool,\n) -\u003e Result\u003c()\u003e {\n    // Read the document file\n    let raw_content = fs::read_to_string(document_path).map_err(MetisError::Io)?;\n\n    // Parse frontmatter and content\n    let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026raw_content);\n    let frontmatter_yaml = if parsed.data.is_some() {\n        extract_frontmatter_yaml(\u0026raw_content)?\n    } else {\n        String::new()\n    };\n\n    let content = parsed.content;\n\n    // Update the checkbox in content\n    let updated_content = update_checkbox_in_content(\u0026content, criterion_text, completed)?;\n\n    // Check if all criteria are now complete\n    let all_complete = check_all_criteria_complete(\u0026updated_content)?;\n\n    // Update frontmatter with new exit_criteria_met status and timestamp\n    let updated_frontmatter = update_frontmatter_exit_criteria(\u0026frontmatter_yaml, all_complete)?;\n\n    // Reconstruct the document\n    let final_document = if updated_frontmatter.is_empty() {\n        updated_content\n    } else {\n        format!(\"---\\n{}\\n---\\n\\n{}\", updated_frontmatter, updated_content)\n    };\n\n    // Validate the updated document\n    validate_content(\u0026final_document).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Updated document failed validation: {}\", e),\n    })?;\n\n    // Write the updated document back atomically\n    write_file_atomic(document_path, \u0026final_document)?;\n\n    Ok(())\n}\n\n/// Update blocked_by relationships in document frontmatter\npub async fn update_blocked_by(document_path: \u0026Path, blocked_by: Vec\u003cString\u003e) -\u003e Result\u003c()\u003e {\n    // Read the document file\n    let raw_content = fs::read_to_string(document_path).map_err(MetisError::Io)?;\n\n    // Parse frontmatter and content\n    let parsed = gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026raw_content);\n    let frontmatter_yaml = if parsed.data.is_some() {\n        extract_frontmatter_yaml(\u0026raw_content)?\n    } else {\n        return Err(MetisError::ValidationFailed {\n            message: \"Document has no frontmatter to update\".to_string(),\n        });\n    };\n\n    let content = parsed.content;\n\n    // Validate blocked_by references\n    validate_blocked_by_references(\u0026blocked_by)?;\n\n    // Update frontmatter with new blocked_by and timestamp\n    let updated_frontmatter = update_frontmatter_blocked_by(\u0026frontmatter_yaml, \u0026blocked_by)?;\n\n    // Reconstruct the document\n    let final_document = format!(\"---\\n{}\\n---\\n\\n{}\", updated_frontmatter, content);\n\n    // Validate the updated document\n    validate_content(\u0026final_document).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Updated document failed validation: {}\", e),\n    })?;\n\n    // Write the updated document back atomically\n    write_file_atomic(document_path, \u0026final_document)?;\n\n    Ok(())\n}\n\n/// Update a section within content text, preserving structure\nfn update_section_in_content(\n    content: \u0026str,\n    section_heading: \u0026str,\n    new_content: \u0026str,\n) -\u003e Result\u003cString\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n    let target_heading = format!(\"## {}\", section_heading);\n\n    // Find the section start\n    let section_start = lines.iter().position(|line| {\n        line.trim() == target_heading\n    }).ok_or_else(|| MetisError::ValidationFailed {\n        message: format!(\"H2 section '## {}' not found in document. Provide heading text only (e.g., 'Problem Statement' for '## Problem Statement')\", section_heading),\n    })?;\n\n    // Find the section end (next ## heading or end of document)\n    let section_end = lines[section_start + 1..]\n        .iter()\n        .position(|line| line.trim_start().starts_with(\"## \"))\n        .map(|pos| section_start + 1 + pos)\n        .unwrap_or(lines.len());\n\n    // Build the updated content\n    let mut updated_lines = Vec::new();\n\n    // Add content before the section\n    updated_lines.extend_from_slice(\u0026lines[..section_start + 1]);\n\n    // Add empty line after heading if new content exists\n    if !new_content.trim().is_empty() {\n        updated_lines.push(\"\");\n\n        // Add the new content\n        for line in new_content.lines() {\n            updated_lines.push(line);\n        }\n    }\n\n    // Add content after the section\n    if section_end \u003c lines.len() {\n        updated_lines.push(\"\"); // Empty line before next section\n        updated_lines.extend_from_slice(\u0026lines[section_end..]);\n    }\n\n    Ok(updated_lines.join(\"\\n\"))\n}\n\n/// Extract original frontmatter YAML from raw content\nfn extract_frontmatter_yaml(raw_content: \u0026str) -\u003e Result\u003cString\u003e {\n    if !raw_content.starts_with(\"---\\n\") {\n        return Ok(String::new());\n    }\n\n    let content_after_first_marker = \u0026raw_content[4..]; // Skip \"---\\n\"\n    if let Some(end_pos) = content_after_first_marker.find(\"\\n---\\n\") {\n        Ok(content_after_first_marker[..end_pos].to_string())\n    } else {\n        Err(MetisError::ValidationFailed {\n            message: \"Invalid frontmatter format - missing closing marker\".to_string(),\n        })\n    }\n}\n\n/// Update checkbox state in content for a specific criterion\nfn update_checkbox_in_content(\n    content: \u0026str,\n    criterion_text: \u0026str,\n    completed: bool,\n) -\u003e Result\u003cString\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n\n    // Find the Exit Criteria section\n    let exit_criteria_start = lines\n        .iter()\n        .position(|line| line.trim() == \"## Exit Criteria\")\n        .ok_or_else(|| MetisError::ValidationFailed {\n            message: \"Exit Criteria section not found in document\".to_string(),\n        })?;\n\n    // Find the end of the Exit Criteria section\n    let exit_criteria_end = lines[exit_criteria_start + 1..]\n        .iter()\n        .position(|line| line.trim_start().starts_with(\"## \"))\n        .map(|pos| exit_criteria_start + 1 + pos)\n        .unwrap_or(lines.len());\n\n    // Find matching criteria within the section\n    let mut matching_lines = Vec::new();\n    for (i, line) in lines[exit_criteria_start + 1..exit_criteria_end]\n        .iter()\n        .enumerate()\n    {\n        if is_checkbox_line(line) \u0026\u0026 line.to_lowercase().contains(\u0026criterion_text.to_lowercase()) {\n            matching_lines.push(exit_criteria_start + 1 + i);\n        }\n    }\n\n    // Check for ambiguous matches\n    if matching_lines.is_empty() {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\"No exit criteria found matching text: '{}'\", criterion_text),\n        });\n    }\n\n    if matching_lines.len() \u003e 1 {\n        return Err(MetisError::ValidationFailed {\n            message: format!(\n                \"Multiple exit criteria match text '{}' - please be more specific\",\n                criterion_text\n            ),\n        });\n    }\n\n    // Update the matching line\n    let target_line_idx = matching_lines[0];\n    let updated_lines: Vec\u003cString\u003e = lines\n        .iter()\n        .enumerate()\n        .map(|(i, line)| {\n            if i == target_line_idx {\n                update_checkbox_state(line, completed)\n            } else {\n                line.to_string()\n            }\n        })\n        .collect();\n\n    Ok(updated_lines.join(\"\\n\"))\n}\n\n/// Check if a line contains a checkbox\nfn is_checkbox_line(line: \u0026str) -\u003e bool {\n    let trimmed = line.trim_start();\n    trimmed.starts_with(\"- [ ]\") || trimmed.starts_with(\"- [x]\") || trimmed.starts_with(\"- [X]\")\n}\n\n/// Update the checkbox state in a single line\nfn update_checkbox_state(line: \u0026str, completed: bool) -\u003e String {\n    let checkbox = if completed { \"[x]\" } else { \"[ ]\" };\n\n    // Replace any checkbox pattern with the desired state\n    if line.trim_start().starts_with(\"- [ ]\") {\n        line.replacen(\"- [ ]\", \u0026format!(\"- {}\", checkbox), 1)\n    } else if line.trim_start().starts_with(\"- [x]\") {\n        line.replacen(\"- [x]\", \u0026format!(\"- {}\", checkbox), 1)\n    } else if line.trim_start().starts_with(\"- [X]\") {\n        line.replacen(\"- [X]\", \u0026format!(\"- {}\", checkbox), 1)\n    } else {\n        line.to_string()\n    }\n}\n\n/// Check if all exit criteria in the content are complete\nfn check_all_criteria_complete(content: \u0026str) -\u003e Result\u003cbool\u003e {\n    let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n\n    // Find the Exit Criteria section\n    let exit_criteria_start = lines\n        .iter()\n        .position(|line| line.trim() == \"## Exit Criteria\");\n\n    if exit_criteria_start.is_none() {\n        // No exit criteria section, consider complete\n        return Ok(true);\n    }\n\n    let start = exit_criteria_start.unwrap();\n    let exit_criteria_end = lines[start + 1..]\n        .iter()\n        .position(|line| line.trim_start().starts_with(\"## \"))\n        .map(|pos| start + 1 + pos)\n        .unwrap_or(lines.len());\n\n    // Check all checkbox lines in the section\n    for line in \u0026lines[start + 1..exit_criteria_end] {\n        if is_checkbox_line(line) \u0026\u0026 line.trim_start().starts_with(\"- [ ]\") {\n            return Ok(false); // Found incomplete criterion\n        }\n    }\n\n    Ok(true) // All criteria are complete\n}\n\n/// Update frontmatter with exit criteria status and timestamp\nfn update_frontmatter_exit_criteria(frontmatter_yaml: \u0026str, all_complete: bool) -\u003e Result\u003cString\u003e {\n    if frontmatter_yaml.is_empty() {\n        return Ok(String::new());\n    }\n\n    // Parse YAML\n    let mut frontmatter: serde_yaml::Value =\n        serde_yaml::from_str(frontmatter_yaml).map_err(|e| MetisError::ValidationFailed {\n            message: format!(\"Failed to parse frontmatter YAML: {}\", e),\n        })?;\n\n    // Update fields\n    if let serde_yaml::Value::Mapping(ref mut map) = frontmatter {\n        // Update exit_criteria_met\n        map.insert(\n            serde_yaml::Value::String(\"exit_criteria_met\".to_string()),\n            serde_yaml::Value::Bool(all_complete),\n        );\n\n        // Update updated_at timestamp\n        let now = Utc::now();\n        map.insert(\n            serde_yaml::Value::String(\"updated_at\".to_string()),\n            serde_yaml::Value::String(now.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string()),\n        );\n    }\n\n    // Serialize back to YAML\n    serde_yaml::to_string(\u0026frontmatter).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to serialize frontmatter YAML: {}\", e),\n    })\n}\n\n/// Validate blocked_by reference format\nfn validate_blocked_by_references(blocked_by: \u0026[String]) -\u003e Result\u003c()\u003e {\n    for reference in blocked_by {\n        if !is_valid_wiki_link_reference(reference) {\n            return Err(MetisError::ValidationFailed {\n                message: format!(\n                    \"Invalid reference format '{}'. Expected format: '[[Document Title]]'\",\n                    reference\n                ),\n            });\n        }\n    }\n    Ok(())\n}\n\n/// Check if a string is a valid wiki-link reference\nfn is_valid_wiki_link_reference(reference: \u0026str) -\u003e bool {\n    if reference.is_empty() {\n        return false;\n    }\n\n    // Must start with [[ and end with ]]\n    if !reference.starts_with(\"[[\") || !reference.ends_with(\"]]\") {\n        return false;\n    }\n\n    // Extract the inner content\n    let inner = \u0026reference[2..reference.len() - 2];\n\n    // Must not be empty and should not contain invalid characters\n    !inner.is_empty() \u0026\u0026 !inner.contains(\"[[\") \u0026\u0026 !inner.contains(\"]]\")\n}\n\n/// Update frontmatter with new blocked_by list and timestamp\nfn update_frontmatter_blocked_by(frontmatter_yaml: \u0026str, blocked_by: \u0026[String]) -\u003e Result\u003cString\u003e {\n    // Parse YAML\n    let mut frontmatter: serde_yaml::Value =\n        serde_yaml::from_str(frontmatter_yaml).map_err(|e| MetisError::ValidationFailed {\n            message: format!(\"Failed to parse frontmatter YAML: {}\", e),\n        })?;\n\n    // Update fields\n    if let serde_yaml::Value::Mapping(ref mut map) = frontmatter {\n        // Update blocked_by field\n        if blocked_by.is_empty() {\n            // Empty blocked_by should be represented as empty array or null\n            map.insert(\n                serde_yaml::Value::String(\"blocked_by\".to_string()),\n                serde_yaml::Value::Sequence(Vec::new()),\n            );\n        } else {\n            let blocked_by_values: Vec\u003cserde_yaml::Value\u003e = blocked_by\n                .iter()\n                .map(|s| serde_yaml::Value::String(s.clone()))\n                .collect();\n            map.insert(\n                serde_yaml::Value::String(\"blocked_by\".to_string()),\n                serde_yaml::Value::Sequence(blocked_by_values),\n            );\n        }\n\n        // Update updated_at timestamp\n        let now = Utc::now();\n        map.insert(\n            serde_yaml::Value::String(\"updated_at\".to_string()),\n            serde_yaml::Value::String(now.format(\"%Y-%m-%dT%H:%M:%SZ\").to_string()),\n        );\n    }\n\n    // Serialize back to YAML\n    serde_yaml::to_string(\u0026frontmatter).map_err(|e| MetisError::ValidationFailed {\n        message: format!(\"Failed to serialize frontmatter YAML: {}\", e),\n    })\n}\n\n/// Write file atomically using a temporary file\nfn write_file_atomic(path: \u0026Path, content: \u0026str) -\u003e Result\u003c()\u003e {\n    let temp_path = path.with_extension(\"tmp\");\n\n    // Write to temporary file first\n    fs::write(\u0026temp_path, content).map_err(MetisError::Io)?;\n\n    // Atomic rename\n    fs::rename(\u0026temp_path, path).map_err(MetisError::Io)?;\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    fn create_test_document(content: \u0026str) -\u003e NamedTempFile {\n        let mut temp_file = NamedTempFile::new().unwrap();\n        temp_file.write_all(content.as_bytes()).unwrap();\n        temp_file.flush().unwrap();\n        temp_file\n    }\n\n    #[test]\n    fn test_update_section_in_content_basic() {\n        let content = r#\"# Document Title\n\n## Introduction\n\nThis is the introduction.\n\n## Implementation\n\nOld implementation details.\n\n## Conclusion\n\nThis is the conclusion.\"#;\n\n        let result = update_section_in_content(\n            content,\n            \"Implementation\",\n            \"New implementation details.\\n\\nWith multiple paragraphs.\",\n        );\n\n        assert!(result.is_ok());\n        let updated = result.unwrap();\n\n        assert!(updated.contains(\"New implementation details.\"));\n        assert!(updated.contains(\"With multiple paragraphs.\"));\n        assert!(updated.contains(\"This is the introduction.\"));\n        assert!(updated.contains(\"This is the conclusion.\"));\n        assert!(!updated.contains(\"Old implementation details.\"));\n    }\n\n    #[test]\n    fn test_update_section_in_content_last_section() {\n        let content = r#\"# Document Title\n\n## Introduction\n\nThis is the introduction.\n\n## Conclusion\n\nOld conclusion.\"#;\n\n        let result =\n            update_section_in_content(content, \"Conclusion\", \"New conclusion with more details.\");\n\n        assert!(result.is_ok());\n        let updated = result.unwrap();\n\n        assert!(updated.contains(\"New conclusion with more details.\"));\n        assert!(updated.contains(\"This is the introduction.\"));\n        assert!(!updated.contains(\"Old conclusion.\"));\n    }\n\n    #[test]\n    fn test_update_section_in_content_empty_content() {\n        let content = r#\"# Document Title\n\n## Introduction\n\nThis is the introduction.\n\n## Implementation\n\nOld implementation details.\n\n## Conclusion\n\nThis is the conclusion.\"#;\n\n        let result = update_section_in_content(content, \"Implementation\", \"\");\n\n        assert!(result.is_ok());\n        let updated = result.unwrap();\n\n        assert!(!updated.contains(\"Old implementation details.\"));\n        assert!(updated.contains(\"This is the introduction.\"));\n        assert!(updated.contains(\"This is the conclusion.\"));\n\n        // Section heading should still be present\n        assert!(updated.contains(\"## Implementation\"));\n    }\n\n    #[test]\n    fn test_update_section_in_content_missing_section() {\n        let content = r#\"# Document Title\n\n## Introduction\n\nThis is the introduction.\"#;\n\n        let result = update_section_in_content(content, \"NonExistent\", \"New content\");\n\n        assert!(result.is_err());\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"H2 section '## NonExistent' not found\"));\n        } else {\n            panic!(\"Expected ValidationFailed error\");\n        }\n    }\n\n    #[test]\n    fn test_extract_frontmatter_yaml() {\n        let content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\ntags:\n  - \"#strategy\"\n  - \"#active\"\n---\n\n# Test Document\n\nContent here.\"##;\n\n        let result = extract_frontmatter_yaml(content);\n        assert!(result.is_ok());\n\n        let yaml = result.unwrap();\n        assert!(yaml.contains(\"id: test-document\"));\n        assert!(yaml.contains(\"level: strategy\"));\n        assert!(yaml.contains(\"status: active\"));\n        assert!(!yaml.contains(\"# Test Document\"));\n    }\n\n    #[test]\n    fn test_extract_frontmatter_yaml_no_frontmatter() {\n        let content = r#\"# Test Document\n\nJust content, no frontmatter.\"#;\n\n        let result = extract_frontmatter_yaml(content);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"\");\n    }\n\n    #[test]\n    fn test_extract_frontmatter_yaml_invalid() {\n        let content = r#\"---\nid: test-document\nlevel: strategy\n# Missing closing marker\"#;\n\n        let result = extract_frontmatter_yaml(content);\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_update_document_content_full() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the old problem statement.\n\n## Solution Approach\n\nThis section needs updating.\n\n## Exit Criteria\n\n- [ ] Criterion 1\n- [ ] Criterion 2\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let result = update_document_content(\n            temp_file.path(),\n            \"Solution Approach\",\n            \"This is the updated solution approach.\\n\\nWith more detailed implementation notes.\",\n        )\n        .await;\n\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify updates\n        assert!(updated_content.contains(\"This is the updated solution approach.\"));\n        assert!(updated_content.contains(\"With more detailed implementation notes.\"));\n        assert!(!updated_content.contains(\"This section needs updating.\"));\n\n        // Verify other sections preserved\n        assert!(updated_content.contains(\"This is the old problem statement.\"));\n        assert!(updated_content.contains(\"- [ ] Criterion 1\"));\n\n        // Verify frontmatter preserved\n        assert!(updated_content.contains(\"id: test-document\"));\n        assert!(updated_content.contains(\"level: strategy\"));\n    }\n\n    #[tokio::test]\n    async fn test_update_document_content_nonexistent_file() {\n        let result =\n            update_document_content(Path::new(\"/nonexistent/file.md\"), \"Section\", \"Content\").await;\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_is_checkbox_line() {\n        assert!(is_checkbox_line(\"- [ ] Incomplete task\"));\n        assert!(is_checkbox_line(\"- [x] Complete task\"));\n        assert!(is_checkbox_line(\"- [X] Complete task\"));\n        assert!(is_checkbox_line(\"  - [ ] Indented task\"));\n\n        assert!(!is_checkbox_line(\"- Regular list item\"));\n        assert!(!is_checkbox_line(\"Not a list\"));\n        assert!(!is_checkbox_line(\"- [invalid] Bad checkbox\"));\n    }\n\n    #[test]\n    fn test_update_checkbox_state() {\n        assert_eq!(\n            update_checkbox_state(\"- [ ] Complete this task\", true),\n            \"- [x] Complete this task\"\n        );\n        assert_eq!(\n            update_checkbox_state(\"- [x] Complete this task\", false),\n            \"- [ ] Complete this task\"\n        );\n        assert_eq!(\n            update_checkbox_state(\"- [X] Complete this task\", false),\n            \"- [ ] Complete this task\"\n        );\n        assert_eq!(\n            update_checkbox_state(\"  - [ ] Indented task\", true),\n            \"  - [x] Indented task\"\n        );\n    }\n\n    #[test]\n    fn test_check_all_criteria_complete() {\n        let content_all_complete = r#\"# Document\n\n## Exit Criteria\n\n- [x] First criterion\n- [x] Second criterion\n- [x] Third criterion\"#;\n\n        let content_incomplete = r#\"# Document\n\n## Exit Criteria\n\n- [x] First criterion\n- [ ] Second criterion\n- [x] Third criterion\"#;\n\n        let content_no_exit_criteria = r#\"# Document\n\n## Other Section\n\nSome content.\"#;\n\n        assert!(check_all_criteria_complete(content_all_complete).unwrap());\n        assert!(!check_all_criteria_complete(content_incomplete).unwrap());\n        assert!(check_all_criteria_complete(content_no_exit_criteria).unwrap());\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content() {\n        let content = r#\"# Document\n\n## Exit Criteria\n\n- [ ] First criterion to complete\n- [x] Second criterion already done\n- [ ] Third criterion pending\"#;\n\n        let result = update_checkbox_in_content(content, \"First criterion\", true);\n        assert!(result.is_ok());\n\n        let updated = result.unwrap();\n        assert!(updated.contains(\"- [x] First criterion to complete\"));\n        assert!(updated.contains(\"- [x] Second criterion already done\"));\n        assert!(updated.contains(\"- [ ] Third criterion pending\"));\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content_partial_match() {\n        let content = r#\"# Document\n\n## Exit Criteria\n\n- [ ] Complete the implementation\n- [ ] Complete the testing\n- [ ] Complete the documentation\"#;\n\n        let result = update_checkbox_in_content(content, \"implementation\", true);\n        assert!(result.is_ok());\n\n        let updated = result.unwrap();\n        assert!(updated.contains(\"- [x] Complete the implementation\"));\n        assert!(updated.contains(\"- [ ] Complete the testing\"));\n        assert!(updated.contains(\"- [ ] Complete the documentation\"));\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content_ambiguous_match() {\n        let content = r#\"# Document\n\n## Exit Criteria\n\n- [ ] Complete the implementation phase\n- [ ] Complete the implementation testing\n- [ ] Complete the documentation\"#;\n\n        let result = update_checkbox_in_content(content, \"implementation\", true);\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Multiple exit criteria match\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for ambiguous match\");\n        }\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content_no_match() {\n        let content = r#\"# Document\n\n## Exit Criteria\n\n- [ ] First criterion\n- [ ] Second criterion\"#;\n\n        let result = update_checkbox_in_content(content, \"nonexistent\", true);\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"No exit criteria found matching\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for no match\");\n        }\n    }\n\n    #[test]\n    fn test_update_checkbox_in_content_no_exit_criteria() {\n        let content = r#\"# Document\n\n## Some Other Section\n\nNo exit criteria here.\"#;\n\n        let result = update_checkbox_in_content(content, \"anything\", true);\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Exit Criteria section not found\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for missing section\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_update_exit_criterion_full() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nexit_criteria_met: false\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the problem statement.\n\n## Exit Criteria\n\n- [ ] Define the solution approach\n- [ ] Complete implementation \n- [x] Write documentation\n\n## Conclusion\n\nFinal thoughts.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let result = update_exit_criterion(temp_file.path(), \"solution approach\", true).await;\n\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify checkbox was updated\n        assert!(updated_content.contains(\"- [x] Define the solution approach\"));\n        assert!(updated_content.contains(\"- [ ] Complete implementation\"));\n        assert!(updated_content.contains(\"- [x] Write documentation\"));\n\n        // Verify other content preserved\n        assert!(updated_content.contains(\"This is the problem statement\"));\n        assert!(updated_content.contains(\"Final thoughts\"));\n\n        // Verify frontmatter updated (exit_criteria_met should still be false since not all complete)\n        assert!(updated_content.contains(\"exit_criteria_met: false\"));\n        assert!(updated_content.contains(\"id: test-document\"));\n\n        // Verify updated_at was changed (should be current date)\n        let current_date = chrono::Utc::now().format(\"%Y-%m-%d\").to_string();\n        assert!(updated_content.contains(\u0026format!(\"updated_at: {}T\", current_date)));\n    }\n\n    #[tokio::test]\n    async fn test_update_exit_criterion_all_complete() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nexit_criteria_met: false\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Exit Criteria\n\n- [x] First criterion\n- [ ] Second criterion\n- [x] Third criterion\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        // Complete the last remaining criterion\n        let result = update_exit_criterion(temp_file.path(), \"Second criterion\", true).await;\n\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify all checkboxes are complete\n        assert!(updated_content.contains(\"- [x] First criterion\"));\n        assert!(updated_content.contains(\"- [x] Second criterion\"));\n        assert!(updated_content.contains(\"- [x] Third criterion\"));\n\n        // Verify exit_criteria_met is now true\n        assert!(updated_content.contains(\"exit_criteria_met: true\"));\n    }\n\n    #[test]\n    fn test_is_valid_wiki_link_reference() {\n        // Valid references\n        assert!(is_valid_wiki_link_reference(\"[[Document Title]]\"));\n        assert!(is_valid_wiki_link_reference(\n            \"[[Complex Document Title with Spaces]]\"\n        ));\n        assert!(is_valid_wiki_link_reference(\"[[Document-With-Hyphens]]\"));\n        assert!(is_valid_wiki_link_reference(\n            \"[[Document_With_Underscores]]\"\n        ));\n\n        // Invalid references\n        assert!(!is_valid_wiki_link_reference(\"\"));\n        assert!(!is_valid_wiki_link_reference(\"Document Title\"));\n        assert!(!is_valid_wiki_link_reference(\"[Document Title]\"));\n        assert!(!is_valid_wiki_link_reference(\"[[]]\"));\n        assert!(!is_valid_wiki_link_reference(\n            \"[[Document [[Nested]] Title]]\"\n        ));\n        assert!(!is_valid_wiki_link_reference(\"Document Title]]\"));\n        assert!(!is_valid_wiki_link_reference(\"[[Document Title\"));\n    }\n\n    #[test]\n    fn test_validate_blocked_by_references() {\n        // Valid references\n        let valid_refs = vec![\n            \"[[Document One]]\".to_string(),\n            \"[[Document Two]]\".to_string(),\n            \"[[Another Document]]\".to_string(),\n        ];\n        assert!(validate_blocked_by_references(\u0026valid_refs).is_ok());\n\n        // Empty list should be valid\n        let empty_refs: Vec\u003cString\u003e = vec![];\n        assert!(validate_blocked_by_references(\u0026empty_refs).is_ok());\n\n        // Invalid references\n        let invalid_refs = vec![\n            \"[[Valid Document]]\".to_string(),\n            \"Invalid Document\".to_string(), // Missing brackets\n        ];\n        assert!(validate_blocked_by_references(\u0026invalid_refs).is_err());\n\n        let nested_refs = vec![\"[[Document [[Nested]] Title]]\".to_string()];\n        assert!(validate_blocked_by_references(\u0026nested_refs).is_err());\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_basic() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nblocked_by: []\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the problem statement.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let new_blocked_by = vec![\n            \"[[Dependency One]]\".to_string(),\n            \"[[Dependency Two]]\".to_string(),\n        ];\n\n        let result = update_blocked_by(temp_file.path(), new_blocked_by).await;\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify blocked_by was updated\n        assert!(updated_content.contains(\"[[Dependency One]]\"));\n        assert!(updated_content.contains(\"[[Dependency Two]]\"));\n\n        // Verify other content preserved\n        assert!(updated_content.contains(\"This is the problem statement\"));\n        assert!(updated_content.contains(\"id: test-document\"));\n        assert!(updated_content.contains(\"level: strategy\"));\n\n        // Verify updated_at was changed (should be current date)\n        let current_date = chrono::Utc::now().format(\"%Y-%m-%d\").to_string();\n        assert!(updated_content.contains(\u0026format!(\"updated_at: {}T\", current_date)));\n\n        // Verify frontmatter can be parsed again\n        let parsed_again =\n            gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026updated_content);\n        assert!(parsed_again.data.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_clear_blockers() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nblocked_by:\n  - \"[[Old Dependency One]]\"\n  - \"[[Old Dependency Two]]\"\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the problem statement.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        // Clear all blockers\n        let empty_blocked_by: Vec\u003cString\u003e = vec![];\n\n        let result = update_blocked_by(temp_file.path(), empty_blocked_by).await;\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify blocked_by was cleared\n        assert!(updated_content.contains(\"blocked_by: []\"));\n        assert!(!updated_content.contains(\"Old Dependency One\"));\n        assert!(!updated_content.contains(\"Old Dependency Two\"));\n\n        // Verify other content preserved\n        assert!(updated_content.contains(\"This is the problem statement\"));\n        assert!(updated_content.contains(\"id: test-document\"));\n\n        // Verify frontmatter can be parsed again\n        let parsed_again =\n            gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026updated_content);\n        assert!(parsed_again.data.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_replace_existing() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nblocked_by:\n  - \"[[Old Dependency]]\"\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\n\n## Problem Statement\n\nThis is the problem statement.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let new_blocked_by = vec![\n            \"[[New Dependency One]]\".to_string(),\n            \"[[New Dependency Two]]\".to_string(),\n            \"[[New Dependency Three]]\".to_string(),\n        ];\n\n        let result = update_blocked_by(temp_file.path(), new_blocked_by).await;\n        assert!(result.is_ok());\n\n        // Read the updated file\n        let updated_content = fs::read_to_string(temp_file.path()).unwrap();\n\n        // Verify old blocked_by was replaced\n        assert!(!updated_content.contains(\"Old Dependency\"));\n        assert!(updated_content.contains(\"[[New Dependency One]]\"));\n        assert!(updated_content.contains(\"[[New Dependency Two]]\"));\n        assert!(updated_content.contains(\"[[New Dependency Three]]\"));\n\n        // Verify other content preserved\n        assert!(updated_content.contains(\"This is the problem statement\"));\n\n        // Verify frontmatter can be parsed again\n        let parsed_again =\n            gray_matter::Matter::\u003cgray_matter::engine::YAML\u003e::new().parse(\u0026updated_content);\n        assert!(parsed_again.data.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_invalid_reference() {\n        let document_content = r##\"---\nid: test-document\nlevel: strategy\nstatus: active\nblocked_by: []\ncreated_at: 2025-07-03T18:00:00Z\nupdated_at: 2025-07-03T18:00:00Z\n---\n\n# Test Strategy\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let invalid_blocked_by = vec![\n            \"[[Valid Dependency]]\".to_string(),\n            \"Invalid Dependency\".to_string(), // Missing brackets\n        ];\n\n        let result = update_blocked_by(temp_file.path(), invalid_blocked_by).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Invalid reference format\"));\n            assert!(message.contains(\"Invalid Dependency\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for invalid reference\");\n        }\n    }\n\n    #[tokio::test]\n    async fn test_update_blocked_by_no_frontmatter() {\n        let document_content = r##\"# Test Strategy\n\n## Problem Statement\n\nThis document has no frontmatter.\"##;\n\n        let temp_file = create_test_document(document_content);\n\n        let blocked_by = vec![\"[[Some Dependency]]\".to_string()];\n\n        let result = update_blocked_by(temp_file.path(), blocked_by).await;\n        assert!(result.is_err());\n\n        if let Err(MetisError::ValidationFailed { message }) = result {\n            assert!(message.contains(\"Document has no frontmatter to update\"));\n        } else {\n            panic!(\"Expected ValidationFailed error for missing frontmatter\");\n        }\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":7}},{"line":17,"address":[],"length":0,"stats":{"Line":10}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":6}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":3}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":5}},{"line":110,"address":[],"length":0,"stats":{"Line":10}},{"line":111,"address":[],"length":0,"stats":{"Line":10}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":146,"address":[],"length":0,"stats":{"Line":7}},{"line":151,"address":[],"length":0,"stats":{"Line":7}},{"line":152,"address":[],"length":0,"stats":{"Line":7}},{"line":155,"address":[],"length":0,"stats":{"Line":108}},{"line":156,"address":[],"length":0,"stats":{"Line":97}},{"line":157,"address":[],"length":0,"stats":{"Line":107}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":162,"address":[],"length":0,"stats":{"Line":14}},{"line":163,"address":[],"length":0,"stats":{"Line":14}},{"line":164,"address":[],"length":0,"stats":{"Line":17}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":177,"address":[],"length":0,"stats":{"Line":7}},{"line":183,"address":[],"length":0,"stats":{"Line":3}},{"line":184,"address":[],"length":0,"stats":{"Line":3}},{"line":185,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":12}},{"line":193,"address":[],"length":0,"stats":{"Line":12}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":11}},{"line":198,"address":[],"length":0,"stats":{"Line":21}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":7}},{"line":213,"address":[],"length":0,"stats":{"Line":7}},{"line":216,"address":[],"length":0,"stats":{"Line":40}},{"line":217,"address":[],"length":0,"stats":{"Line":27}},{"line":218,"address":[],"length":0,"stats":{"Line":35}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":223,"address":[],"length":0,"stats":{"Line":25}},{"line":224,"address":[],"length":0,"stats":{"Line":25}},{"line":225,"address":[],"length":0,"stats":{"Line":26}},{"line":229,"address":[],"length":0,"stats":{"Line":24}},{"line":230,"address":[],"length":0,"stats":{"Line":23}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":5}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":244,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":250,"address":[],"length":0,"stats":{"Line":40}},{"line":251,"address":[],"length":0,"stats":{"Line":36}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":32}},{"line":256,"address":[],"length":0,"stats":{"Line":36}},{"line":262,"address":[],"length":0,"stats":{"Line":45}},{"line":263,"address":[],"length":0,"stats":{"Line":45}},{"line":264,"address":[],"length":0,"stats":{"Line":88}},{"line":268,"address":[],"length":0,"stats":{"Line":8}},{"line":269,"address":[],"length":0,"stats":{"Line":24}},{"line":272,"address":[],"length":0,"stats":{"Line":8}},{"line":273,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":1}},{"line":276,"address":[],"length":0,"stats":{"Line":1}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":5}},{"line":285,"address":[],"length":0,"stats":{"Line":5}},{"line":288,"address":[],"length":0,"stats":{"Line":26}},{"line":289,"address":[],"length":0,"stats":{"Line":21}},{"line":292,"address":[],"length":0,"stats":{"Line":5}},{"line":294,"address":[],"length":0,"stats":{"Line":1}},{"line":297,"address":[],"length":0,"stats":{"Line":4}},{"line":298,"address":[],"length":0,"stats":{"Line":22}},{"line":299,"address":[],"length":0,"stats":{"Line":18}},{"line":300,"address":[],"length":0,"stats":{"Line":19}},{"line":303,"address":[],"length":0,"stats":{"Line":14}},{"line":304,"address":[],"length":0,"stats":{"Line":14}},{"line":305,"address":[],"length":0,"stats":{"Line":10}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":2}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":2}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":8}},{"line":354,"address":[],"length":0,"stats":{"Line":31}},{"line":355,"address":[],"length":0,"stats":{"Line":13}},{"line":356,"address":[],"length":0,"stats":{"Line":3}},{"line":357,"address":[],"length":0,"stats":{"Line":3}},{"line":361,"address":[],"length":0,"stats":{"Line":5}},{"line":365,"address":[],"length":0,"stats":{"Line":24}},{"line":366,"address":[],"length":0,"stats":{"Line":24}},{"line":367,"address":[],"length":0,"stats":{"Line":1}},{"line":371,"address":[],"length":0,"stats":{"Line":41}},{"line":372,"address":[],"length":0,"stats":{"Line":6}},{"line":376,"address":[],"length":0,"stats":{"Line":17}},{"line":379,"address":[],"length":0,"stats":{"Line":47}},{"line":383,"address":[],"length":0,"stats":{"Line":3}},{"line":388,"address":[],"length":0,"stats":{"Line":6}},{"line":389,"address":[],"length":0,"stats":{"Line":3}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":3}},{"line":396,"address":[],"length":0,"stats":{"Line":1}},{"line":398,"address":[],"length":0,"stats":{"Line":1}},{"line":399,"address":[],"length":0,"stats":{"Line":1}},{"line":400,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":7}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":6}},{"line":429,"address":[],"length":0,"stats":{"Line":6}},{"line":432,"address":[],"length":0,"stats":{"Line":6}},{"line":433,"address":[],"length":0,"stats":{"Line":12}},{"line":436,"address":[],"length":0,"stats":{"Line":6}},{"line":437,"address":[],"length":0,"stats":{"Line":6}},{"line":439,"address":[],"length":0,"stats":{"Line":6}}],"covered":136,"coverable":166},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-core","src","validation.rs"],"content":"//! Document validation functions\n\nuse crate::{DocumentType, Result};\nuse serde_yaml::Value;\nuse std::path::Path;\nuse tokio::fs;\n\n/// Result of document validation containing detailed error information\n#[derive(Debug, Clone)]\npub struct ValidationResult {\n    pub is_valid: bool,\n    pub document_type: Option\u003cDocumentType\u003e,\n    pub frontmatter_errors: Vec\u003cString\u003e,\n}\n\nimpl ValidationResult {\n    pub fn valid(document_type: DocumentType) -\u003e Self {\n        Self {\n            is_valid: true,\n            document_type: Some(document_type),\n            frontmatter_errors: Vec::new(),\n        }\n    }\n\n    pub fn invalid(errors: Vec\u003cString\u003e) -\u003e Self {\n        Self {\n            is_valid: false,\n            document_type: None,\n            frontmatter_errors: errors,\n        }\n    }\n\n    pub fn add_error(\u0026mut self, error: String) {\n        self.frontmatter_errors.push(error);\n        self.is_valid = false;\n    }\n}\n\n/// Validate a document from file path\npub async fn validate(document_path: \u0026Path) -\u003e Result\u003cValidationResult\u003e {\n    let content = fs::read_to_string(document_path)\n        .await\n        .map_err(crate::MetisError::Io)?;\n    validate_content(\u0026content)\n}\n\n/// Validate a document from content string\npub fn validate_content(content: \u0026str) -\u003e Result\u003cValidationResult\u003e {\n    // Extract frontmatter manually\n    let frontmatter = match extract_frontmatter(content) {\n        Some(fm) =\u003e fm,\n        None =\u003e {\n            return Ok(ValidationResult::invalid(vec![\n                \"No frontmatter found in document\".to_string(),\n            ]));\n        }\n    };\n\n    let mut result = ValidationResult {\n        is_valid: true,\n        document_type: None,\n        frontmatter_errors: Vec::new(),\n    };\n\n    // Extract and validate document type\n    let doc_type = match extract_document_type(\u0026frontmatter) {\n        Ok(dt) =\u003e {\n            result.document_type = Some(dt.clone());\n            dt\n        }\n        Err(error) =\u003e {\n            result.add_error(error);\n            return Ok(result);\n        }\n    };\n\n    // Validate required fields for the document type\n    validate_required_fields(\u0026frontmatter, \u0026doc_type, \u0026mut result);\n\n    // Validate phase from tags\n    validate_phase_from_tags(\u0026frontmatter, \u0026doc_type, \u0026mut result);\n\n    Ok(result)\n}\n\n/// Extract frontmatter from document content\nfn extract_frontmatter(content: \u0026str) -\u003e Option\u003cValue\u003e {\n    if !content.starts_with(\"---\") {\n        return None;\n    }\n\n    let mut lines = content.lines();\n    lines.next(); // Skip first \"---\"\n\n    let mut frontmatter_lines = Vec::new();\n    for line in lines {\n        if line.trim() == \"---\" {\n            break;\n        }\n        frontmatter_lines.push(line);\n    }\n\n    let frontmatter_str = frontmatter_lines.join(\"\\n\");\n    serde_yaml::from_str(\u0026frontmatter_str).ok()\n}\n\n/// Extract document type from frontmatter\nfn extract_document_type(frontmatter: \u0026Value) -\u003e std::result::Result\u003cDocumentType, String\u003e {\n    let level = frontmatter\n        .get(\"level\")\n        .and_then(|v| v.as_str())\n        .ok_or_else(|| \"Missing 'level' field in frontmatter\".to_string())?;\n\n    match level {\n        \"vision\" =\u003e Ok(DocumentType::Vision),\n        \"strategy\" =\u003e Ok(DocumentType::Strategy),\n        \"initiative\" =\u003e Ok(DocumentType::Initiative),\n        \"task\" =\u003e Ok(DocumentType::Task),\n        \"adr\" =\u003e Ok(DocumentType::Adr),\n        _ =\u003e Err(format!(\n            \"Invalid document level: '{}'. Must be one of: vision, strategy, initiative, task, adr\",\n            level\n        )),\n    }\n}\n\n/// Validate required fields for a specific document type\nfn validate_required_fields(\n    frontmatter: \u0026Value,\n    doc_type: \u0026DocumentType,\n    result: \u0026mut ValidationResult,\n) {\n    // Check common required fields\n    let required_common = [\"id\", \"level\", \"status\", \"created_at\", \"updated_at\"];\n    for field in \u0026required_common {\n        if frontmatter.get(field).is_none() {\n            result.add_error(format!(\"Missing required field: '{}'\", field));\n        }\n    }\n\n    // Check document-type specific required fields\n    match doc_type {\n        DocumentType::Strategy =\u003e {\n            if frontmatter.get(\"risk_level\").is_none() {\n                result.add_error(\"Strategy documents require 'risk_level' field\".to_string());\n            } else if let Some(risk) = frontmatter.get(\"risk_level\").and_then(|v| v.as_str()) {\n                if ![\"low\", \"medium\", \"high\", \"critical\"].contains(\u0026risk) {\n                    result.add_error(format!(\n                        \"Invalid risk_level '{}'. Must be: low, medium, high, or critical\",\n                        risk\n                    ));\n                }\n            }\n        }\n        DocumentType::Initiative =\u003e {\n            if frontmatter.get(\"estimated_complexity\").is_none() {\n                result.add_error(\n                    \"Initiative documents require 'estimated_complexity' field\".to_string(),\n                );\n            } else if let Some(complexity) = frontmatter\n                .get(\"estimated_complexity\")\n                .and_then(|v| v.as_str())\n            {\n                if ![\"S\", \"M\", \"L\", \"XL\"].contains(\u0026complexity) {\n                    result.add_error(format!(\n                        \"Invalid complexity '{}'. Must be: S, M, L, or XL\",\n                        complexity\n                    ));\n                }\n            }\n        }\n        DocumentType::Adr =\u003e {\n            if frontmatter.get(\"decision_maker\").is_none() {\n                result.add_error(\"ADR documents require 'decision_maker' field\".to_string());\n            }\n            // Note: number field is optional in our templates, so not requiring it\n        }\n        DocumentType::Vision | DocumentType::Task =\u003e {\n            // No additional required fields for these types\n        }\n    }\n}\n\n/// Validate phase from tags array\nfn validate_phase_from_tags(\n    frontmatter: \u0026Value,\n    doc_type: \u0026DocumentType,\n    result: \u0026mut ValidationResult,\n) {\n    let tags = match frontmatter.get(\"tags\").and_then(|v| v.as_sequence()) {\n        Some(tags) =\u003e tags,\n        None =\u003e {\n            result.add_error(\"Missing 'tags' field in frontmatter\".to_string());\n            return;\n        }\n    };\n\n    // Extract phase tags\n    let phase_tags: Vec\u003cString\u003e = tags\n        .iter()\n        .filter_map(|tag| tag.as_str())\n        .filter(|tag| tag.starts_with(\"#phase/\"))\n        .map(|tag| tag.strip_prefix(\"#phase/\").unwrap().to_string())\n        .collect();\n\n    if phase_tags.is_empty() {\n        result.add_error(\"Document must have at least one #phase/ tag\".to_string());\n        return;\n    }\n\n    if phase_tags.len() \u003e 1 {\n        result.add_error(format!(\n            \"Document has multiple active phase tags: {}. Only one phase should be active.\",\n            phase_tags.join(\", \")\n        ));\n        return;\n    }\n\n    let current_phase = \u0026phase_tags[0];\n\n    // Validate phase against document type\n    let valid_phases = match doc_type {\n        DocumentType::Vision =\u003e vec![\"draft\", \"review\", \"published\"],\n        DocumentType::Strategy =\u003e vec![\"shaping\", \"design\", \"ready\", \"active\", \"completed\"],\n        DocumentType::Initiative =\u003e vec![\n            \"discovery\",\n            \"design\",\n            \"ready\",\n            \"decompose\",\n            \"active\",\n            \"completed\",\n        ],\n        DocumentType::Task =\u003e vec![\"todo\", \"doing\", \"completed\"],\n        DocumentType::Adr =\u003e vec![\"draft\", \"discussion\", \"decided\", \"superseded\"],\n    };\n\n    if !valid_phases.contains(\u0026current_phase.as_str()) {\n        result.add_error(format!(\n            \"Invalid phase '{}' for {} document. Valid phases: {}\",\n            current_phase,\n            format!(\"{:?}\", doc_type).to_lowercase(),\n            valid_phases.join(\", \")\n        ));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_valid_strategy_document() {\n        let content = \"---\nid: strategy-test\nlevel: strategy\nstatus: shaping\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\nparent: \nblocked_by: \ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/shaping\\\"\nexit_criteria_met: false\nsuccess_metrics: []\nrisk_level: high\nstakeholders: []\n---\n\n# Test Strategy\n\nContent here...\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(result.is_valid);\n        assert_eq!(result.document_type, Some(DocumentType::Strategy));\n        assert!(result.frontmatter_errors.is_empty());\n    }\n\n    #[test]\n    fn test_validate_missing_frontmatter() {\n        let content = \"# Just some markdown without frontmatter\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert_eq!(result.document_type, None);\n        assert_eq!(\n            result.frontmatter_errors,\n            vec![\"No frontmatter found in document\"]\n        );\n    }\n\n    #[test]\n    fn test_validate_invalid_level() {\n        let content = \"---\nid: test-doc\nlevel: invalid_level\nstatus: draft\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\ntags:\n  - \\\"#test\\\"\n---\n\n# Test Document\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert_eq!(result.document_type, None);\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Invalid document level\")));\n    }\n\n    #[test]\n    fn test_validate_missing_required_fields() {\n        let content = \"---\nlevel: strategy\n---\n\n# Incomplete Strategy\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Missing required field: 'id'\")));\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Missing required field: 'status'\")));\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Strategy documents require 'risk_level'\")));\n    }\n\n    #[test]\n    fn test_validate_invalid_phase_tags() {\n        let content = \"---\nid: strategy-test\nlevel: strategy\nstatus: shaping\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\nrisk_level: high\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/invalid_phase\\\"\n---\n\n# Test Strategy\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"Invalid phase 'invalid_phase'\")));\n    }\n\n    #[test]\n    fn test_validate_multiple_phase_tags() {\n        let content = \"---\nid: strategy-test\nlevel: strategy\nstatus: shaping\ncreated_at: 2025-07-03T12:00:00Z\nupdated_at: 2025-07-03T12:00:00Z\nrisk_level: high\ntags:\n  - \\\"#strategy\\\"\n  - \\\"#phase/shaping\\\"\n  - \\\"#phase/design\\\"\n---\n\n# Test Strategy\n\";\n\n        let result = validate_content(content).unwrap();\n        assert!(!result.is_valid);\n        assert!(result\n            .frontmatter_errors\n            .iter()\n            .any(|e| e.contains(\"multiple active phase tags\")));\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":21}},{"line":34,"address":[],"length":0,"stats":{"Line":21}},{"line":35,"address":[],"length":0,"stats":{"Line":21}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":17}},{"line":48,"address":[],"length":0,"stats":{"Line":33}},{"line":49,"address":[],"length":0,"stats":{"Line":16}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":16}},{"line":64,"address":[],"length":0,"stats":{"Line":31}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":17}},{"line":86,"address":[],"length":0,"stats":{"Line":17}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":16}},{"line":91,"address":[],"length":0,"stats":{"Line":16}},{"line":93,"address":[],"length":0,"stats":{"Line":16}},{"line":94,"address":[],"length":0,"stats":{"Line":302}},{"line":95,"address":[],"length":0,"stats":{"Line":151}},{"line":96,"address":[],"length":0,"stats":{"Line":16}},{"line":98,"address":[],"length":0,"stats":{"Line":135}},{"line":101,"address":[],"length":0,"stats":{"Line":16}},{"line":102,"address":[],"length":0,"stats":{"Line":16}},{"line":106,"address":[],"length":0,"stats":{"Line":16}},{"line":107,"address":[],"length":0,"stats":{"Line":32}},{"line":109,"address":[],"length":0,"stats":{"Line":48}},{"line":110,"address":[],"length":0,"stats":{"Line":32}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":31}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":123,"address":[],"length":0,"stats":{"Line":15}},{"line":125,"address":[],"length":0,"stats":{"Line":15}},{"line":126,"address":[],"length":0,"stats":{"Line":165}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":15}},{"line":135,"address":[],"length":0,"stats":{"Line":22}},{"line":136,"address":[],"length":0,"stats":{"Line":7}},{"line":137,"address":[],"length":0,"stats":{"Line":31}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":15}},{"line":166,"address":[],"length":0,"stats":{"Line":46}},{"line":167,"address":[],"length":0,"stats":{"Line":8}},{"line":169,"address":[],"length":0,"stats":{"Line":7}},{"line":170,"address":[],"length":0,"stats":{"Line":7}},{"line":175,"address":[],"length":0,"stats":{"Line":8}},{"line":177,"address":[],"length":0,"stats":{"Line":33}},{"line":178,"address":[],"length":0,"stats":{"Line":33}},{"line":179,"address":[],"length":0,"stats":{"Line":25}},{"line":182,"address":[],"length":0,"stats":{"Line":8}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":8}},{"line":188,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":7}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":7}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":1}}],"covered":65,"coverable":88},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","config.rs"],"content":"use anyhow::Result;\n\n#[derive(Debug, Clone, Default)]\npub struct MetisServerConfig {\n    // Configuration is now minimal since we use direct paths\n    // Could add logging level, port bindings, etc. in future\n}\n\nimpl MetisServerConfig {\n    pub fn from_env() -\u003e Result\u003cSelf\u003e {\n        // No environment variables needed for stateless operation\n        Ok(Self {})\n    }\n\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","error.rs"],"content":"use thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum McpServerError {\n    #[error(\"Document not found: {document_path}\")]\n    DocumentNotFound { document_path: String },\n\n    #[error(\"Invalid parameter: {param_name} - {message}\")]\n    InvalidParameter { param_name: String, message: String },\n\n    #[error(\"Metis project not initialized at path: {path}\")]\n    ProjectNotInitialized { path: String },\n\n    #[error(\"Core library error: {0}\")]\n    CoreLibrary(#[from] metis_core::MetisError),\n\n    #[error(\"Configuration error: {0}\")]\n    Config(#[from] anyhow::Error),\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, McpServerError\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","lib.rs"],"content":"pub mod config;\npub mod error;\npub mod server;\npub mod tools;\n\npub use config::MetisServerConfig;\npub use error::{McpServerError, Result};\npub use server::MetisServerHandler;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","main.rs"],"content":"use anyhow::Result;\nuse metis_mcp_server::{MetisServerConfig, MetisServerHandler};\nuse rust_mcp_sdk::{\n    mcp_server::server_runtime,\n    schema::{\n        Implementation, InitializeResult, ServerCapabilities, ServerCapabilitiesTools,\n        LATEST_PROTOCOL_VERSION,\n    },\n    McpServer, StdioTransport, TransportOptions,\n};\nuse tracing::info;\n\nfn find_metis_log_path() -\u003e Option\u003cString\u003e {\n    let current_dir = std::env::current_dir().ok()?;\n    let mut current = current_dir;\n\n    // Traverse upward looking for initialized metis project\n    loop {\n        let metis_dir = current.join(\"metis\");\n        let metis_db = metis_dir.join(\".metis.db\");\n\n        // Only create logs if there's an initialized metis project\n        if metis_dir.is_dir() \u0026\u0026 metis_db.exists() {\n            return Some(\n                metis_dir\n                    .join(\"metis-mcp-server.log\")\n                    .to_string_lossy()\n                    .to_string(),\n            );\n        }\n\n        // Move to parent directory\n        if let Some(parent) = current.parent() {\n            current = parent.to_path_buf();\n        } else {\n            // Reached filesystem root\n            break;\n        }\n    }\n\n    None\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    // Initialize logging only if we find an initialized metis project\n    if let Some(log_path) = find_metis_log_path() {\n        // Initialize tracing with file output in metis project\n        let log_file = std::fs::OpenOptions::new()\n            .create(true)\n            .append(true)\n            .open(\u0026log_path)?;\n\n        tracing_subscriber::fmt()\n            .with_writer(log_file)\n            .with_ansi(false)\n            .init();\n    } else {\n        // No metis project found - use minimal console logging only\n        tracing_subscriber::fmt()\n            .with_writer(std::io::stderr)\n            .with_ansi(false)\n            .with_max_level(tracing::Level::WARN)\n            .init();\n    }\n\n    // Load configuration (minimal for now)\n    let config = MetisServerConfig::from_env()?;\n\n    info!(\"Starting Metis MCP Server\");\n\n    // Create server details\n    let server_details = InitializeResult {\n        server_info: Implementation {\n            name: \"Metis Documentation Management System\".to_string(),\n            version: \"0.1.0\".to_string(),\n            title: Some(\"Metis MCP Server\".to_string()),\n        },\n        capabilities: ServerCapabilities {\n            tools: Some(ServerCapabilitiesTools { list_changed: None }),\n            ..Default::default()\n        },\n        meta: None,\n        instructions: Some(\n            r#\"# Metis Flight Levels Documentation Management\n\n## Overview\nMetis implements a hierarchical document management system based on Flight Levels methodology. You manage projects by creating and transitioning documents through defined phases using direct file paths.\n\n## Document Hierarchy (Flight Levels)\nCreate documents in this order, with each level building on the previous:\n\n1. **Vision** (Level 3) - Overall purpose and direction\n   - Always start here - defines why the project exists\n   - Phases: draft  review  published\n\n2. **Strategy** (Level 2) - How to achieve the vision  \n   - Must reference Vision as parent\n   - Phases: shaping  design  ready  active  completed\n\n3. **Initiative** (Level 1) - Concrete projects implementing strategies\n   - Must reference Strategy as parent\n   - Phases: discovery  design  ready  decompose  active  completed\n\n4. **Task** (Level 0) - Individual work items\n   - Must reference Initiative as parent\n   - Phases: todo  doing  completed\n\n5. **ADR** (Architectural Decision Record) - Technical decisions\n   - Can exist at any level, no parent required\n   - Phases: draft  discussion  decided  superseded\n\n## Direct Path Usage\nAll tools use `project_path` pointing to the directory containing `.metis.db`:\n- Initialize: `{\"project_path\": \"/path/to/project\", \"project_name\": \"my-project\"}`\n- Create doc: `{\"project_path\": \"/path/to/project\", \"document_type\": \"vision\", \"title\": \"Project Vision\"}`\n- Update: `{\"project_path\": \"/path/to/project\", \"document_path\": \"vision.md\", ...}`\n\n## Essential Workflow\n1. **Start**: `initialize_project` creates `.metis.db` and initial structure\n2. **Build hierarchy**: Create Vision  Strategies  Initiatives  Tasks\n3. **Progress**: Use `validate_exit_criteria` before `transition_phase`\n4. **Update**: Use `update_*` tools for incremental changes\n5. **Query**: Use `list_documents` and `search_documents` to explore\n\n## Phase Transition Rules\n- Always validate exit criteria before transitioning: `validate_exit_criteria`\n- Use `transition_phase` only when ready to progress\n- Phase progression is generally linear (no skipping)\n- Force transitions with `force: true` only when necessary\n\n## Best Practices\n- Create documents in hierarchical order (Vision before Strategy, etc.)\n- Define clear exit criteria for each phase\n- Use `blocked_by` to track dependencies\n- Validate documents after creation/updates\n- Keep documents focused on their level's scope\n- Update parent documents when children complete\n\n## Common Patterns\n- Start with Vision, then 2-3 key Strategies\n- Each Strategy typically has 3-5 Initiatives  \n- Each Initiative usually has 5-15 Tasks\n- Create ADRs for significant technical decisions\n- Review hierarchy regularly as work progresses\"#.to_string(),\n        ),\n        protocol_version: LATEST_PROTOCOL_VERSION.to_string(),\n    };\n\n    // Create transport\n    let transport = StdioTransport::new(TransportOptions::default())\n        .map_err(|e| anyhow::anyhow!(\"Failed to create transport: {}\", e))?;\n\n    // Create handler\n    let handler = MetisServerHandler::new(config);\n\n    // Create and start server\n    let server = server_runtime::create_server(server_details, transport, handler);\n\n    info!(\"MCP Server starting on stdio transport\");\n    server\n        .start()\n        .await\n        .map_err(|e| anyhow::anyhow!(\"MCP server failed to start: {}\", e))?;\n\n    Ok(())\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","server.rs"],"content":"use crate::tools::{\n    CheckPhaseTransitionTool, CreateDocumentTool, InitializeProjectTool, ListDocumentsTool,\n    MetisTools, OpenVaultInObsidianTool, SearchDocumentsTool, TransitionPhaseTool,\n    UpdateBlockedByTool, UpdateDocumentContentTool, UpdateExitCriterionTool, ValidateDocumentTool,\n    ValidateExitCriteriaTool,\n};\nuse crate::MetisServerConfig;\nuse async_trait::async_trait;\nuse rust_mcp_sdk::{\n    mcp_server::ServerHandler,\n    schema::{CallToolRequest, CallToolResult, ListToolsRequest, ListToolsResult, TextContent},\n    McpServer,\n};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::sync::RwLock;\nuse tracing::{debug, error, info, warn};\n\npub struct MetisServerHandler {\n    #[allow(dead_code)]\n    config: Arc\u003cMetisServerConfig\u003e,\n    // Track active projects for background sync\n    active_projects: Arc\u003cRwLock\u003cHashMap\u003cPathBuf, Arc\u003cmetis_core::SyncEngine\u003e\u003e\u003e\u003e,\n}\n\nimpl MetisServerHandler {\n    pub fn new(config: MetisServerConfig) -\u003e Self {\n        let handler = Self {\n            config: Arc::new(config),\n            active_projects: Arc::new(RwLock::new(HashMap::new())),\n        };\n\n        // Auto-discover existing projects on startup\n        handler.discover_existing_projects();\n\n        // Start background sync task\n        handler.start_background_sync();\n\n        handler\n    }\n\n    fn discover_existing_projects(\u0026self) {\n        let active_projects = Arc::clone(\u0026self.active_projects);\n\n        tokio::spawn(async move {\n            info!(\"Discovering existing Metis projects...\");\n\n            // Start from current directory and search for .metis.db files\n            if let Ok(current_dir) = std::env::current_dir() {\n                match Self::find_metis_projects(\u0026current_dir).await {\n                    Ok(projects) =\u003e {\n                        info!(\"Found {} existing Metis projects\", projects.len());\n\n                        let mut projects_map = active_projects.write().await;\n                        for project_path in projects {\n                            match Self::initialize_sync_engine(\u0026project_path).await {\n                                Ok(sync_engine) =\u003e {\n                                    info!(\n                                        \"Registered project for sync: {}\",\n                                        project_path.display()\n                                    );\n                                    projects_map.insert(project_path, sync_engine);\n                                }\n                                Err(e) =\u003e {\n                                    warn!(\n                                        \"Failed to initialize sync engine for {}: {}\",\n                                        project_path.display(),\n                                        e\n                                    );\n                                }\n                            }\n                        }\n                    }\n                    Err(e) =\u003e {\n                        warn!(\"Failed to discover existing projects: {}\", e);\n                    }\n                }\n            }\n        });\n    }\n\n    async fn find_metis_projects(\n        start_dir: \u0026std::path::Path,\n    ) -\u003e Result\u003cVec\u003cPathBuf\u003e, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        let mut projects = Vec::new();\n        let mut current_dir = start_dir.to_path_buf();\n\n        // Traverse upward from current directory looking for metis/ subdirectory\n        loop {\n            let metis_dir = current_dir.join(\"metis\");\n            let metis_db = metis_dir.join(\".metis.db\");\n\n            if metis_dir.is_dir() \u0026\u0026 metis_db.is_file() {\n                info!(\"Found Metis project at: {}\", metis_dir.display());\n                projects.push(metis_dir);\n            }\n\n            // Move to parent directory\n            if let Some(parent) = current_dir.parent() {\n                current_dir = parent.to_path_buf();\n            } else {\n                // Reached filesystem root\n                break;\n            }\n        }\n\n        Ok(projects)\n    }\n\n    async fn initialize_sync_engine(\n        project_path: \u0026Path,\n    ) -\u003e Result\u003cArc\u003cmetis_core::SyncEngine\u003e, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        let db_path = project_path.join(\".metis.db\");\n\n        // Create document store and sync engine\n        let store = metis_core::DocumentStore::new(db_path.to_str().unwrap())\n            .await\n            .map_err(|e| format!(\"Failed to open document store: {}\", e))?;\n        let sync_engine = Arc::new(metis_core::SyncEngine::new(store));\n\n        // Run initial sync\n        info!(\n            \"Running initial sync for discovered project: {}\",\n            project_path.display()\n        );\n        match sync_engine.sync_from_filesystem(project_path).await {\n            Ok(result) =\u003e {\n                info!(\n                    \"Initial sync completed for {}: {} processed, {} updated, {} deleted\",\n                    project_path.display(),\n                    result.files_processed,\n                    result.files_updated,\n                    result.files_deleted\n                );\n\n                if !result.errors.is_empty() {\n                    warn!(\n                        \"Initial sync errors for {}: {} errors\",\n                        project_path.display(),\n                        result.errors.len()\n                    );\n                    for error in \u0026result.errors {\n                        error!(\n                            \"Initial sync error in {}: {}\",\n                            error.file_path.display(),\n                            error.error\n                        );\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                warn!(\"Initial sync failed for {}: {}\", project_path.display(), e);\n            }\n        }\n\n        Ok(sync_engine)\n    }\n\n    fn start_background_sync(\u0026self) {\n        let active_projects = Arc::clone(\u0026self.active_projects);\n\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(Duration::from_secs(5));\n            info!(\"Background sync task started, checking every 5 seconds\");\n\n            loop {\n                interval.tick().await;\n\n                let projects = active_projects.read().await;\n                debug!(\"Background sync tick: {} active projects\", projects.len());\n                for (project_path, sync_engine) in projects.iter() {\n                    match sync_engine.sync_from_filesystem(project_path).await {\n                        Ok(result) =\u003e {\n                            if result.files_updated \u003e 0 || result.files_deleted \u003e 0 {\n                                debug!(\n                                    \"Sync completed for {}: {} updated, {} deleted\",\n                                    project_path.display(),\n                                    result.files_updated,\n                                    result.files_deleted\n                                );\n                            }\n\n                            if !result.errors.is_empty() {\n                                warn!(\n                                    \"Sync errors for {}: {} errors\",\n                                    project_path.display(),\n                                    result.errors.len()\n                                );\n                                for error in \u0026result.errors {\n                                    error!(\n                                        \"Sync error in {}: {}\",\n                                        error.file_path.display(),\n                                        error.error\n                                    );\n                                }\n                            }\n                        }\n                        Err(e) =\u003e {\n                            error!(\"Sync failed for {}: {}\", project_path.display(), e);\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    async fn ensure_project_synced(\n        \u0026self,\n        project_path: \u0026PathBuf,\n    ) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        info!(\n            \"ensure_project_synced called for: {}\",\n            project_path.display()\n        );\n        let mut projects = self.active_projects.write().await;\n\n        if !projects.contains_key(project_path) {\n            info!(\n                \"Project not found in active projects, initializing: {}\",\n                project_path.display()\n            );\n            // Check if project exists\n            let db_path = project_path.join(\".metis.db\");\n            if !db_path.exists() {\n                return Err(\n                    format!(\"Metis project not found at: {}\", project_path.display()).into(),\n                );\n            }\n\n            // Create document store and sync engine\n            let store = metis_core::DocumentStore::new(db_path.to_str().unwrap())\n                .await\n                .map_err(|e| format!(\"Failed to open document store: {}\", e))?;\n            let sync_engine = Arc::new(metis_core::SyncEngine::new(store));\n\n            // Run initial sync\n            info!(\n                \"Running initial sync for project: {}\",\n                project_path.display()\n            );\n            match sync_engine.sync_from_filesystem(project_path).await {\n                Ok(result) =\u003e {\n                    info!(\n                        \"Initial sync completed for {}: {} processed, {} updated, {} deleted\",\n                        project_path.display(),\n                        result.files_processed,\n                        result.files_updated,\n                        result.files_deleted\n                    );\n                }\n                Err(e) =\u003e {\n                    warn!(\"Initial sync failed for {}: {}\", project_path.display(), e);\n                }\n            }\n\n            projects.insert(project_path.clone(), sync_engine);\n        }\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl ServerHandler for MetisServerHandler {\n    async fn handle_list_tools_request(\n        \u0026self,\n        _request: ListToolsRequest,\n        _server: \u0026dyn McpServer,\n    ) -\u003e Result\u003cListToolsResult, rust_mcp_sdk::schema::RpcError\u003e {\n        Ok(ListToolsResult {\n            tools: MetisTools::tools(),\n            meta: None,\n            next_cursor: None,\n        })\n    }\n\n    async fn handle_call_tool_request(\n        \u0026self,\n        request: CallToolRequest,\n        _server: \u0026dyn McpServer,\n    ) -\u003e Result\u003cCallToolResult, rust_mcp_sdk::schema::schema_utils::CallToolError\u003e {\n        match request.params.name.as_str() {\n            \"initialize_project\" =\u003e {\n                let tool: InitializeProjectTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                // Initialize project at the specified path\n                let base_path = PathBuf::from(\u0026tool.project_path);\n\n                let config = metis_core::ProjectConfig {\n                    root_path: base_path.clone(),\n                    name: tool.project_name.clone(),\n                    description: tool.description.clone(),\n                };\n\n                match metis_core::initialize_project(config).await {\n                    Ok(metadata) =\u003e {\n                        // Register project for background sync using the metis directory path\n                        let metis_dir = base_path.join(\"metis\");\n                        if let Err(e) = self.ensure_project_synced(\u0026metis_dir).await {\n                            warn!(\"Failed to register project for sync: {}\", e);\n                        } else {\n                            info!(\n                                \"Successfully registered new project for sync: {}\",\n                                metis_dir.display()\n                            );\n                        }\n\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Project '{}' initialized successfully\", tool.project_name),\n                            \"project_path\": metadata.project_path,\n                            \"database_path\": metadata.database_path\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to initialize project '{}': {}\", tool.project_name, e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"create_document\" =\u003e {\n                let tool: CreateDocumentTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            \"validate_document\" =\u003e {\n                let tool: ValidateDocumentTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            \"update_document_content\" =\u003e {\n                let tool: UpdateDocumentContentTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core update function\n                match metis_core::update_document_content(\n                    \u0026document_path,\n                    \u0026tool.section_heading,\n                    \u0026tool.new_content,\n                )\n                .await\n                {\n                    Ok(()) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Successfully updated section '{}' in document\", tool.section_heading),\n                            \"document_path\": document_path,\n                            \"section_heading\": tool.section_heading,\n                            \"updated\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to update document content: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"update_exit_criterion\" =\u003e {\n                let tool: UpdateExitCriterionTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core update function\n                match metis_core::update_exit_criterion(\n                    \u0026document_path,\n                    \u0026tool.criterion_title,\n                    tool.completed,\n                )\n                .await\n                {\n                    Ok(()) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Successfully updated exit criterion to {}\", if tool.completed { \"completed\" } else { \"incomplete\" }),\n                            \"document_path\": document_path,\n                            \"criterion_title\": tool.criterion_title,\n                            \"completed\": tool.completed,\n                            \"updated\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to update exit criterion: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"update_blocked_by\" =\u003e {\n                let tool: UpdateBlockedByTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core update function\n                match metis_core::update_blocked_by(\u0026document_path, tool.blocked_by.clone()).await {\n                    Ok(()) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": \"Successfully updated blocked_by relationships\",\n                            \"document_path\": document_path,\n                            \"blocked_by\": tool.blocked_by,\n                            \"updated\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to update blocked_by: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"transition_phase\" =\u003e {\n                let tool: TransitionPhaseTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core phase transition function\n                match metis_core::transition_phase(\n                    \u0026document_path,\n                    \u0026tool.new_phase,\n                    tool.force.unwrap_or(false),\n                )\n                .await\n                {\n                    Ok(result_message) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": result_message,\n                            \"document_path\": document_path,\n                            \"new_phase\": tool.new_phase,\n                            \"force\": tool.force.unwrap_or(false),\n                            \"updated\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to transition phase: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"check_phase_transition\" =\u003e {\n                let tool: CheckPhaseTransitionTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core phase checking function\n                match metis_core::can_transition_to_phase(\u0026document_path, \u0026tool.target_phase).await\n                {\n                    Ok(can_transition) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": \"Phase transition check completed\",\n                            \"document_path\": document_path,\n                            \"target_phase\": tool.target_phase,\n                            \"can_transition\": can_transition,\n                            \"valid\": can_transition\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to check phase transition: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"validate_exit_criteria\" =\u003e {\n                let tool: ValidateExitCriteriaTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                let project_path = PathBuf::from(\u0026tool.project_path);\n                let document_path = project_path.join(\u0026tool.document_path);\n\n                // Use metis-core exit criteria validation function\n                match metis_core::validate_exit_criteria(\u0026document_path).await {\n                    Ok(result) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": \"Exit criteria validation completed\",\n                            \"document_path\": document_path,\n                            \"all_complete\": result.met,\n                            \"completed_count\": result.completed_criteria,\n                            \"total_count\": result.total_criteria,\n                            \"missing_criteria\": result.missing_criteria,\n                            \"valid\": true\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to validate exit criteria: {}\", e)\n                        });\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            \"list_documents\" =\u003e {\n                let tool: ListDocumentsTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            \"search_documents\" =\u003e {\n                let tool: SearchDocumentsTool = serde_json::from_value(serde_json::Value::Object(\n                    request.params.arguments.unwrap_or_default(),\n                ))\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            \"open_vault_in_obsidian\" =\u003e {\n                let tool: OpenVaultInObsidianTool = serde_json::from_value(\n                    serde_json::Value::Object(request.params.arguments.unwrap_or_default()),\n                )\n                .map_err(rust_mcp_sdk::schema::schema_utils::CallToolError::new)?;\n\n                tool.call_tool().await\n            }\n            _ =\u003e Err(\n                rust_mcp_sdk::schema::schema_utils::CallToolError::unknown_tool(\n                    request.params.name,\n                ),\n            ),\n        }\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":261},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","all_tools.rs"],"content":"use super::document::{CreateDocumentTool, ValidateDocumentTool};\nuse super::obsidian::OpenVaultInObsidianTool;\nuse super::phase::{CheckPhaseTransitionTool, TransitionPhaseTool, ValidateExitCriteriaTool};\nuse super::project::InitializeProjectTool;\nuse super::query::{ListDocumentsTool, SearchDocumentsTool};\nuse super::update::{UpdateBlockedByTool, UpdateDocumentContentTool, UpdateExitCriterionTool};\nuse rust_mcp_sdk::tool_box;\n\n// Generate the combined MetisTools enum\ntool_box!(\n    MetisTools,\n    [\n        InitializeProjectTool,\n        CreateDocumentTool,\n        ValidateDocumentTool,\n        UpdateDocumentContentTool,\n        UpdateExitCriterionTool,\n        UpdateBlockedByTool,\n        TransitionPhaseTool,\n        CheckPhaseTransitionTool,\n        ValidateExitCriteriaTool,\n        ListDocumentsTool,\n        SearchDocumentsTool,\n        OpenVaultInObsidianTool\n    ]\n);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","document.rs"],"content":"use metis_core::{\n    render, validate, Complexity, DocumentContext, DocumentStore, DocumentType, RiskLevel,\n};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse std::str::FromStr;\n\n#[mcp_tool(\n    name = \"create_document\",\n    description = \"Create a new Metis document (vision, strategy, initiative, task, adr)\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct CreateDocumentTool {\n    /// Path to the .metis folder where the document will be created\n    pub project_path: String,\n\n    /// Document type: vision, strategy, initiative, task, adr\n    pub document_type: String,\n\n    /// Title of the document\n    pub title: String,\n\n    /// Parent document title (required for strategy, initiative, task)\n    pub parent_title: Option\u003cString\u003e,\n\n    /// Risk level for strategies (low, medium, high)\n    pub risk_level: Option\u003cString\u003e,\n\n    /// Complexity for initiatives (xs, s, m, l, xl)\n    pub complexity: Option\u003cString\u003e,\n\n    /// Decision maker for ADRs\n    pub decision_maker: Option\u003cString\u003e,\n\n    /// Stakeholders involved\n    pub stakeholders: Option\u003cVec\u003cString\u003e\u003e,\n}\n\nimpl CreateDocumentTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n\n        // Parse document type\n        let doc_type = DocumentType::from_str(\u0026self.document_type).map_err(CallToolError::new)?;\n\n        // Create document context\n        let mut context = DocumentContext::new(self.title.clone());\n\n        // Add optional fields based on document type\n        if let Some(parent) = \u0026self.parent_title {\n            context = context.with_parent(parent.clone());\n        }\n\n        if let Some(risk) = \u0026self.risk_level {\n            let risk_level = match risk.to_lowercase().as_str() {\n                \"low\" =\u003e RiskLevel::Low,\n                \"medium\" =\u003e RiskLevel::Medium,\n                \"high\" =\u003e RiskLevel::High,\n                \"critical\" =\u003e RiskLevel::Critical,\n                _ =\u003e return Ok(CallToolResult::text_content(\n                    vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                        \"error\": format!(\"Invalid risk level '{}'. Must be: low, medium, high, critical\", risk)\n                    })).map_err(CallToolError::new)?)]\n                ))\n            };\n            context = context.with_risk_level(risk_level);\n        }\n\n        if let Some(complexity) = \u0026self.complexity {\n            let complexity_level = match complexity.to_lowercase().as_str() {\n                \"s\" =\u003e Complexity::S,\n                \"m\" =\u003e Complexity::M,\n                \"l\" =\u003e Complexity::L,\n                \"xl\" =\u003e Complexity::XL,\n                _ =\u003e return Ok(CallToolResult::text_content(\n                    vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                        \"error\": format!(\"Invalid complexity '{}'. Must be: s, m, l, xl\", complexity)\n                    })).map_err(CallToolError::new)?)]\n                ))\n            };\n            context = context.with_complexity(complexity_level);\n        }\n\n        if let Some(decision_maker) = \u0026self.decision_maker {\n            context = context.with_decision_maker(decision_maker.clone());\n        }\n\n        if let Some(stakeholders) = \u0026self.stakeholders {\n            context = context.with_stakeholders(stakeholders.clone());\n        }\n\n        // Validate context for document type\n        if let Err(validation_error) = context.validate_for_type(\u0026doc_type) {\n            return Ok(CallToolResult::text_content(vec![TextContent::from(\n                serde_json::to_string_pretty(\u0026serde_json::json!({\n                    \"error\": \"Document validation failed\",\n                    \"validation_error\": format!(\"{}\", validation_error)\n                }))\n                .map_err(CallToolError::new)?,\n            )]));\n        }\n\n        // Render document using metis-core render function\n        match render(doc_type.clone(), context, \u0026project_path).await {\n            Ok(file_path) =\u003e {\n                // Store document in database\n                let db_path = project_path.join(\".metis.db\");\n                match DocumentStore::new(db_path.to_str().unwrap()).await {\n                    Ok(store) =\u003e {\n                        // Sync the created document to database\n                        let sync_engine = metis_core::SyncEngine::new(store);\n                        if let Err(e) = sync_engine.sync_from_filesystem(\u0026project_path).await {\n                            eprintln!(\"Warning: Failed to sync document to database: {}\", e);\n                        }\n\n                        let response = serde_json::json!({\n                            \"message\": format!(\"{} '{}' created successfully\", doc_type, self.title),\n                            \"file_path\": file_path.to_string_lossy(),\n                            \"document_type\": self.document_type\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to connect to database: {}\", e)\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to create document '{}': {}\", self.title, e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"validate_document\",\n    description = \"Validate a Metis document's structure and content\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct ValidateDocumentTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n}\n\nimpl ValidateDocumentTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        // Read the document file\n        match tokio::fs::read_to_string(\u0026document_path).await {\n            Ok(_content) =\u003e {\n                // Validate the document using metis-core\n                match validate(\u0026document_path).await {\n                    Ok(validation_result) =\u003e {\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Document validation {}: {}\",\n                                if validation_result.is_valid { \"passed\" } else { \"failed\" },\n                                if validation_result.is_valid {\n                                    \"Document is valid\".to_string()\n                                } else {\n                                    format!(\"{} errors found\", validation_result.frontmatter_errors.len())\n                                }),\n                            \"is_valid\": validation_result.is_valid,\n                            \"document_type\": validation_result.document_type,\n                            \"frontmatter_errors\": validation_result.frontmatter_errors,\n                            \"project_path\": self.project_path,\n                            \"document_path\": self.document_path\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Failed to validate document: {}\", e),\n                            \"project_path\": self.project_path,\n                            \"document_path\": self.document_path\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to read document file: {}\", e),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":12}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":12}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":6}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":10}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":6}},{"line":115,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":6}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":12}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}}],"covered":25,"coverable":100},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","mod.rs"],"content":"pub mod all_tools;\npub mod document;\npub mod obsidian;\npub mod phase;\npub mod project;\npub mod query;\npub mod update;\n\npub use all_tools::MetisTools;\npub use document::*;\npub use obsidian::*;\npub use phase::*;\npub use project::*;\npub use query::*;\npub use update::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","obsidian.rs"],"content":"use rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::fs;\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\n\n#[mcp_tool(\n    name = \"open_vault_in_obsidian\",\n    description = \"Open a metis project vault in Obsidian by configuring it as a known vault and launching Obsidian\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct OpenVaultInObsidianTool {\n    /// Path to the project directory to open as an Obsidian vault\n    pub project_path: String,\n}\n\nimpl OpenVaultInObsidianTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n\n        // Ensure the project path exists\n        if !project_path.exists() {\n            return Ok(CallToolResult::text_content(vec![TextContent::from(\n                serde_json::to_string_pretty(\u0026serde_json::json!({\n                    \"error\": format!(\"Project path does not exist: {}\", self.project_path)\n                }))\n                .map_err(CallToolError::new)?,\n            )]));\n        }\n\n        // Detect operating system and set appropriate configuration\n        let os_info = get_os_info();\n\n        match open_obsidian_vault(\u0026project_path, \u0026os_info) {\n            Ok(message) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": message,\n                    \"project_path\": self.project_path,\n                    \"os\": os_info.name\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to open vault in Obsidian: {}\", e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct OsInfo {\n    name: String,\n    config_path: PathBuf,\n    close_command: Vec\u003cString\u003e,\n    open_command: Vec\u003cString\u003e,\n}\n\nfn get_os_info() -\u003e OsInfo {\n    #[cfg(target_os = \"macos\")]\n    {\n        let home = std::env::var(\"HOME\").unwrap_or_default();\n        OsInfo {\n            name: \"macOS\".to_string(),\n            config_path: PathBuf::from(home)\n                .join(\"Library/Application Support/obsidian/obsidian.json\"),\n            close_command: vec![\n                \"osascript\".to_string(),\n                \"-e\".to_string(),\n                \"quit app \\\"Obsidian\\\"\".to_string(),\n            ],\n            open_command: vec![\"open\".to_string(), \"-a\".to_string(), \"Obsidian\".to_string()],\n        }\n    }\n\n    #[cfg(target_os = \"linux\")]\n    {\n        // Try multiple possible config locations for different installation methods\n        let config_path = get_linux_config_path();\n        OsInfo {\n            name: \"Linux\".to_string(),\n            config_path,\n            close_command: vec![\"killall\".to_string(), \"obsidian\".to_string()],\n            open_command: vec![\"obsidian\".to_string()],\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    {\n        let appdata = std::env::var(\"APPDATA\").unwrap_or_default();\n        OsInfo {\n            name: \"Windows\".to_string(),\n            config_path: PathBuf::from(appdata).join(\"Obsidian/obsidian.json\"), // Note: capital O\n            close_command: vec![\n                \"taskkill\".to_string(),\n                \"/F\".to_string(),\n                \"/IM\".to_string(),\n                \"Obsidian.exe\".to_string(),\n            ],\n            open_command: get_windows_obsidian_command(),\n        }\n    }\n\n    #[cfg(not(any(target_os = \"macos\", target_os = \"linux\", target_os = \"windows\")))]\n    {\n        OsInfo {\n            name: \"Unknown\".to_string(),\n            config_path: PathBuf::from(\"obsidian.json\"),\n            close_command: vec![],\n            open_command: vec![\"obsidian\".to_string()],\n        }\n    }\n}\n\n#[cfg(target_os = \"linux\")]\nfn get_linux_config_path() -\u003e PathBuf {\n    let home = std::env::var(\"HOME\").unwrap_or_default();\n\n    // Check multiple possible locations based on installation method\n    let possible_paths = vec![\n        // Standard location\n        PathBuf::from(\u0026home).join(\".config/obsidian/obsidian.json\"),\n        // Flatpak location\n        PathBuf::from(\u0026home).join(\".var/app/md.obsidian.Obsidian/config/obsidian/obsidian.json\"),\n        // Snap location (pattern - actual path varies by revision)\n        // We'll check for this dynamically below\n    ];\n\n    // Check standard and Flatpak locations\n    for path in \u0026possible_paths {\n        if path.exists() {\n            return path.clone();\n        }\n    }\n\n    // Check for Snap installation (dynamic revision)\n    let snap_base = PathBuf::from(\u0026home).join(\"snap/obsidian\");\n    if snap_base.exists() {\n        if let Ok(entries) = fs::read_dir(\u0026snap_base) {\n            for entry in entries.flatten() {\n                let config_path = entry.path().join(\".config/obsidian/obsidian.json\");\n                if config_path.exists() {\n                    return config_path;\n                }\n            }\n        }\n    }\n\n    // Default to standard location if none found\n    PathBuf::from(\u0026home).join(\".config/obsidian/obsidian.json\")\n}\n\n#[cfg(target_os = \"windows\")]\nfn get_windows_obsidian_command() -\u003e Vec\u003cString\u003e {\n    // Try to find Obsidian executable in common locations\n    let local_appdata = std::env::var(\"LOCALAPPDATA\").unwrap_or_default();\n    let possible_paths = vec![\n        PathBuf::from(\u0026local_appdata).join(\"Obsidian/Obsidian.exe\"),\n        // Could add other possible installation paths here\n    ];\n\n    for path in possible_paths {\n        if path.exists() {\n            return vec![\n                \"cmd\".to_string(),\n                \"/C\".to_string(),\n                \"start\".to_string(),\n                \"\".to_string(),\n                path.to_string_lossy().to_string(),\n            ];\n        }\n    }\n\n    // Fallback to hoping it's in PATH or using start with obsidian\n    vec![\n        \"cmd\".to_string(),\n        \"/C\".to_string(),\n        \"start\".to_string(),\n        \"obsidian\".to_string(),\n    ]\n}\n\nfn format_path_for_os(path: \u0026Path, _os_name: \u0026str) -\u003e Result\u003cString, Box\u003cdyn std::error::Error\u003e\u003e {\n    let path_str = path.to_string_lossy().to_string();\n\n    // On Windows, ensure we use backslashes for the JSON config\n    // (the JSON library will properly escape them when serializing)\n    #[cfg(target_os = \"windows\")]\n    {\n        Ok(path_str.replace(\"/\", \"\\\\\"))\n    }\n\n    // On Unix-like systems, use forward slashes\n    #[cfg(not(target_os = \"windows\"))]\n    {\n        Ok(path_str)\n    }\n}\n\nfn open_obsidian_vault(\n    project_path: \u0026Path,\n    os_info: \u0026OsInfo,\n) -\u003e Result\u003cString, Box\u003cdyn std::error::Error\u003e\u003e {\n    // Step 1: Close Obsidian if running\n    if !os_info.close_command.is_empty() {\n        let _ = Command::new(\u0026os_info.close_command[0])\n            .args(\u0026os_info.close_command[1..])\n            .output(); // Ignore errors - app might not be running\n\n        // Small delay to ensure app closes\n        std::thread::sleep(std::time::Duration::from_millis(500));\n    }\n\n    // Step 2: Get absolute path and format appropriately for OS\n    let vault_path = project_path.canonicalize()?;\n    let vault_path_str = format_path_for_os(\u0026vault_path, \u0026os_info.name)?;\n\n    // Step 3: Initialize .obsidian directory if needed\n    let obsidian_dir = vault_path.join(\".obsidian\");\n    if !obsidian_dir.exists() {\n        fs::create_dir_all(\u0026obsidian_dir)?;\n    }\n\n    // Step 4: Ensure config directory exists\n    if let Some(config_dir) = os_info.config_path.parent() {\n        fs::create_dir_all(config_dir)?;\n    }\n\n    // Step 5: Update Obsidian configuration\n    update_obsidian_config(\u0026os_info.config_path, \u0026vault_path_str)?;\n\n    // Step 6: Open Obsidian with the vault\n    if !os_info.open_command.is_empty() {\n        let mut cmd = Command::new(\u0026os_info.open_command[0]);\n        cmd.args(\u0026os_info.open_command[1..]);\n        cmd.arg(\u0026vault_path_str);\n\n        let output = cmd.output()?;\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            return Err(format!(\"Failed to open Obsidian: {}\", stderr).into());\n        }\n    }\n\n    Ok(format!(\n        \"Successfully opened vault '{}' in Obsidian\",\n        vault_path_str\n    ))\n}\n\nfn update_obsidian_config(\n    config_path: \u0026PathBuf,\n    vault_path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Read existing config or create new one\n    let mut config: serde_json::Value = if config_path.exists() {\n        let content = fs::read_to_string(config_path)?;\n        if content.trim().is_empty() {\n            serde_json::json!({})\n        } else {\n            serde_json::from_str(\u0026content).unwrap_or_else(|_| serde_json::json!({}))\n        }\n    } else {\n        serde_json::json!({})\n    };\n\n    // Ensure vaults object exists\n    if !config.is_object() {\n        config = serde_json::json!({});\n    }\n\n    let config_obj = config.as_object_mut().unwrap();\n    if !config_obj.contains_key(\"vaults\") {\n        config_obj.insert(\"vaults\".to_string(), serde_json::json!({}));\n    }\n\n    // Generate vault ID (16-character hex string based on path)\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    let mut hasher = DefaultHasher::new();\n    vault_path.hash(\u0026mut hasher);\n    let hash = hasher.finish();\n    let vault_id = format!(\"{:016x}\", hash)[..16].to_string();\n\n    // Add vault entry (check if it already exists)\n    let vaults = config_obj\n        .get_mut(\"vaults\")\n        .unwrap()\n        .as_object_mut()\n        .unwrap();\n\n    // Only add if vault doesn't already exist\n    if !vaults.contains_key(\u0026vault_id) {\n        vaults.insert(\n            vault_id,\n            serde_json::json!({\n                \"path\": vault_path,\n                \"ts\": std::time::SystemTime::now()\n                    .duration_since(std::time::UNIX_EPOCH)\n                    .unwrap()\n                    .as_millis() as u64,\n                \"open\": true\n            }),\n        );\n    } else {\n        // Update existing entry to mark as open and update timestamp\n        if let Some(vault_entry) = vaults.get_mut(\u0026vault_id) {\n            if let Some(vault_obj) = vault_entry.as_object_mut() {\n                vault_obj.insert(\"open\".to_string(), serde_json::json!(true));\n                vault_obj.insert(\n                    \"ts\".to_string(),\n                    serde_json::json!(std::time::SystemTime::now()\n                        .duration_since(std::time::UNIX_EPOCH)\n                        .unwrap()\n                        .as_millis() as u64),\n                );\n            }\n        }\n    }\n\n    // Write config back\n    let config_str = serde_json::to_string_pretty(\u0026config)?;\n    let mut file = fs::File::create(config_path)?;\n    file.write_all(config_str.as_bytes())?;\n\n    Ok(())\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":9}},{"line":27,"address":[],"length":0,"stats":{"Line":3}},{"line":30,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":1}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":2}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":4}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":4}},{"line":179,"address":[],"length":0,"stats":{"Line":4}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":4}},{"line":192,"address":[],"length":0,"stats":{"Line":4}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":198,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":8}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":8}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":4}},{"line":226,"address":[],"length":0,"stats":{"Line":4}},{"line":227,"address":[],"length":0,"stats":{"Line":4}},{"line":228,"address":[],"length":0,"stats":{"Line":4}},{"line":229,"address":[],"length":0,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":4}},{"line":241,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":8}},{"line":245,"address":[],"length":0,"stats":{"Line":8}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":4}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":282,"address":[],"length":0,"stats":{"Line":4}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":284,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":4}},{"line":304,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":4}}],"covered":70,"coverable":104},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","phase.rs"],"content":"use metis_core::{transition_phase, validate_exit_criteria};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n#[mcp_tool(\n    name = \"transition_phase\",\n    description = \"Transition a document to a new phase\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct TransitionPhaseTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// New phase to transition to\n    pub new_phase: String,\n\n    /// Force transition even if exit criteria aren't met\n    pub force: Option\u003cbool\u003e,\n}\n\nimpl TransitionPhaseTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n        let force = self.force.unwrap_or(false);\n\n        match transition_phase(\u0026document_path, \u0026self.new_phase, force).await {\n            Ok(_) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Document transitioned to phase '{}' successfully\", self.new_phase),\n                    \"document_path\": self.document_path,\n                    \"new_phase\": self.new_phase,\n                    \"project_path\": self.project_path,\n                    \"force\": force\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to transition phase: {}\", e),\n                    \"document_path\": self.document_path,\n                    \"new_phase\": self.new_phase,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"check_phase_transition\",\n    description = \"Check if a document can transition to a new phase\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct CheckPhaseTransitionTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// Phase to check transition to\n    pub target_phase: String,\n}\n\nimpl CheckPhaseTransitionTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        // Note: can_transition_phase function doesn't exist in metis-core, using validate_exit_criteria instead\n        match validate_exit_criteria(\u0026document_path).await {\n            Ok(validation_result) =\u003e {\n                let can_transition = validation_result.met;\n                let response = serde_json::json!({\n                    \"can_transition\": can_transition,\n                    \"message\": if can_transition {\n                        format!(\"Document can transition to phase '{}'\", self.target_phase)\n                    } else {\n                        format!(\"Document cannot transition to phase '{}' - exit criteria not met\", self.target_phase)\n                    },\n                    \"document_path\": self.document_path,\n                    \"target_phase\": self.target_phase,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to check phase transition: {}\", e),\n                    \"document_path\": self.document_path,\n                    \"target_phase\": self.target_phase,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"validate_exit_criteria\",\n    description = \"Validate if a document's exit criteria are completed\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct ValidateExitCriteriaTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n}\n\nimpl ValidateExitCriteriaTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        match validate_exit_criteria(\u0026document_path).await {\n            Ok(validation_result) =\u003e {\n                let response = serde_json::json!({\n                    \"is_complete\": validation_result.met,\n                    \"total_criteria\": validation_result.total_criteria,\n                    \"completed_criteria\": validation_result.completed_criteria,\n                    \"missing_criteria\": validation_result.missing_criteria,\n                    \"message\": if validation_result.met {\n                        \"All exit criteria are completed\"\n                    } else {\n                        \"Some exit criteria are still pending\"\n                    },\n                    \"document_path\": self.document_path,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to validate exit criteria: {}\", e),\n                    \"document_path\": self.document_path,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":75},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","project.rs"],"content":"use metis_core::{initialize_project, ProjectConfig};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n// list_projects tool removed - direct path approach doesn't need project discovery\n\n#[mcp_tool(\n    name = \"initialize_project\",\n    description = \"Initialize a new Metis project by creating a 'metis' subdirectory at the specified path\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct InitializeProjectTool {\n    /// Path where the 'metis' subdirectory will be created (e.g., \"/path/to/my-project\" creates \"/path/to/my-project/metis/\")\n    pub project_path: String,\n\n    /// Name of the project\n    pub project_name: String,\n\n    /// Optional description for the project\n    pub description: Option\u003cString\u003e,\n}\n\nimpl InitializeProjectTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let base_path = PathBuf::from(\u0026self.project_path);\n\n        let config = ProjectConfig {\n            root_path: base_path,\n            name: self.project_name.clone(),\n            description: self.description.clone(),\n        };\n\n        match initialize_project(config).await {\n            Ok(metadata) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Project '{}' initialized successfully\", self.project_name),\n                    \"project_path\": metadata.project_path,\n                    \"database_path\": metadata.database_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to initialize project '{}': {}\", self.project_name, e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":30}},{"line":33,"address":[],"length":0,"stats":{"Line":10}},{"line":37,"address":[],"length":0,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":10}},{"line":41,"address":[],"length":0,"stats":{"Line":10}},{"line":42,"address":[],"length":0,"stats":{"Line":10}},{"line":43,"address":[],"length":0,"stats":{"Line":10}},{"line":44,"address":[],"length":0,"stats":{"Line":10}},{"line":45,"address":[],"length":0,"stats":{"Line":10}},{"line":46,"address":[],"length":0,"stats":{"Line":10}},{"line":49,"address":[],"length":0,"stats":{"Line":10}},{"line":50,"address":[],"length":0,"stats":{"Line":10}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}}],"covered":13,"coverable":19},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","query.rs"],"content":"use chrono::{DateTime, Utc};\nuse metis_core::{Document, DocumentStore, DocumentType, SearchResult};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse std::str::FromStr;\n\n/// Document summary without content field for list operations\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DocumentSummary {\n    pub id: String,\n    pub filepath: String,\n    pub document_type: DocumentType,\n    pub level: DocumentType,\n    pub status: String,\n    pub parent_id: Option\u003cString\u003e,\n    pub created_at: DateTime\u003cUtc\u003e,\n    pub updated_at: DateTime\u003cUtc\u003e,\n    pub content_hash: String,\n    pub frontmatter: serde_json::Value,\n    pub exit_criteria_met: bool,\n    pub file_size: Option\u003ci64\u003e,\n    pub file_modified_at: Option\u003cf64\u003e,\n}\n\nimpl From\u003cDocument\u003e for DocumentSummary {\n    fn from(doc: Document) -\u003e Self {\n        Self {\n            id: doc.id,\n            filepath: doc.filepath,\n            document_type: doc.document_type,\n            level: doc.level,\n            status: doc.status,\n            parent_id: doc.parent_id,\n            created_at: doc.created_at,\n            updated_at: doc.updated_at,\n            content_hash: doc.content_hash,\n            frontmatter: doc.frontmatter,\n            exit_criteria_met: doc.exit_criteria_met,\n            file_size: doc.file_size,\n            file_modified_at: doc.file_modified_at,\n        }\n    }\n}\n\n/// Search result summary without content field for search operations\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SearchResultSummary {\n    pub document: DocumentSummary,\n    pub rank: f64,\n    pub snippet: String,\n}\n\nimpl From\u003cSearchResult\u003e for SearchResultSummary {\n    fn from(result: SearchResult) -\u003e Self {\n        Self {\n            document: DocumentSummary::from(result.document),\n            rank: result.rank,\n            snippet: result.snippet,\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"list_documents\",\n    description = \"List documents in a project with optional filtering\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct ListDocumentsTool {\n    /// Path to the .metis folder to list documents from\n    pub project_path: String,\n\n    /// Filter by document type (vision, strategy, initiative, task, adr)\n    pub document_type: Option\u003cString\u003e,\n\n    /// Filter by phase (draft, review, published, etc.)\n    pub phase: Option\u003cString\u003e,\n\n    /// Maximum number of results to return\n    pub limit: Option\u003cu32\u003e,\n}\n\nimpl ListDocumentsTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let db_path = project_path.join(\".metis.db\");\n\n        match DocumentStore::new(db_path.to_str().unwrap()).await {\n            Ok(store) =\u003e {\n                let query_service = store.query_service();\n\n                // Parse document type filter if provided\n                let doc_type_filter = if let Some(type_str) = \u0026self.document_type {\n                    match DocumentType::from_str(type_str) {\n                        Ok(doc_type) =\u003e Some(doc_type),\n                        Err(_) =\u003e return Ok(CallToolResult::text_content(\n                            vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                                \"error\": format!(\"Invalid document type '{}'. Must be: vision, strategy, initiative, task, adr\", type_str)\n                            })).map_err(CallToolError::new)?)]\n                        ))\n                    }\n                } else {\n                    None\n                };\n\n                // Query documents\n                let documents =\n                    if let Some(doc_type) = doc_type_filter {\n                        match query_service.find_documents_by_type(doc_type).await {\n                            Ok(docs) =\u003e docs,\n                            Err(e) =\u003e {\n                                return Ok(CallToolResult::text_content(vec![TextContent::from(\n                                    serde_json::to_string_pretty(\u0026serde_json::json!({\n                                        \"error\": format!(\"Failed to query documents: {}\", e)\n                                    }))\n                                    .map_err(CallToolError::new)?,\n                                )]))\n                            }\n                        }\n                    } else if let Some(phase) = \u0026self.phase {\n                        match query_service.find_documents_by_phase(phase).await {\n                        Ok(docs) =\u003e docs,\n                        Err(e) =\u003e return Ok(CallToolResult::text_content(\n                            vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                                \"error\": format!(\"Failed to query documents by phase: {}\", e)\n                            })).map_err(CallToolError::new)?)]\n                        ))\n                    }\n                    } else {\n                        // List all documents - use a generic query approach\n                        match query_service\n                            .find_documents_by_type(DocumentType::Vision)\n                            .await\n                        {\n                            Ok(mut all_docs) =\u003e {\n                                // Get documents of other types and combine\n                                for doc_type in [\n                                    DocumentType::Strategy,\n                                    DocumentType::Initiative,\n                                    DocumentType::Task,\n                                    DocumentType::Adr,\n                                ] {\n                                    if let Ok(docs) =\n                                        query_service.find_documents_by_type(doc_type).await\n                                    {\n                                        all_docs.extend(docs);\n                                    }\n                                }\n                                all_docs\n                            }\n                            Err(e) =\u003e {\n                                return Ok(CallToolResult::text_content(vec![TextContent::from(\n                                    serde_json::to_string_pretty(\u0026serde_json::json!({\n                                        \"error\": format!(\"Failed to query documents: {}\", e)\n                                    }))\n                                    .map_err(CallToolError::new)?,\n                                )]))\n                            }\n                        }\n                    };\n\n                // Apply limit if specified and convert to summaries\n                let limited_docs: Vec\u003cDocumentSummary\u003e = if let Some(limit) = self.limit {\n                    documents\n                        .into_iter()\n                        .take(limit as usize)\n                        .map(DocumentSummary::from)\n                        .collect()\n                } else {\n                    documents.into_iter().map(DocumentSummary::from).collect()\n                };\n\n                let response = serde_json::json!({\n                    \"message\": format!(\"Found {} documents\", limited_docs.len()),\n                    \"documents\": limited_docs,\n                    \"project_path\": self.project_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to connect to database: {}\", e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"search_documents\",\n    description = \"Search documents by content with optional filtering\",\n    idempotent_hint = true,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = true\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct SearchDocumentsTool {\n    /// Path to the .metis folder to search documents in\n    pub project_path: String,\n\n    /// Search query to match against document content\n    pub query: String,\n\n    /// Filter by document type (vision, strategy, initiative, task, adr)\n    pub document_type: Option\u003cString\u003e,\n\n    /// Maximum number of results to return\n    pub limit: Option\u003cu32\u003e,\n}\n\nimpl SearchDocumentsTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let db_path = project_path.join(\".metis.db\");\n\n        match DocumentStore::new(db_path.to_str().unwrap()).await {\n            Ok(store) =\u003e {\n                let query_service = store.query_service();\n\n                // Perform the search with a reasonable default limit\n                let limit = self.limit.unwrap_or(100) as usize;\n                match query_service.search_content(\u0026self.query, limit).await {\n                    Ok(documents) =\u003e {\n                        // Filter by document type if specified\n                        let filtered_docs = if let Some(type_str) = \u0026self.document_type {\n                            match DocumentType::from_str(type_str) {\n                                Ok(doc_type) =\u003e {\n                                    documents.into_iter()\n                                        .filter(|doc| doc.document.document_type == doc_type)\n                                        .collect()\n                                }\n                                Err(_) =\u003e return Ok(CallToolResult::text_content(\n                                    vec![TextContent::from(serde_json::to_string_pretty(\u0026serde_json::json!({\n                                        \"error\": format!(\"Invalid document type '{}'. Must be: vision, strategy, initiative, task, adr\", type_str)\n                                    })).map_err(CallToolError::new)?)]\n                                ))\n                            }\n                        } else {\n                            documents\n                        };\n\n                        // Apply limit if specified and convert to summaries\n                        let limited_docs: Vec\u003cSearchResultSummary\u003e = if let Some(limit) = self.limit\n                        {\n                            filtered_docs\n                                .into_iter()\n                                .take(limit as usize)\n                                .map(SearchResultSummary::from)\n                                .collect()\n                        } else {\n                            filtered_docs\n                                .into_iter()\n                                .map(SearchResultSummary::from)\n                                .collect()\n                        };\n\n                        let response = serde_json::json!({\n                            \"message\": format!(\"Found {} documents matching '{}'\", limited_docs.len(), self.query),\n                            \"documents\": limited_docs,\n                            \"query\": self.query,\n                            \"project_path\": self.project_path\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                        )]))\n                    }\n                    Err(e) =\u003e {\n                        let error_response = serde_json::json!({\n                            \"error\": format!(\"Search failed: {}\", e)\n                        });\n\n                        Ok(CallToolResult::text_content(vec![TextContent::from(\n                            serde_json::to_string_pretty(\u0026error_response)\n                                .map_err(CallToolError::new)?,\n                        )]))\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to connect to database: {}\", e)\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":137,"address":[],"length":0,"stats":{"Line":16}},{"line":138,"address":[],"length":0,"stats":{"Line":32}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":2}},{"line":214,"address":[],"length":0,"stats":{"Line":2}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":2}},{"line":221,"address":[],"length":0,"stats":{"Line":2}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}}],"covered":42,"coverable":112},{"path":["/","Users","dstorey","Desktop","colliery","metis","crates","metis-mcp-server","src","tools","update.rs"],"content":"use metis_core::{update_blocked_by, update_document_content, update_exit_criterion};\nuse rust_mcp_sdk::{\n    macros::{mcp_tool, JsonSchema},\n    schema::{schema_utils::CallToolError, CallToolResult, TextContent},\n};\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n#[mcp_tool(\n    name = \"update_document_content\",\n    description = \"Update content of a specific H2 section in a document\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct UpdateDocumentContentTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// Section heading to update - must be an H2 level heading (e.g., \"Problem Statement\" targets \"## Problem Statement\")\n    pub section_heading: String,\n\n    /// New content for the section\n    pub new_content: String,\n}\n\nimpl UpdateDocumentContentTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        match update_document_content(\u0026document_path, \u0026self.section_heading, \u0026self.new_content)\n            .await\n        {\n            Ok(_) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Successfully updated section '{}' in document\", self.section_heading),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"section_heading\": self.section_heading\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to update document content: {}\", e),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"section_heading\": self.section_heading\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"update_exit_criterion\",\n    description = \"Update the completion status of an exit criterion\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct UpdateExitCriterionTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// Title of the exit criterion to update\n    pub criterion_title: String,\n\n    /// New completion status (true/false)\n    pub completed: bool,\n\n    /// Optional notes or evidence for the completion\n    pub notes: Option\u003cString\u003e,\n}\n\nimpl UpdateExitCriterionTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        match update_exit_criterion(\u0026document_path, \u0026self.criterion_title, self.completed).await {\n            Ok(_) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Successfully updated exit criterion '{}' to {}\",\n                        self.criterion_title,\n                        if self.completed { \"completed\" } else { \"pending\" }\n                    ),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"criterion_title\": self.criterion_title,\n                    \"completed\": self.completed\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to update exit criterion: {}\", e),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"criterion_title\": self.criterion_title\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n\n#[mcp_tool(\n    name = \"update_blocked_by\",\n    description = \"Update the blocked_by relationship for a document\",\n    idempotent_hint = false,\n    destructive_hint = false,\n    open_world_hint = false,\n    read_only_hint = false\n)]\n#[derive(Debug, Serialize, Deserialize, JsonSchema)]\npub struct UpdateBlockedByTool {\n    /// Path to the .metis folder containing the document\n    pub project_path: String,\n\n    /// Path to the document file (relative to project root)\n    pub document_path: String,\n\n    /// List of document titles that this document is blocked by\n    pub blocked_by: Vec\u003cString\u003e,\n}\n\nimpl UpdateBlockedByTool {\n    pub async fn call_tool(\u0026self) -\u003e std::result::Result\u003cCallToolResult, CallToolError\u003e {\n        let project_path = PathBuf::from(\u0026self.project_path);\n        let document_path = project_path.join(\u0026self.document_path);\n\n        match update_blocked_by(\u0026document_path, self.blocked_by.clone()).await {\n            Ok(_) =\u003e {\n                let response = serde_json::json!({\n                    \"message\": format!(\"Successfully updated blocked_by for document (now blocked by {} items)\", self.blocked_by.len()),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path,\n                    \"blocked_by\": self.blocked_by\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026response).map_err(CallToolError::new)?,\n                )]))\n            }\n            Err(e) =\u003e {\n                let error_response = serde_json::json!({\n                    \"error\": format!(\"Failed to update blocked_by: {}\", e),\n                    \"project_path\": self.project_path,\n                    \"document_path\": self.document_path\n                });\n\n                Ok(CallToolResult::text_content(vec![TextContent::from(\n                    serde_json::to_string_pretty(\u0026error_response).map_err(CallToolError::new)?,\n                )]))\n            }\n        }\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":35,"address":[],"length":0,"stats":{"Line":1}},{"line":37,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}}],"covered":13,"coverable":65}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>