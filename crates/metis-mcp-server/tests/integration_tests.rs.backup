use metis_mcp_server::tools::{MetisTools, InitializeProjectTool, CreateDocumentTool, ListDocumentsTool, SearchDocumentsTool, UpdateDocumentContentTool, UpdateExitCriterionTool, UpdateBlockedByTool, TransitionPhaseTool, CheckPhaseTransitionTool, ValidateExitCriteriaTool, ValidateDocumentTool};
use tempfile::TempDir;
use tokio::fs;
use sqlx::{SqlitePool, Row};

/// Test that MCP server tools are available
#[tokio::test]
async fn test_tools_available() {
    let tools = MetisTools::tools();
    
    // Verify we get tools back
    assert!(tools.len() > 0);
    
    // Verify key tools exist
    let tool_names: Vec<&str> = tools.iter().map(|t| t.name.as_str()).collect();
    assert!(tool_names.contains(&"initialize_project"));
    assert!(tool_names.contains(&"create_document"));
    assert!(tool_names.contains(&"list_documents"));
    assert!(tool_names.contains(&"search_documents"));
    assert!(tool_names.contains(&"update_document_content"));
    assert!(tool_names.contains(&"update_exit_criterion"));
    assert!(tool_names.contains(&"update_blocked_by"));
    assert!(tool_names.contains(&"transition_phase"));
    assert!(tool_names.contains(&"validate_exit_criteria"));
    assert!(tool_names.contains(&"validate_document"));
}

/// Test initialize project tool directly
#[tokio::test]
async fn test_initialize_project_tool() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    let tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "test-project".to_string(),
        description: Some("Test project".to_string()),
    };
    
    let result = tool.call_tool().await;
    
    if let Err(e) = &result {
        println!("Tool call failed: {:?}", e);
    }
    
    assert!(result.is_ok());
    
    // Print what was actually created for debugging
    let path = temp_dir.path();
    println!("Project path: {:?}", path);
    if let Ok(entries) = std::fs::read_dir(path) {
        for entry in entries {
            if let Ok(entry) = entry {
                println!("Created: {:?}", entry.file_name());
            }
        }
    }
    
    // Verify project structure was created in metis subdirectory
    assert!(path.join("metis").join("strategies").exists(), "strategies directory not found");
    assert!(path.join("metis").join("decisions").exists(), "decisions directory not found");
    assert!(path.join("metis").join(".metis.db").exists(), "database file not found");
    assert!(path.join("metis").join("vision.md").exists(), "vision document not found");
}

/// Test create document tool
#[tokio::test]
async fn test_create_document_tool() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // First initialize the project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "test-project".to_string(),
        description: Some("Test project".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Create a strategy document
    let create_tool = CreateDocumentTool {
        project_path: project_path.clone(),
        document_type: "strategy".to_string(),
        title: "Test Strategy".to_string(),
        parent_title: Some("test-project".to_string()),
        risk_level: Some("medium".to_string()),
        complexity: None,
        decision_maker: None,
        stakeholders: None,
    };
    
    let result = create_tool.call_tool().await;
    
    match &result {
        Ok(call_result) => {
            println!("Create document succeeded: {:?}", call_result);
        }
        Err(e) => {
            println!("Create document failed: {:?}", e);
        }
    }
    
    assert!(result.is_ok(), "Document creation failed");
    
    // Verify strategy document was created
    let strategies_dir = temp_dir.path().join("strategies");
    assert!(strategies_dir.exists(), "strategies directory not found");
    
    // Check that some strategy file was created (just check if any .md files exist in subdirs)
    let mut strategy_files = Vec::new();
    
    if let Ok(mut entries) = fs::read_dir(&strategies_dir).await {
        while let Some(entry) = entries.next_entry().await.unwrap_or(None) {
            let path = entry.path();
            if path.is_dir() {
                // Check inside subdirectory for .md files
                if let Ok(mut sub_entries) = fs::read_dir(&path).await {
                    while let Some(sub_entry) = sub_entries.next_entry().await.unwrap_or(None) {
                        let sub_path = sub_entry.path();
                        if sub_path.extension().and_then(|s| s.to_str()) == Some("md") {
                            strategy_files.push(sub_path.to_string_lossy().to_string());
                        }
                    }
                }
            } else if path.extension().and_then(|s| s.to_str()) == Some("md") {
                strategy_files.push(path.to_string_lossy().to_string());
            }
        }
    }
    
    let strategy_files = strategy_files;
    assert!(!strategy_files.is_empty(), "No strategy files created");
    println!("Created strategy files: {:?}", strategy_files);
}

/// Test list documents tool
#[tokio::test]
async fn test_list_documents_tool() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "list-test".to_string(),
        description: Some("Test project for listing".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Create a few documents
    let create_strategy = CreateDocumentTool {
        project_path: project_path.clone(),
        document_type: "strategy".to_string(),
        title: "Test Strategy".to_string(),
        parent_title: Some("list-test".to_string()),
        risk_level: Some("low".to_string()),
        complexity: None,
        decision_maker: None,
        stakeholders: None,
    };
    
    let strategy_result = create_strategy.call_tool().await;
    assert!(strategy_result.is_ok(), "Strategy creation failed");
    
    // List all documents
    let list_tool = ListDocumentsTool {
        project_path: project_path.clone(),
        document_type: None,
        phase: None,
        limit: None,
    };
    
    let list_result = list_tool.call_tool().await;
    
    match &list_result {
        Ok(call_result) => {
            println!("List documents succeeded: {:?}", call_result);
        }
        Err(e) => {
            println!("List documents failed: {:?}", e);
        }
    }
    
    assert!(list_result.is_ok(), "Document listing failed");
    
    // Test filtering by document type
    let list_strategies = ListDocumentsTool {
        project_path: project_path.clone(),
        document_type: Some("strategy".to_string()),
        phase: None,
        limit: Some(10),
    };
    
    let strategies_result = list_strategies.call_tool().await;
    assert!(strategies_result.is_ok(), "Strategy listing failed");
    
    if let Ok(call_result) = &strategies_result {
        // Should have content indicating strategies were found
        assert!(call_result.content.len() > 0);
    }
}

/// Test search documents tool
#[tokio::test]
async fn test_search_documents_tool() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "search-test".to_string(),
        description: Some("Test project for searching".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Create a document with specific content
    let create_tool = CreateDocumentTool {
        project_path: project_path.clone(),
        document_type: "strategy".to_string(),
        title: "API Integration Strategy".to_string(),
        parent_title: Some("search-test".to_string()),
        risk_level: Some("medium".to_string()),
        complexity: None,
        decision_maker: None,
        stakeholders: None,
    };
    
    let create_result = create_tool.call_tool().await;
    assert!(create_result.is_ok(), "Document creation failed");
    
    // Search for documents
    let search_tool = SearchDocumentsTool {
        project_path: project_path.clone(),
        query: "integration".to_string(),
        document_type: None,
        limit: None,
    };
    
    let search_result = search_tool.call_tool().await;
    
    match &search_result {
        Ok(call_result) => {
            println!("Search documents succeeded: {:?}", call_result);
        }
        Err(e) => {
            println!("Search documents failed: {:?}", e);
        }
    }
    
    assert!(search_result.is_ok(), "Document search failed");
    
    // Test searching with document type filter
    let filtered_search = SearchDocumentsTool {
        project_path: project_path.clone(),
        query: "strategy".to_string(),
        document_type: Some("strategy".to_string()),
        limit: Some(5),
    };
    
    let filtered_result = filtered_search.call_tool().await;
    assert!(filtered_result.is_ok(), "Filtered search failed");
}

/// Test update document content tool
#[tokio::test]
async fn test_update_document_content_tool() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "update-test".to_string(),
        description: Some("Test project for content updates".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Create a strategy document
    let create_tool = CreateDocumentTool {
        project_path: project_path.clone(),
        document_type: "strategy".to_string(),
        title: "Update Test Strategy".to_string(),
        parent_title: Some("update-test".to_string()),
        risk_level: Some("low".to_string()),
        complexity: None,
        decision_maker: None,
        stakeholders: None,
    };
    
    let create_result = create_tool.call_tool().await;
    assert!(create_result.is_ok(), "Strategy creation failed");
    
    // Update a section in the document
    let update_tool = UpdateDocumentContentTool {
        project_path: project_path.clone(),
        document_path: "strategies/update-test-strategy/strategy.md".to_string(),
        section_heading: "Problem Statement".to_string(),
        new_content: "This is the updated problem statement.\n\nWith additional details about the specific challenges we face.".to_string(),
    };
    
    let update_result = update_tool.call_tool().await;
    
    match &update_result {
        Ok(call_result) => {
            println!("Update document content succeeded: {:?}", call_result);
        }
        Err(e) => {
            println!("Update document content failed: {:?}", e);
        }
    }
    
    assert!(update_result.is_ok(), "Document content update failed");
}

/// Test validate document tool
#[tokio::test]
async fn test_validate_document_tool() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "validate-test".to_string(),
        description: Some("Test project for validation".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Validate the vision document that was created during initialization
    let validate_tool = ValidateDocumentTool {
        project_path: project_path.clone(),
        document_path: "vision.md".to_string(),
    };
    
    let validate_result = validate_tool.call_tool().await;
    
    match &validate_result {
        Ok(call_result) => {
            println!("Validate document succeeded: {:?}", call_result);
        }
        Err(e) => {
            println!("Validate document failed: {:?}", e);
        }
    }
    
    assert!(validate_result.is_ok(), "Document validation failed");
}

/// Test update exit criterion tool
#[tokio::test]
async fn test_update_exit_criterion_tool() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "exit-test".to_string(),
        description: Some("Test project for exit criteria".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Update an exit criterion in the vision document
    let update_tool = UpdateExitCriterionTool {
        project_path: project_path.clone(),
        document_path: "vision.md".to_string(),
        criterion_title: "Purpose and success criteria are clearly defined".to_string(),
        completed: true,
        notes: Some("Test completion".to_string()),
    };
    
    let update_result = update_tool.call_tool().await;
    
    match &update_result {
        Ok(call_result) => {
            println!("Update exit criterion succeeded: {:?}", call_result);
        }
        Err(e) => {
            println!("Update exit criterion failed: {:?}", e);
        }
    }
    
    assert!(update_result.is_ok(), "Exit criterion update failed");
}

/// Test update blocked by tool
#[tokio::test]
async fn test_update_blocked_by_tool() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "blocked-test".to_string(),
        description: Some("Test project for blocked_by".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Update blocked_by relationships
    let update_tool = UpdateBlockedByTool {
        project_path: project_path.clone(),
        document_path: "vision.md".to_string(),
        blocked_by: vec![
            "[[Strategy Document]]".to_string(),
            "[[Initial Requirements]]".to_string(),
        ],
    };
    
    let update_result = update_tool.call_tool().await;
    
    match &update_result {
        Ok(call_result) => {
            println!("Update blocked_by succeeded: {:?}", call_result);
        }
        Err(e) => {
            println!("Update blocked_by failed: {:?}", e);
        }
    }
    
    assert!(update_result.is_ok(), "Blocked_by update failed");
}

/// Test validate exit criteria tool
#[tokio::test]
async fn test_validate_exit_criteria_tool() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "criteria-test".to_string(),
        description: Some("Test project for exit criteria validation".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Validate exit criteria on vision document
    let validate_tool = ValidateExitCriteriaTool {
        project_path: project_path.clone(),
        document_path: "vision.md".to_string(),
    };
    
    let validate_result = validate_tool.call_tool().await;
    
    match &validate_result {
        Ok(call_result) => {
            println!("Validate exit criteria succeeded: {:?}", call_result);
            // Should show some criteria not met since we haven't completed them
        }
        Err(e) => {
            println!("Validate exit criteria failed: {:?}", e);
        }
    }
    
    assert!(validate_result.is_ok(), "Exit criteria validation failed");
}

/// Test phase transition tools
#[tokio::test]
async fn test_phase_transition_tools() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "phase-test".to_string(),
        description: Some("Test project for phase transitions".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Create a task document (starts in draft phase)
    let create_tool = CreateDocumentTool {
        project_path: project_path.clone(),
        document_type: "task".to_string(),
        title: "Phase Transition Test Task".to_string(),
        parent_title: Some("phase-test".to_string()),
        risk_level: None,
        complexity: None,
        decision_maker: None,
        stakeholders: None,
    };
    
    let create_result = create_tool.call_tool().await;
    assert!(create_result.is_ok(), "Task creation failed");
    
    // Test check phase transition
    let check_tool = CheckPhaseTransitionTool {
        project_path: project_path.clone(),
        document_path: "tasks/phase-transition-test-task/task.md".to_string(),
        target_phase: "active".to_string(),
    };
    
    let check_result = check_tool.call_tool().await;
    
    match &check_result {
        Ok(call_result) => {
            println!("Check phase transition succeeded: {:?}", call_result);
        }
        Err(e) => {
            println!("Check phase transition failed: {:?}", e);
        }
    }
    
    assert!(check_result.is_ok(), "Phase transition check failed");
    
    // Test transition phase
    let transition_tool = TransitionPhaseTool {
        project_path: project_path.clone(),
        document_path: "tasks/phase-transition-test-task/task.md".to_string(),
        new_phase: "active".to_string(),
        force: Some(true), // Force transition without exit criteria
    };
    
    let transition_result = transition_tool.call_tool().await;
    
    match &transition_result {
        Ok(call_result) => {
            println!("Transition phase succeeded: {:?}", call_result);
        }
        Err(e) => {
            println!("Transition phase failed: {:?}", e);
        }
    }
    
    assert!(transition_result.is_ok(), "Phase transition failed");
}

/// Test sync engine's ability to insert documents to database after initialization
#[tokio::test]
async fn test_sync_engine_document_insertion() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "sync-test".to_string(),
        description: Some("Test project for sync engine".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // The vision document should already be synced during initialization
    // Let's verify it exists in the database by listing documents
    let list_tool = ListDocumentsTool {
        project_path: project_path.clone() + "/metis",
        document_type: Some("vision".to_string()),
        phase: None,
        limit: None,
    };
    
    let list_result = list_tool.call_tool().await;
    assert!(list_result.is_ok(), "Failed to list documents");
    
    // Create a strategy document with parent reference to vision
    let create_strategy = CreateDocumentTool {
        project_path: project_path.clone() + "/metis",
        document_type: "strategy".to_string(),
        title: "Sync Test Strategy".to_string(),
        parent_title: Some("sync-test".to_string()),
        risk_level: Some("low".to_string()),
        complexity: None,
        decision_maker: None,
        stakeholders: None,
    };
    
    let strategy_result = create_strategy.call_tool().await;
    assert!(strategy_result.is_ok(), "Strategy creation failed");
    
    // Create an initiative with parent reference to strategy
    let create_initiative = CreateDocumentTool {
        project_path: project_path.clone() + "/metis",
        document_type: "initiative".to_string(),
        title: "Sync Test Initiative".to_string(),
        parent_title: Some("Sync Test Strategy".to_string()),
        risk_level: None,
        complexity: Some("m".to_string()),
        decision_maker: None,
        stakeholders: None,
    };
    
    let initiative_result = create_initiative.call_tool().await;
    assert!(initiative_result.is_ok(), "Initiative creation failed");
    
    // Create a task with parent reference to initiative
    let create_task = CreateDocumentTool {
        project_path: project_path.clone() + "/metis",
        document_type: "task".to_string(),
        title: "Sync Test Task".to_string(),
        parent_title: Some("Sync Test Initiative".to_string()),
        risk_level: None,
        complexity: None,
        decision_maker: None,
        stakeholders: None,
    };
    
    let task_result = create_task.call_tool().await;
    assert!(task_result.is_ok(), "Task creation failed");
    
    // List all documents to verify they were synced
    let list_all = ListDocumentsTool {
        project_path: project_path.clone() + "/metis",
        document_type: None,
        phase: None,
        limit: None,
    };
    
    let all_docs_result = list_all.call_tool().await;
    assert!(all_docs_result.is_ok(), "Failed to list all documents");
    
    // Search for documents to verify sync worked
    let search_tool = SearchDocumentsTool {
        project_path: project_path.clone() + "/metis",
        query: "Sync Test".to_string(),
        document_type: None,
        limit: None,
    };
    
    let search_result = search_tool.call_tool().await;
    assert!(search_result.is_ok(), "Document search failed");
}

/// Test sync engine handling of documents with empty parent field
#[tokio::test]
async fn test_sync_engine_empty_parent_handling() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "empty-parent-test".to_string(),
        description: Some("Test empty parent handling".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Create an ADR (Architecture Decision Record) with no parent
    let create_adr = CreateDocumentTool {
        project_path: project_path.clone() + "/metis",
        document_type: "adr".to_string(),
        title: "Use SQLite for Storage".to_string(),
        parent_title: None, // No parent for ADRs
        risk_level: None,
        complexity: None,
        decision_maker: Some("Tech Lead".to_string()),
        stakeholders: Some(vec!["Dev Team".to_string(), "Ops Team".to_string()]),
    };
    
    let adr_result = create_adr.call_tool().await;
    assert!(adr_result.is_ok(), "ADR creation failed");
    
    // Create another top-level vision document
    let vision_path = temp_dir.path().join("metis").join("another-vision.md");
    let vision_content = r##"---
id: another-vision
level: vision
status: draft
tags:
  - "#phase/draft"
parent:
created_at: 2025-07-05T10:00:00Z
updated_at: 2025-07-05T10:00:00Z
exit_criteria_met: false
---

# Another Vision

This is a vision document with an empty parent field."##;
    
    fs::write(&vision_path, vision_content).await.expect("Failed to write vision file");
    
    // List documents to trigger sync
    let list_tool = ListDocumentsTool {
        project_path: project_path.clone() + "/metis",
        document_type: None,
        phase: None,
        limit: None,
    };
    
    let list_result = list_tool.call_tool().await;
    assert!(list_result.is_ok(), "Failed to list documents after creating files with empty parents");
}

/// Test sync engine handling of documents with blocked_by relationships
#[tokio::test]
async fn test_sync_engine_blocked_by_handling() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "blocked-test".to_string(),
        description: Some("Test blocked_by relationships".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Create a strategy
    let create_strategy = CreateDocumentTool {
        project_path: project_path.clone() + "/metis",
        document_type: "strategy".to_string(),
        title: "Infrastructure Strategy".to_string(),
        parent_title: Some("blocked-test".to_string()),
        risk_level: Some("medium".to_string()),
        complexity: None,
        decision_maker: None,
        stakeholders: None,
    };
    
    let strategy_result = create_strategy.call_tool().await;
    assert!(strategy_result.is_ok(), "Strategy creation failed");
    
    // Create an initiative that will be blocked
    let create_initiative = CreateDocumentTool {
        project_path: project_path.clone() + "/metis",
        document_type: "initiative".to_string(),
        title: "Cloud Migration".to_string(),
        parent_title: Some("Infrastructure Strategy".to_string()),
        risk_level: None,
        complexity: Some("l".to_string()),
        decision_maker: None,
        stakeholders: None,
    };
    
    let initiative_result = create_initiative.call_tool().await;
    assert!(initiative_result.is_ok(), "Initiative creation failed");
    
    // Update the initiative to be blocked by other documents
    let update_blocked = UpdateBlockedByTool {
        project_path: project_path.clone() + "/metis",
        document_path: "initiatives/cloud-migration/initiative.md".to_string(),
        blocked_by: vec![
            "[[Security Audit]]".to_string(),
            "[[Budget Approval]]".to_string(),
        ],
    };
    
    let blocked_result = update_blocked.call_tool().await;
    assert!(blocked_result.is_ok(), "Failed to update blocked_by");
    
    // Create a document with empty blocked_by
    let task_path = temp_dir.path().join("metis").join("tasks").join("test-task");
    fs::create_dir_all(&task_path).await.expect("Failed to create task directory");
    
    let task_content = r##"---
id: test-task-empty-blocked
level: task
status: todo
tags:
  - "#phase/draft"
parent: Cloud Migration
blocked_by:
created_at: 2025-07-05T10:00:00Z
updated_at: 2025-07-05T10:00:00Z
exit_criteria_met: false
---

# Test Task

This task has an empty blocked_by field."##;
    
    fs::write(task_path.join("task.md"), task_content).await.expect("Failed to write task file");
    
    // List documents to trigger sync
    let list_tool = ListDocumentsTool {
        project_path: project_path.clone() + "/metis",
        document_type: None,
        phase: None,
        limit: None,
    };
    
    let list_result = list_tool.call_tool().await;
    assert!(list_result.is_ok(), "Failed to list documents after blocked_by updates");
}

/// Test sync engine handling of foreign key constraints
#[tokio::test]
async fn test_sync_engine_foreign_key_constraints() {
    let temp_dir = TempDir::new().expect("Failed to create temp directory");
    let project_path = temp_dir.path().to_string_lossy().to_string();
    
    // Initialize project
    let init_tool = InitializeProjectTool {
        project_path: project_path.clone(),
        project_name: "fk-test".to_string(),
        description: Some("Test foreign key constraints".to_string()),
    };
    
    let init_result = init_tool.call_tool().await;
    assert!(init_result.is_ok(), "Project initialization failed");
    
    // Create a document with non-existent parent (should handle gracefully)
    let orphan_path = temp_dir.path().join("metis").join("strategies").join("orphan-strategy");
    fs::create_dir_all(&orphan_path).await.expect("Failed to create strategy directory");
    
    let orphan_content = r##"---
id: orphan-strategy
level: strategy
status: draft
tags:
  - "#phase/draft"
parent: non-existent-parent
created_at: 2025-07-05T10:00:00Z
updated_at: 2025-07-05T10:00:00Z
exit_criteria_met: false
---

# Orphan Strategy

This strategy references a non-existent parent."##;
    
    fs::write(orphan_path.join("strategy.md"), orphan_content).await.expect("Failed to write orphan strategy");
    
    // List documents to trigger sync - should handle the orphan gracefully
    let list_tool = ListDocumentsTool {
        project_path: project_path.clone() + "/metis",
        document_type: None,
        phase: None,
        limit: None,
    };
    
    let list_result = list_tool.call_tool().await;
    // The sync might fail due to foreign key constraint, but the tool should handle it
    // We're testing that the system doesn't crash
    match list_result {
        Ok(_) => println!("Sync handled orphan document gracefully"),
        Err(e) => println!("Sync reported error for orphan document: {:?}", e),
    }
    
    // Create documents in correct order (parent first)
    let parent_strategy = CreateDocumentTool {
        project_path: project_path.clone() + "/metis",
        document_type: "strategy".to_string(),
        title: "Parent Strategy".to_string(),
        parent_title: Some("fk-test".to_string()),
        risk_level: Some("low".to_string()),
        complexity: None,
        decision_maker: None,
        stakeholders: None,
    };
    
    let parent_result = parent_strategy.call_tool().await;
    assert!(parent_result.is_ok(), "Parent strategy creation failed");
    
    // Now create child with valid parent
    let child_initiative = CreateDocumentTool {
        project_path: project_path.clone() + "/metis",
        document_type: "initiative".to_string(),
        title: "Child Initiative".to_string(),
        parent_title: Some("Parent Strategy".to_string()),
        risk_level: None,
        complexity: Some("s".to_string()),
        decision_maker: None,
        stakeholders: None,
    };
    
    let child_result = child_initiative.call_tool().await;
    assert!(child_result.is_ok(), "Child initiative creation failed with valid parent");
    
    // Verify both documents exist
    let search_tool = SearchDocumentsTool {
        project_path: project_path.clone() + "/metis",
        query: "Strategy Initiative".to_string(),
        document_type: None,
        limit: None,
    };
    
    let search_result = search_tool.call_tool().await;
    assert!(search_result.is_ok(), "Search failed after creating parent-child documents");
}
