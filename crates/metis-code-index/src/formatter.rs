//! Markdown output formatter for code-index.md.
//!
//! Takes parsed symbols and file tree from the walker/extractors and produces
//! a flat markdown file with two sections: Project Structure and Modules.
//! Modules groups files by directory with co-located semantic summary slots
//! that are preserved across regenerations.

use std::collections::BTreeMap;
use std::fmt::Write;
use std::path::{Path, PathBuf};

use crate::symbols::{compact_signature, Symbol, Visibility};
use crate::walker::WalkResult;

/// Placeholder text for modules that haven't been summarized yet.
const SUMMARY_PLACEHOLDER: &str = "> *Semantic summary to be generated by AI agent.*";

/// Format a code index as markdown.
///
/// Takes the walk result and extracted symbols, producing a complete markdown
/// document suitable for `.metis/code-index.md`. If `existing_content` is
/// provided, any AI-generated semantic summaries from the previous version
/// are preserved in the new output.
pub fn format_index(
    walk_result: &WalkResult,
    symbols_by_file: &BTreeMap<PathBuf, Vec<Symbol>>,
    timestamp: &str,
    existing_content: Option<&str>,
) -> String {
    let existing_summaries = existing_content
        .map(parse_existing_summaries)
        .unwrap_or_default();

    let mut output = String::new();

    write_header(&mut output, walk_result, timestamp);
    write_project_structure(&mut output, walk_result);
    write_modules(&mut output, walk_result, symbols_by_file, &existing_summaries);

    output
}

/// Parse existing semantic summaries from a code-index.md file.
///
/// Returns a map of module path -> summary text. Only returns entries where
/// the summary has been written by the AI agent (not the placeholder text).
pub fn parse_existing_summaries(content: &str) -> BTreeMap<String, String> {
    let mut summaries = BTreeMap::new();
    let mut in_modules_section = false;
    let mut current_module: Option<String> = None;
    let mut current_summary = String::new();

    for line in content.lines() {
        // Track which top-level section we're in
        if line.starts_with("## ") && !line.starts_with("### ") {
            // Save any pending summary before switching sections
            if let Some(module) = current_module.take() {
                save_summary(&mut summaries, module, &current_summary);
            }
            in_modules_section = line.starts_with("## Modules");
            continue;
        }

        if !in_modules_section {
            continue;
        }

        if line.starts_with("### ") && !line.starts_with("#### ") {
            // New module heading — save previous
            if let Some(module) = current_module.take() {
                save_summary(&mut summaries, module, &current_summary);
            }
            current_module = Some(line[4..].trim().to_string());
            current_summary = String::new();
        } else if line.starts_with("#### ") {
            // Hit a file heading — save summary and stop collecting
            if let Some(module) = current_module.take() {
                save_summary(&mut summaries, module, &current_summary);
            }
        } else if current_module.is_some() {
            current_summary.push_str(line);
            current_summary.push('\n');
        }
    }

    // Handle last module if no #### followed
    if let Some(module) = current_module {
        save_summary(&mut summaries, module, &current_summary);
    }

    summaries
}

/// Save a non-placeholder summary to the map.
fn save_summary(summaries: &mut BTreeMap<String, String>, module: String, raw: &str) {
    let trimmed = raw.trim().to_string();
    if !trimmed.is_empty() && !trimmed.contains("Semantic summary to be generated by AI agent") {
        summaries.insert(module, trimmed);
    }
}

/// Write the document header with metadata.
fn write_header(output: &mut String, walk_result: &WalkResult, timestamp: &str) {
    output.push_str("# Code Index\n\n");

    // Collect unique languages
    let mut languages: Vec<&str> = walk_result.by_language().keys().map(|l| l.name()).collect();
    languages.sort();

    let _ = writeln!(
        output,
        "> Generated: {} | {} files | {}",
        timestamp,
        walk_result.file_count(),
        languages.join(", ")
    );
    output.push('\n');
}

/// Write the project structure as an ASCII tree.
fn write_project_structure(output: &mut String, walk_result: &WalkResult) {
    output.push_str("## Project Structure\n\n");
    output.push_str("```\n");

    let tree = build_tree(walk_result);
    render_tree(output, &tree.children, "");

    output.push_str("```\n\n");
}

/// Write modules grouped by directory with co-located semantic summaries and symbols.
fn write_modules(
    output: &mut String,
    walk_result: &WalkResult,
    symbols_by_file: &BTreeMap<PathBuf, Vec<Symbol>>,
    existing_summaries: &BTreeMap<String, String>,
) {
    output.push_str("## Modules\n\n");

    // Group files by parent directory, preserving order
    let mut modules: Vec<(PathBuf, Vec<&crate::walker::SourceFile>)> = Vec::new();
    let mut seen_dirs: BTreeMap<PathBuf, usize> = BTreeMap::new();

    for file in &walk_result.files {
        let parent = file
            .relative_path
            .parent()
            .unwrap_or(Path::new(""))
            .to_path_buf();
        if let Some(&idx) = seen_dirs.get(&parent) {
            modules[idx].1.push(file);
        } else {
            let idx = modules.len();
            seen_dirs.insert(parent.clone(), idx);
            modules.push((parent, vec![file]));
        }
    }

    for (dir, files) in &modules {
        // Check if any file in this module has symbols
        let has_symbols = files.iter().any(|f| {
            symbols_by_file
                .get(&f.relative_path)
                .is_some_and(|s| !s.is_empty())
        });

        if !has_symbols {
            continue;
        }

        let dir_str = dir.display().to_string();
        let _ = writeln!(output, "### {}\n", dir_str);

        // Insert existing summary or placeholder
        if let Some(summary) = existing_summaries.get(&dir_str) {
            let _ = writeln!(output, "{}\n", summary);
        } else {
            let _ = writeln!(output, "{}\n", SUMMARY_PLACEHOLDER);
        }

        // Write file symbols
        for file in files {
            if let Some(symbols) = symbols_by_file.get(&file.relative_path) {
                if symbols.is_empty() {
                    continue;
                }

                let _ = writeln!(output, "#### {}\n", file.relative_path.display());

                // Sort: public first, then by line
                let mut sorted_symbols = symbols.clone();
                sorted_symbols.sort_by(|a, b| {
                    let vis_a = if a.visibility == Visibility::Public {
                        0
                    } else {
                        1
                    };
                    let vis_b = if b.visibility == Visibility::Public {
                        0
                    } else {
                        1
                    };
                    vis_a.cmp(&vis_b).then(a.start_line.cmp(&b.start_line))
                });

                for sym in &sorted_symbols {
                    let vis = if sym.visibility == Visibility::Public {
                        "pub"
                    } else {
                        ""
                    };
                    let sig = sym
                        .signature
                        .as_deref()
                        .map(|s| compact_signature(s, 80))
                        .unwrap_or_else(|| "-".to_string());

                    // Line range: L10-25 or L10 for single-line
                    let line_range = if sym.start_line == sym.end_line {
                        format!("L{}", sym.start_line)
                    } else {
                        format!("L{}-{}", sym.start_line, sym.end_line)
                    };

                    // First sentence of doc comment
                    let doc_excerpt = sym.doc_comment.as_deref().and_then(first_sentence);

                    match doc_excerpt {
                        Some(doc) => {
                            let _ = writeln!(
                                output,
                                "- {} `{}` {} {} — `{}` — {}",
                                vis,
                                sym.name,
                                sym.kind.as_str(),
                                line_range,
                                sig,
                                doc,
                            );
                        }
                        None => {
                            let _ = writeln!(
                                output,
                                "- {} `{}` {} {} — `{}`",
                                vis,
                                sym.name,
                                sym.kind.as_str(),
                                line_range,
                                sig,
                            );
                        }
                    }
                }
                output.push('\n');
            }
        }
    }
}

/// Extract the first sentence from a doc comment.
fn first_sentence(doc: &str) -> Option<&str> {
    let trimmed = doc.trim();
    if trimmed.is_empty() {
        return None;
    }
    // Take first line, then first sentence (up to period+space or period+end)
    let first_line = trimmed.lines().next().unwrap_or(trimmed).trim();
    if first_line.is_empty() {
        return None;
    }
    // Find sentence boundary: period followed by space, end, or newline
    if let Some(pos) = first_line.find(". ") {
        Some(&first_line[..=pos])
    } else if first_line.ends_with('.') {
        Some(first_line)
    } else {
        Some(first_line)
    }
}

/// A node in the file tree for rendering.
struct TreeNode {
    name: String,
    is_dir: bool,
    children: Vec<TreeNode>,
}

/// Build a tree structure from the walk result.
fn build_tree(walk_result: &WalkResult) -> TreeNode {
    let mut root = TreeNode {
        name: String::new(),
        is_dir: true,
        children: Vec::new(),
    };

    for file in &walk_result.files {
        let components: Vec<&str> = file
            .relative_path
            .components()
            .map(|c| c.as_os_str().to_str().unwrap_or("?"))
            .collect();

        insert_path(&mut root, &components, 0);
    }

    root
}

/// Recursively insert a path into the tree.
fn insert_path(node: &mut TreeNode, components: &[&str], depth: usize) {
    if depth >= components.len() {
        return;
    }

    let name = components[depth];
    let is_last = depth == components.len() - 1;

    // Find or create the child node
    let child_idx = node.children.iter().position(|c| c.name == name);

    if let Some(idx) = child_idx {
        if !is_last {
            insert_path(&mut node.children[idx], components, depth + 1);
        }
    } else {
        let mut child = TreeNode {
            name: name.to_string(),
            is_dir: !is_last,
            children: Vec::new(),
        };

        if !is_last {
            insert_path(&mut child, components, depth + 1);
        }

        node.children.push(child);
    }
}

/// Render the tree with box-drawing characters.
fn render_tree(output: &mut String, children: &[TreeNode], prefix: &str) {
    for (i, child) in children.iter().enumerate() {
        let is_last = i == children.len() - 1;
        let connector = if is_last { "└── " } else { "├── " };
        let child_prefix = if is_last { "    " } else { "│   " };

        let suffix = if child.is_dir { "/" } else { "" };
        let _ = writeln!(output, "{}{}{}{}", prefix, connector, child.name, suffix);

        if child.is_dir {
            let new_prefix = format!("{}{}", prefix, child_prefix);
            render_tree(output, &child.children, &new_prefix);
        }
    }
}

/// Write the formatted index to a file, preserving existing summaries.
pub fn write_index_file(
    output_path: &Path,
    walk_result: &WalkResult,
    symbols_by_file: &BTreeMap<PathBuf, Vec<Symbol>>,
    timestamp: &str,
) -> std::io::Result<()> {
    let existing = std::fs::read_to_string(output_path).ok();
    let content = format_index(
        walk_result,
        symbols_by_file,
        timestamp,
        existing.as_deref(),
    );
    std::fs::write(output_path, content)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::Language;
    use crate::symbols::SymbolKind;

    fn make_walk_result(files: Vec<(&str, Language)>) -> WalkResult {
        WalkResult {
            root: PathBuf::from("/project"),
            files: files
                .into_iter()
                .map(|(path, lang)| crate::walker::SourceFile {
                    path: PathBuf::from(format!("/project/{}", path)),
                    relative_path: PathBuf::from(path),
                    language: lang,
                })
                .collect(),
        }
    }

    fn make_symbol(
        name: &str,
        kind: SymbolKind,
        file: &str,
        vis: Visibility,
        sig: Option<&str>,
    ) -> Symbol {
        let mut sym = Symbol::new(name, kind, file, 1, 10).with_visibility(vis);
        if let Some(s) = sig {
            sym = sym.with_signature(s);
        }
        sym
    }

    #[test]
    fn test_format_header() {
        let walk = make_walk_result(vec![
            ("src/main.rs", Language::Rust),
            ("scripts/build.py", Language::Python),
        ]);
        let symbols = BTreeMap::new();

        let output = format_index(&walk, &symbols, "2026-02-24T10:00:00Z", None);

        assert!(output.starts_with("# Code Index"));
        assert!(output.contains("2 files"));
        assert!(output.contains("Python"));
        assert!(output.contains("Rust"));
    }

    #[test]
    fn test_format_project_structure() {
        let walk = make_walk_result(vec![
            ("src/lib.rs", Language::Rust),
            ("src/main.rs", Language::Rust),
            ("src/utils/helpers.rs", Language::Rust),
        ]);
        let symbols = BTreeMap::new();

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        assert!(output.contains("## Project Structure"));
        assert!(output.contains("src/"));
        assert!(output.contains("main.rs"));
        assert!(output.contains("lib.rs"));
        assert!(output.contains("utils/"));
        assert!(output.contains("helpers.rs"));
        // Check box-drawing chars
        assert!(
            output.contains("├── ") || output.contains("└── "),
            "should contain tree connectors"
        );
    }

    #[test]
    fn test_modules_section_exists() {
        let walk = make_walk_result(vec![("src/main.rs", Language::Rust)]);
        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("src/main.rs"),
            vec![make_symbol(
                "main",
                SymbolKind::Function,
                "src/main.rs",
                Visibility::Private,
                Some("fn main()"),
            )],
        );

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        assert!(output.contains("## Modules"));
        assert!(
            output.contains(SUMMARY_PLACEHOLDER),
            "should contain summary placeholder"
        );
    }

    #[test]
    fn test_module_grouping() {
        let walk = make_walk_result(vec![
            ("src/main.rs", Language::Rust),
            ("src/lib.rs", Language::Rust),
            ("src/utils/helpers.rs", Language::Rust),
        ]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("src/main.rs"),
            vec![make_symbol(
                "main",
                SymbolKind::Function,
                "src/main.rs",
                Visibility::Private,
                Some("fn main()"),
            )],
        );
        symbols.insert(
            PathBuf::from("src/lib.rs"),
            vec![make_symbol(
                "init",
                SymbolKind::Function,
                "src/lib.rs",
                Visibility::Public,
                Some("pub fn init()"),
            )],
        );
        symbols.insert(
            PathBuf::from("src/utils/helpers.rs"),
            vec![make_symbol(
                "help",
                SymbolKind::Function,
                "src/utils/helpers.rs",
                Visibility::Public,
                Some("pub fn help()"),
            )],
        );

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        // Module headers (###) for directories
        assert!(output.contains("### src"), "should have src module header");
        assert!(
            output.contains("### src/utils"),
            "should have src/utils module header"
        );
        // File headers (####) for individual files
        assert!(
            output.contains("#### src/main.rs"),
            "should have file header"
        );
        assert!(
            output.contains("#### src/lib.rs"),
            "should have file header"
        );
        assert!(
            output.contains("#### src/utils/helpers.rs"),
            "should have file header"
        );
    }

    #[test]
    fn test_symbols_under_file_headers() {
        let walk = make_walk_result(vec![("src/main.rs", Language::Rust)]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("src/main.rs"),
            vec![
                make_symbol(
                    "main",
                    SymbolKind::Function,
                    "src/main.rs",
                    Visibility::Private,
                    Some("fn main()"),
                ),
                make_symbol(
                    "Config",
                    SymbolKind::Struct,
                    "src/main.rs",
                    Visibility::Public,
                    None,
                ),
            ],
        );

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        assert!(output.contains("#### src/main.rs"));
        assert!(output.contains("`Config`"));
        assert!(output.contains("`main`"));
        assert!(output.contains("L1-10"), "Should contain line range");
    }

    #[test]
    fn test_public_symbols_first() {
        let walk = make_walk_result(vec![("lib.rs", Language::Rust)]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("lib.rs"),
            vec![
                make_symbol(
                    "private_fn",
                    SymbolKind::Function,
                    "lib.rs",
                    Visibility::Private,
                    Some("fn private_fn()"),
                ),
                make_symbol(
                    "PublicFn",
                    SymbolKind::Function,
                    "lib.rs",
                    Visibility::Public,
                    Some("pub fn PublicFn()"),
                ),
            ],
        );

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        // Public symbol should appear before private
        let pub_pos = output.find("`PublicFn`").unwrap();
        let priv_pos = output.find("`private_fn`").unwrap();
        assert!(
            pub_pos < priv_pos,
            "public symbols should appear before private"
        );
    }

    #[test]
    fn test_tree_rendering() {
        let walk = make_walk_result(vec![
            ("cmd/main.go", Language::Go),
            ("pkg/server/handler.go", Language::Go),
            ("pkg/server/routes.go", Language::Go),
            ("pkg/config.go", Language::Go),
        ]);
        let symbols = BTreeMap::new();

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        // Verify tree structure
        assert!(output.contains("cmd/"), "should show cmd directory");
        assert!(output.contains("pkg/"), "should show pkg directory");
        assert!(
            output.contains("server/"),
            "should show nested server directory"
        );
        assert!(output.contains("handler.go"), "should show handler.go");
        assert!(output.contains("routes.go"), "should show routes.go");
        assert!(output.contains("config.go"), "should show config.go");
    }

    #[test]
    fn test_empty_project() {
        let walk = WalkResult {
            root: PathBuf::from("/empty"),
            files: Vec::new(),
        };
        let symbols = BTreeMap::new();

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        assert!(output.contains("# Code Index"));
        assert!(output.contains("0 files"));
        assert!(output.contains("## Project Structure"));
        assert!(output.contains("## Modules"));
    }

    #[test]
    fn test_files_without_symbols_skipped() {
        let walk = make_walk_result(vec![
            ("src/main.rs", Language::Rust),
            ("src/empty.rs", Language::Rust),
        ]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("src/main.rs"),
            vec![make_symbol(
                "main",
                SymbolKind::Function,
                "src/main.rs",
                Visibility::Private,
                Some("fn main()"),
            )],
        );
        // src/empty.rs has no symbols entry

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        assert!(output.contains("#### src/main.rs"));
        assert!(
            !output.contains("#### src/empty.rs"),
            "files without symbols should be skipped"
        );
    }

    #[test]
    fn test_module_without_symbols_skipped() {
        let walk = make_walk_result(vec![
            ("src/main.rs", Language::Rust),
            ("tests/test.rs", Language::Rust),
        ]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("src/main.rs"),
            vec![make_symbol(
                "main",
                SymbolKind::Function,
                "src/main.rs",
                Visibility::Private,
                Some("fn main()"),
            )],
        );
        // tests/test.rs has no symbols

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        assert!(output.contains("### src"), "should have src module");
        assert!(
            !output.contains("### tests"),
            "module with no symbols should be skipped"
        );
    }

    #[test]
    fn test_write_index_file() {
        let tmp = tempfile::tempdir().unwrap();
        let output_path = tmp.path().join("code-index.md");

        let walk = make_walk_result(vec![("main.rs", Language::Rust)]);
        let symbols = BTreeMap::new();

        write_index_file(&output_path, &walk, &symbols, "2026-02-24").unwrap();

        let content = std::fs::read_to_string(&output_path).unwrap();
        assert!(content.contains("# Code Index"));
    }

    #[test]
    fn test_format_with_doc_comment() {
        let walk = make_walk_result(vec![("src/lib.rs", Language::Rust)]);

        let mut symbols = BTreeMap::new();
        let sym = Symbol::new("Config", SymbolKind::Struct, "src/lib.rs", 5, 20)
            .with_visibility(Visibility::Public)
            .with_signature("{ host: String, port: u16 }")
            .with_doc_comment("Application configuration. Used by the server module.");
        symbols.insert(PathBuf::from("src/lib.rs"), vec![sym]);

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        assert!(output.contains("L5-20"), "Should contain line range");
        assert!(
            output.contains("Application configuration."),
            "Should contain first sentence of doc comment"
        );
        assert!(
            !output.contains("Used by the server"),
            "Should NOT contain second sentence"
        );
    }

    #[test]
    fn test_format_single_line_symbol() {
        let walk = make_walk_result(vec![("src/lib.rs", Language::Rust)]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("src/lib.rs"),
            vec![Symbol::new("MAX_SIZE", SymbolKind::Variable, "src/lib.rs", 5, 5)
                .with_visibility(Visibility::Public)
                .with_signature(": usize")],
        );

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        assert!(
            output.contains("L5 "),
            "Single-line should show just L5, not L5-5"
        );
    }

    #[test]
    fn test_first_sentence_extraction() {
        assert_eq!(first_sentence("Hello world."), Some("Hello world."));
        assert_eq!(
            first_sentence("First sentence. Second sentence."),
            Some("First sentence.")
        );
        assert_eq!(first_sentence("No period"), Some("No period"));
        assert_eq!(first_sentence(""), None);
        assert_eq!(first_sentence("  "), None);
    }

    #[test]
    fn test_multi_language_project() {
        let walk = make_walk_result(vec![
            ("backend/main.go", Language::Go),
            ("backend/handler.go", Language::Go),
            ("frontend/app.ts", Language::TypeScript),
            ("frontend/utils.js", Language::JavaScript),
            ("scripts/deploy.py", Language::Python),
            ("src/lib.rs", Language::Rust),
        ]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("backend/main.go"),
            vec![make_symbol(
                "main",
                SymbolKind::Function,
                "backend/main.go",
                Visibility::Private,
                Some("func main()"),
            )],
        );
        symbols.insert(
            PathBuf::from("frontend/app.ts"),
            vec![make_symbol(
                "App",
                SymbolKind::Function,
                "frontend/app.ts",
                Visibility::Public,
                Some("function App()"),
            )],
        );

        let output = format_index(&walk, &symbols, "2026-02-24", None);

        assert!(output.contains("6 files"));
        assert!(output.contains("Go"));
        assert!(output.contains("TypeScript"));
        assert!(output.contains("JavaScript"));
        assert!(output.contains("Python"));
        assert!(output.contains("Rust"));
        // Module-level headers
        assert!(output.contains("### backend"));
        assert!(output.contains("### frontend"));
        // File-level headers
        assert!(output.contains("#### backend/main.go"));
        assert!(output.contains("#### frontend/app.ts"));
    }

    #[test]
    fn test_summary_preservation() {
        let walk = make_walk_result(vec![
            ("src/main.rs", Language::Rust),
            ("src/lib.rs", Language::Rust),
            ("pkg/server.go", Language::Go),
        ]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("src/main.rs"),
            vec![make_symbol(
                "main",
                SymbolKind::Function,
                "src/main.rs",
                Visibility::Private,
                Some("fn main()"),
            )],
        );
        symbols.insert(
            PathBuf::from("src/lib.rs"),
            vec![make_symbol(
                "init",
                SymbolKind::Function,
                "src/lib.rs",
                Visibility::Public,
                Some("pub fn init()"),
            )],
        );
        symbols.insert(
            PathBuf::from("pkg/server.go"),
            vec![make_symbol(
                "Serve",
                SymbolKind::Function,
                "pkg/server.go",
                Visibility::Public,
                Some("func Serve()"),
            )],
        );

        // First generation — no existing content
        let first_output = format_index(&walk, &symbols, "2026-02-24", None);
        assert!(
            first_output.contains(SUMMARY_PLACEHOLDER),
            "first run should have placeholders"
        );

        // Simulate AI agent writing a summary for src module
        let with_summary = first_output.replace(
            &format!("### src\n\n{}", SUMMARY_PLACEHOLDER),
            "### src\n\n**Role**: Application entry point and initialization.\n\n**Key abstractions**:\n- `init()` — bootstraps the runtime",
        );

        // Second generation — should preserve the src summary
        let second_output = format_index(&walk, &symbols, "2026-02-25", Some(&with_summary));

        assert!(
            second_output.contains("Application entry point and initialization"),
            "should preserve existing summary for src"
        );
        assert!(
            second_output.contains("bootstraps the runtime"),
            "should preserve full summary content"
        );
        // pkg should still have placeholder since it wasn't summarized
        // Find the pkg section and check it has the placeholder
        let pkg_section = second_output
            .find("### pkg")
            .expect("should have pkg module");
        let after_pkg = &second_output[pkg_section..];
        assert!(
            after_pkg.contains(SUMMARY_PLACEHOLDER),
            "unsummarized module should still have placeholder"
        );
    }

    #[test]
    fn test_parse_existing_summaries() {
        let content = r#"# Code Index

## Project Structure

```
├── src/
```

## Modules

### src

**Role**: Core application logic.

**Key abstractions**:
- `App` — Main application struct

#### src/main.rs

- pub `main` function L1-10

### lib

> *Semantic summary to be generated by AI agent.*

#### lib/mod.rs

- pub `init` function L1-5
"#;

        let summaries = parse_existing_summaries(content);

        assert!(summaries.contains_key("src"), "should extract src summary");
        assert!(
            summaries["src"].contains("Core application logic"),
            "should have the summary text"
        );
        assert!(
            summaries["src"].contains("Main application struct"),
            "should include multi-line summary"
        );
        assert!(
            !summaries.contains_key("lib"),
            "should NOT include placeholder as a summary"
        );
    }
}
