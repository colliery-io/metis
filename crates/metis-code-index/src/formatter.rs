//! Markdown output formatter for code-index.md.
//!
//! Takes parsed symbols and file tree from the walker/extractors and produces
//! a flat markdown file with three sections: Project Structure, Module Summaries,
//! and Key Symbols.

use std::collections::BTreeMap;
use std::fmt::Write;
use std::path::{Path, PathBuf};

use crate::symbols::{Symbol, Visibility};
use crate::walker::WalkResult;

/// Format a code index as markdown.
///
/// Takes the walk result and extracted symbols, producing a complete markdown
/// document suitable for `.metis/code-index.md`.
pub fn format_index(
    walk_result: &WalkResult,
    symbols_by_file: &BTreeMap<PathBuf, Vec<Symbol>>,
    timestamp: &str,
) -> String {
    let mut output = String::new();

    write_header(&mut output, walk_result, timestamp);
    write_project_structure(&mut output, walk_result);
    write_module_summaries(&mut output);
    write_key_symbols(&mut output, walk_result, symbols_by_file);

    output
}

/// Write the document header with metadata.
fn write_header(output: &mut String, walk_result: &WalkResult, timestamp: &str) {
    output.push_str("# Code Index\n\n");

    // Collect unique languages
    let mut languages: Vec<&str> = walk_result.by_language().keys().map(|l| l.name()).collect();
    languages.sort();

    let _ = writeln!(
        output,
        "> Generated: {} | {} files | {}",
        timestamp,
        walk_result.file_count(),
        languages.join(", ")
    );
    output.push('\n');
}

/// Write the project structure as an ASCII tree.
fn write_project_structure(output: &mut String, walk_result: &WalkResult) {
    output.push_str("## Project Structure\n\n");
    output.push_str("```\n");

    let tree = build_tree(walk_result);
    render_tree(output, &tree.children, "");

    output.push_str("```\n\n");
}

/// Write the module summaries placeholder section.
fn write_module_summaries(output: &mut String) {
    output.push_str("## Module Summaries\n\n");
    output.push_str("*Module summaries will be generated by the AI agent skill.*\n\n");
}

/// Write key symbols grouped by file path.
fn write_key_symbols(
    output: &mut String,
    walk_result: &WalkResult,
    symbols_by_file: &BTreeMap<PathBuf, Vec<Symbol>>,
) {
    output.push_str("## Key Symbols\n\n");

    for file in &walk_result.files {
        let rel_path = &file.relative_path;

        if let Some(symbols) = symbols_by_file.get(rel_path) {
            if symbols.is_empty() {
                continue;
            }

            // Sort: public first, then by kind priority, then by name
            let mut sorted_symbols = symbols.clone();
            sorted_symbols.sort_by(|a, b| {
                let vis_a = if a.visibility == Visibility::Public {
                    0
                } else {
                    1
                };
                let vis_b = if b.visibility == Visibility::Public {
                    0
                } else {
                    1
                };
                vis_a.cmp(&vis_b).then(a.start_line.cmp(&b.start_line))
            });

            let _ = writeln!(output, "### {}\n", rel_path.display());

            for sym in &sorted_symbols {
                let vis = if sym.visibility == Visibility::Public {
                    "pub"
                } else {
                    ""
                };
                let sig = sym.signature.as_deref().unwrap_or("-");

                let _ = writeln!(
                    output,
                    "- {} `{}` {} — `{}`",
                    vis,
                    sym.name,
                    sym.kind.as_str(),
                    sig,
                );
            }
            output.push('\n');
        }
    }
}

/// A node in the file tree for rendering.
struct TreeNode {
    name: String,
    is_dir: bool,
    children: Vec<TreeNode>,
}

/// Build a tree structure from the walk result.
fn build_tree(walk_result: &WalkResult) -> TreeNode {
    let mut root = TreeNode {
        name: String::new(),
        is_dir: true,
        children: Vec::new(),
    };

    for file in &walk_result.files {
        let components: Vec<&str> = file
            .relative_path
            .components()
            .map(|c| c.as_os_str().to_str().unwrap_or("?"))
            .collect();

        insert_path(&mut root, &components, 0);
    }

    root
}

/// Recursively insert a path into the tree.
fn insert_path(node: &mut TreeNode, components: &[&str], depth: usize) {
    if depth >= components.len() {
        return;
    }

    let name = components[depth];
    let is_last = depth == components.len() - 1;

    // Find or create the child node
    let child_idx = node.children.iter().position(|c| c.name == name);

    if let Some(idx) = child_idx {
        if !is_last {
            insert_path(&mut node.children[idx], components, depth + 1);
        }
    } else {
        let mut child = TreeNode {
            name: name.to_string(),
            is_dir: !is_last,
            children: Vec::new(),
        };

        if !is_last {
            insert_path(&mut child, components, depth + 1);
        }

        node.children.push(child);
    }
}

/// Render the tree with box-drawing characters.
fn render_tree(output: &mut String, children: &[TreeNode], prefix: &str) {
    for (i, child) in children.iter().enumerate() {
        let is_last = i == children.len() - 1;
        let connector = if is_last { "└── " } else { "├── " };
        let child_prefix = if is_last { "    " } else { "│   " };

        let suffix = if child.is_dir { "/" } else { "" };
        let _ = writeln!(output, "{}{}{}{}", prefix, connector, child.name, suffix);

        if child.is_dir {
            let new_prefix = format!("{}{}", prefix, child_prefix);
            render_tree(output, &child.children, &new_prefix);
        }
    }
}

/// Write the formatted index to a file.
pub fn write_index_file(
    output_path: &Path,
    walk_result: &WalkResult,
    symbols_by_file: &BTreeMap<PathBuf, Vec<Symbol>>,
    timestamp: &str,
) -> std::io::Result<()> {
    let content = format_index(walk_result, symbols_by_file, timestamp);
    std::fs::write(output_path, content)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::Language;
    use crate::symbols::SymbolKind;

    fn make_walk_result(files: Vec<(&str, Language)>) -> WalkResult {
        WalkResult {
            root: PathBuf::from("/project"),
            files: files
                .into_iter()
                .map(|(path, lang)| crate::walker::SourceFile {
                    path: PathBuf::from(format!("/project/{}", path)),
                    relative_path: PathBuf::from(path),
                    language: lang,
                })
                .collect(),
        }
    }

    fn make_symbol(
        name: &str,
        kind: SymbolKind,
        file: &str,
        vis: Visibility,
        sig: Option<&str>,
    ) -> Symbol {
        let mut sym = Symbol::new(name, kind, file, 1, 10).with_visibility(vis);
        if let Some(s) = sig {
            sym = sym.with_signature(s);
        }
        sym
    }

    #[test]
    fn test_format_header() {
        let walk = make_walk_result(vec![
            ("src/main.rs", Language::Rust),
            ("scripts/build.py", Language::Python),
        ]);
        let symbols = BTreeMap::new();

        let output = format_index(&walk, &symbols, "2026-02-24T10:00:00Z");

        assert!(output.starts_with("# Code Index"));
        assert!(output.contains("2 files"));
        assert!(output.contains("Python"));
        assert!(output.contains("Rust"));
    }

    #[test]
    fn test_format_project_structure() {
        let walk = make_walk_result(vec![
            ("src/lib.rs", Language::Rust),
            ("src/main.rs", Language::Rust),
            ("src/utils/helpers.rs", Language::Rust),
        ]);
        let symbols = BTreeMap::new();

        let output = format_index(&walk, &symbols, "2026-02-24");

        assert!(output.contains("## Project Structure"));
        assert!(output.contains("src/"));
        assert!(output.contains("main.rs"));
        assert!(output.contains("lib.rs"));
        assert!(output.contains("utils/"));
        assert!(output.contains("helpers.rs"));
        // Check box-drawing chars
        assert!(
            output.contains("├── ") || output.contains("└── "),
            "should contain tree connectors"
        );
    }

    #[test]
    fn test_format_module_summaries_placeholder() {
        let walk = make_walk_result(vec![("src/main.rs", Language::Rust)]);
        let symbols = BTreeMap::new();

        let output = format_index(&walk, &symbols, "2026-02-24");

        assert!(output.contains("## Module Summaries"));
        assert!(output.contains("AI agent skill"));
    }

    #[test]
    fn test_format_key_symbols() {
        let walk = make_walk_result(vec![("src/main.rs", Language::Rust)]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("src/main.rs"),
            vec![
                make_symbol(
                    "main",
                    SymbolKind::Function,
                    "src/main.rs",
                    Visibility::Private,
                    Some("fn main()"),
                ),
                make_symbol(
                    "Config",
                    SymbolKind::Struct,
                    "src/main.rs",
                    Visibility::Public,
                    None,
                ),
            ],
        );

        let output = format_index(&walk, &symbols, "2026-02-24");

        assert!(output.contains("## Key Symbols"));
        assert!(output.contains("### src/main.rs"));
        assert!(output.contains("`Config`"));
        assert!(output.contains("`main`"));
    }

    #[test]
    fn test_public_symbols_first() {
        let walk = make_walk_result(vec![("lib.rs", Language::Rust)]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("lib.rs"),
            vec![
                make_symbol(
                    "private_fn",
                    SymbolKind::Function,
                    "lib.rs",
                    Visibility::Private,
                    Some("fn private_fn()"),
                ),
                make_symbol(
                    "PublicFn",
                    SymbolKind::Function,
                    "lib.rs",
                    Visibility::Public,
                    Some("pub fn PublicFn()"),
                ),
            ],
        );

        let output = format_index(&walk, &symbols, "2026-02-24");

        // Public symbol should appear before private
        let pub_pos = output.find("`PublicFn`").unwrap();
        let priv_pos = output.find("`private_fn`").unwrap();
        assert!(
            pub_pos < priv_pos,
            "public symbols should appear before private"
        );
    }

    #[test]
    fn test_tree_rendering() {
        let walk = make_walk_result(vec![
            ("cmd/main.go", Language::Go),
            ("pkg/server/handler.go", Language::Go),
            ("pkg/server/routes.go", Language::Go),
            ("pkg/config.go", Language::Go),
        ]);
        let symbols = BTreeMap::new();

        let output = format_index(&walk, &symbols, "2026-02-24");

        // Verify tree structure
        assert!(output.contains("cmd/"), "should show cmd directory");
        assert!(output.contains("pkg/"), "should show pkg directory");
        assert!(
            output.contains("server/"),
            "should show nested server directory"
        );
        assert!(output.contains("handler.go"), "should show handler.go");
        assert!(output.contains("routes.go"), "should show routes.go");
        assert!(output.contains("config.go"), "should show config.go");
    }

    #[test]
    fn test_empty_project() {
        let walk = WalkResult {
            root: PathBuf::from("/empty"),
            files: Vec::new(),
        };
        let symbols = BTreeMap::new();

        let output = format_index(&walk, &symbols, "2026-02-24");

        assert!(output.contains("# Code Index"));
        assert!(output.contains("0 files"));
        assert!(output.contains("## Project Structure"));
        assert!(output.contains("## Key Symbols"));
    }

    #[test]
    fn test_files_without_symbols_skipped() {
        let walk = make_walk_result(vec![
            ("src/main.rs", Language::Rust),
            ("src/empty.rs", Language::Rust),
        ]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("src/main.rs"),
            vec![make_symbol(
                "main",
                SymbolKind::Function,
                "src/main.rs",
                Visibility::Private,
                Some("fn main()"),
            )],
        );
        // src/empty.rs has no symbols entry

        let output = format_index(&walk, &symbols, "2026-02-24");

        assert!(output.contains("### src/main.rs"));
        assert!(
            !output.contains("### src/empty.rs"),
            "files without symbols should be skipped in Key Symbols"
        );
    }

    #[test]
    fn test_write_index_file() {
        let tmp = tempfile::tempdir().unwrap();
        let output_path = tmp.path().join("code-index.md");

        let walk = make_walk_result(vec![("main.rs", Language::Rust)]);
        let symbols = BTreeMap::new();

        write_index_file(&output_path, &walk, &symbols, "2026-02-24").unwrap();

        let content = std::fs::read_to_string(&output_path).unwrap();
        assert!(content.contains("# Code Index"));
    }

    #[test]
    fn test_multi_language_project() {
        let walk = make_walk_result(vec![
            ("backend/main.go", Language::Go),
            ("backend/handler.go", Language::Go),
            ("frontend/app.ts", Language::TypeScript),
            ("frontend/utils.js", Language::JavaScript),
            ("scripts/deploy.py", Language::Python),
            ("src/lib.rs", Language::Rust),
        ]);

        let mut symbols = BTreeMap::new();
        symbols.insert(
            PathBuf::from("backend/main.go"),
            vec![make_symbol(
                "main",
                SymbolKind::Function,
                "backend/main.go",
                Visibility::Private,
                Some("func main()"),
            )],
        );
        symbols.insert(
            PathBuf::from("frontend/app.ts"),
            vec![make_symbol(
                "App",
                SymbolKind::Function,
                "frontend/app.ts",
                Visibility::Public,
                Some("function App()"),
            )],
        );

        let output = format_index(&walk, &symbols, "2026-02-24");

        assert!(output.contains("6 files"));
        assert!(output.contains("Go"));
        assert!(output.contains("TypeScript"));
        assert!(output.contains("JavaScript"));
        assert!(output.contains("Python"));
        assert!(output.contains("Rust"));
        assert!(output.contains("### backend/main.go"));
        assert!(output.contains("### frontend/app.ts"));
    }
}
