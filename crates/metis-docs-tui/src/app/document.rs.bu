use super::App;
use crate::models::*;
use metis_core::domain::documents::strategy::RiskLevel;
use metis_core::domain::documents::initiative::Complexity;
use anyhow::Result;
use metis_core::{
    application::Application,
    domain::documents::types::DocumentType,
    dal::Database,
    Document, Strategy, Initiative, Task,
    application::services::document::DocumentCreationService,
    application::services::document::creation::DocumentCreationConfig,
};

impl App {
    pub async fn load_documents(&mut self) -> Result<()> {
        if let Some(workspace_dir) = &self.workspace_dir {
            let db_path = workspace_dir.join("metis.db");
            use std::io::Write;
            if let Ok(mut file) = std::fs::OpenOptions::new().create(true).append(true).open("/tmp/metis-debug.log") {
                writeln!(file, "DEBUG: Using database at: {}", db_path.display()).ok();
            }
            if let Ok(db) = Database::new(&db_path.to_string_lossy()) {
                let mut app = Application::new(db);
                
                // Load strategies from files
                app.with_database(|db| {
                    if let Ok(db_docs) = db.find_by_type(DocumentType::Strategy) {
                        let mut board = KanbanBoard::create_strategy_board();
                        for db_doc in db_docs {
                            // Skip archived documents
                            if db_doc.archived {
                                continue;
                            }
                            
                            // Load the actual document from file
                            if let Ok(strategy) = tokio::task::block_in_place(|| {
                                tokio::runtime::Handle::current().block_on(async {
                                    Strategy::from_file(std::path::Path::new(&db_doc.filepath)).await
                                })
                            }) {
                                // Skip archived documents (double check)
                                if strategy.archived() {
                                    continue;
                                }
                                
                                let phase = strategy.phase()
                                    .map(|p| p.to_string())
                                    .unwrap_or_else(|_| "Unknown".to_string());
                                
                                // Get prelude (first ~50 words of description)
                                let prelude = strategy.content().body
                                    .split_whitespace()
                                    .take(12) // ~50 words, roughly 20% of display
                                    .collect::<Vec<_>>()
                                    .join(" ");
                                let prelude = if prelude.len() > 60 {
                                    format!("{}...", &prelude[..57])
                                } else {
                                    prelude
                                };
                                
                                // Get risk level
                                let risk_complexity = Some(format!("{}",
                                    match strategy.risk_level() {
                                        RiskLevel::Low => "ðŸŸ¢ LOW",
                                        RiskLevel::Medium => "ðŸŸ¡ MED",
                                        RiskLevel::High => "ðŸŸ  HIGH",
                                        RiskLevel::Critical => "ðŸ”´ CRIT",
                                    }
                                ));
                                    
                                let item = KanbanItem {
                                    document: DocumentObject::Strategy(strategy),
                                    prelude,
                                    risk_complexity,
                                    file_path: db_doc.filepath.clone(),
                                };
                                
                                if let Some(column) = board.columns.iter_mut().find(|c| c.title == phase) {
                                    column.items.push(item);
                                }
                            }
                        }
                        self.strategy_board = board;
                    }
                });
                
                // Load initiatives from files
                app.with_database(|db| {
                    if let Ok(db_docs) = db.find_by_type(DocumentType::Initiative) {
                        use std::io::Write;
                        if let Ok(mut file) = std::fs::OpenOptions::new().create(true).append(true).open("/tmp/metis-debug.log") {
                            writeln!(file, "DEBUG: Found {} initiatives in database", db_docs.len()).ok();
                        }
                        let mut board = KanbanBoard::create_initiative_board();
                        for db_doc in db_docs {
                            // Skip archived documents
                            if db_doc.archived {
                                continue;
                            }
                            
                            if let Ok(mut file) = std::fs::OpenOptions::new().create(true).append(true).open("/tmp/metis-debug.log") {
                                writeln!(file, "DEBUG: Loading initiative from {}", db_doc.filepath).ok();
                            }
                            if let Ok(initiative) = tokio::task::block_in_place(|| {
                                tokio::runtime::Handle::current().block_on(async {
                                    Initiative::from_file(std::path::Path::new(&db_doc.filepath)).await
                                })
                            }) {
                                if initiative.archived() {
                                    continue;
                                }
                                
                                let phase = initiative.phase()
                                    .map(|p| p.to_string())
                                    .unwrap_or_else(|_| "Unknown".to_string());
                                
                                if let Ok(mut file) = std::fs::OpenOptions::new().create(true).append(true).open("/tmp/metis-debug.log") {
                                    writeln!(file, "DEBUG: Initiative {} has phase: {}", initiative.title(), phase).ok();
                                }
                                
                                // Get prelude (first ~50 words of description)
                                let prelude = initiative.content().body
                                    .split_whitespace()
                                    .take(12) // ~50 words, roughly 20% of display
                                    .collect::<Vec<_>>()
                                    .join(" ");
                                let prelude = if prelude.len() > 60 {
                                    format!("{}...", &prelude[..57])
                                } else {
                                    prelude
                                };
                                
                                // Get complexity level
                                let risk_complexity = Some(format!("{}",
                                    match initiative.estimated_complexity() {
                                        Complexity::S => "ðŸ”µ S",
                                        Complexity::M => "ðŸŸ¡ M",
                                        Complexity::L => "ðŸŸ  L",
                                        Complexity::XL => "ðŸ”´ XL",
                                    }
                                ));
                                    
                                let item = KanbanItem {
                                    document: DocumentObject::Initiative(initiative),
                                    prelude,
                                    risk_complexity,
                                    file_path: db_doc.filepath.clone(),
                                };
                                
                                if let Ok(mut file) = std::fs::OpenOptions::new().create(true).append(true).open("/tmp/metis-debug.log") {
                                    writeln!(file, "DEBUG: Looking for column with title: '{}'", phase).ok();
                                    writeln!(file, "DEBUG: Available columns: {:?}", board.columns.iter().map(|c| &c.title).collect::<Vec<_>>()).ok();
                                }
                                if let Some(column) = board.columns.iter_mut().find(|c| c.title == phase) {
                                    if let Ok(mut file) = std::fs::OpenOptions::new().create(true).append(true).open("/tmp/metis-debug.log") {
                                        writeln!(file, "DEBUG: Added initiative to {} column", phase).ok();
                                    }
                                    column.items.push(item);
                                } else {
                                    if let Ok(mut file) = std::fs::OpenOptions::new().create(true).append(true).open("/tmp/metis-debug.log") {
                                        writeln!(file, "DEBUG: No matching column found for phase: {}", phase).ok();
                                    }
                                }
                            }
                        }
                        self.initiative_board = board;
                    }
                });
                
                // Load tasks from files
                app.with_database(|db| {
                    if let Ok(db_docs) = db.find_by_type(DocumentType::Task) {
                        let mut board = KanbanBoard::create_task_board();
                        for db_doc in db_docs {
                            // Skip archived documents
                            if db_doc.archived {
                                continue;
                            }
                            
                            if let Ok(task) = tokio::task::block_in_place(|| {
                                tokio::runtime::Handle::current().block_on(async {
                                    Task::from_file(std::path::Path::new(&db_doc.filepath)).await
                                })
                            }) {
                                if task.archived() {
                                    continue;
                                }
                                
                                let phase = task.phase()
                                    .map(|p| p.to_string())
                                    .unwrap_or_else(|_| "Unknown".to_string());
                                
                                // Get prelude (first ~50 words of description)
                                let prelude = task.content().body
                                    .split_whitespace()
                                    .take(12) // ~50 words, roughly 20% of display
                                    .collect::<Vec<_>>()
                                    .join(" ");
                                let prelude = if prelude.len() > 60 {
                                    format!("{}...", &prelude[..57])
                                } else {
                                    prelude
                                };
                                
                                // Tasks don't have risk/complexity
                                let risk_complexity = None;
                                    
                                let item = KanbanItem {
                                    document: DocumentObject::Task(task),
                                    prelude,
                                    risk_complexity,
                                    file_path: db_doc.filepath.clone(),
                                };
                                
                                if let Some(column) = board.columns.iter_mut().find(|c| c.title == phase) {
                                    column.items.push(item);
                                }
                            }
                        }
                        self.task_board = board;
                    }
                });
            }
        }
        Ok(())
    }
    
    pub async fn create_new_document(&mut self) -> Result<()> {
        if let Some(workspace_dir) = &self.workspace_dir {
            match self.current_board {
                BoardType::Strategy => {
                    let creation_service = DocumentCreationService::new(workspace_dir);
                    let config = DocumentCreationConfig {
                        title: if self.input_title.value().is_empty() { "New Strategy".to_string() } else { self.input_title.value().to_string() },
                        description: if self.input_description.is_empty() { None } else { Some(self.input_description.clone()) },
                        parent_id: None,
                        tags: vec![],
                        phase: None, // Auto-transition
                    };
                    creation_service.create_strategy(config).await?;
                    
                    // Sync database to pick up the new file
                    self.sync_database().await?;
                    
                    // Reset state and reload documents
                    self.cancel_document_creation();
                    self.load_documents().await?;
                }
                BoardType::Initiative => {
                    return Err(anyhow::anyhow!("Initiative creation not implemented yet"));
                }
                BoardType::Task => {
                    return Err(anyhow::anyhow!("Task creation not implemented yet"));
                }
            }
        }
        
        Ok(())
    }

    pub async fn delete_selected_document(&mut self) -> Result<()> {
        if let Some(selected_item) = self.get_selected_item() {
            if let Some(workspace_dir) = &self.workspace_dir {
                // Use the core deletion service for recursive deletion
                let deletion_service = metis_core::application::services::document::DeletionService::new(workspace_dir.clone());
                let result = deletion_service.delete_document_recursive(&selected_item.file_path).await?;
                
                eprintln!("Deleted {} files, cleaned {} directories", 
                         result.deleted_files.len(), 
                         result.cleaned_directories.len());
                
                // Reload the UI
                self.load_documents().await?;
            }
        }
        
        Ok(())
    }

    pub async fn create_child_document(&mut self) -> Result<()> {
        if let Some(parent_item) = self.get_selected_item() {
            let title = self.input_title.value().to_string();
            
            if title.trim().is_empty() {
                self.error_message = Some("Title cannot be empty".to_string());
                return Ok(());
            }

            // Store parent info before mutable operations
            let parent_id = parent_item.id();
            let parent_doc_type = parent_item.doc_type();

            if let Some(workspace_dir) = &self.workspace_dir {
                let config = DocumentCreationConfig {
                    title: title.clone(),
                    description: None,
                    parent_id: Some(parent_id.clone().into()),
                    tags: vec![],
                    phase: None,
                };

                let creation_service = DocumentCreationService::new(workspace_dir.clone());

                match parent_doc_type {
                    DocumentType::Strategy => {
                        // Create initiative for this strategy
                        creation_service.create_initiative(config, &parent_id).await?;
                    }
                    DocumentType::Initiative => {
                        // Create task for this initiative
                        // We need to find the strategy_id for the task creation
                        if let DocumentObject::Initiative(ref initiative) = &parent_item.document {
                            if let Some(strategy_id) = initiative.parent_id() {
                                creation_service.create_task(config, &strategy_id.to_string(), &parent_id).await?;
                            } else {
                                self.error_message = Some("Initiative has no parent strategy".to_string());
                                return Ok(());
                            }
                        } else {
                            self.error_message = Some("Selected item is not an initiative".to_string());
                            return Ok(());
                        }
                    }
                    _ => {
                        self.error_message = Some("Cannot create child documents for this type".to_string());
                        return Ok(());
                    }
                }

                // Sync database to pick up the new file
                self.sync_database().await?;

                // Reset state and reload documents
                self.cancel_document_creation();
                self.load_documents().await?;
                
                // Switch to the appropriate board to see the new document
                match parent_doc_type {
                    DocumentType::Strategy => {
                        // Created an initiative, switch to initiative board
                        self.current_board = BoardType::Initiative;
                    }
                    DocumentType::Initiative => {
                        // Created a task, switch to task board
                        self.current_board = BoardType::Task;
                    }
                    _ => {}
                }
            }
        }
        
        Ok(())
    }

    pub async fn save_content_edit(&mut self) -> Result<()> {
        if let Some(selected_item) = self.get_selected_item() {
            if let Some(ref textarea) = self.strategy_editor {
                // Get current content from textarea
                let new_content = textarea.lines().join("\n");
                
                // Update and save based on document type
                match &selected_item.document {
                    DocumentObject::Strategy(_) => {
                        let mut doc = Strategy::from_file(&selected_item.file_path).await?;
                        doc.update_content_body(new_content)?;
                        doc.to_file(&selected_item.file_path).await?;
                    }
                    DocumentObject::Initiative(_) => {
                        let mut doc = Initiative::from_file(&selected_item.file_path).await?;
                        doc.update_content_body(new_content)?;
                        doc.to_file(&selected_item.file_path).await?;
                    }
                    DocumentObject::Task(_) => {
                        let mut doc = Task::from_file(&selected_item.file_path).await?;
                        doc.update_content_body(new_content)?;
                        doc.to_file(&selected_item.file_path).await?;
                    }
                    DocumentObject::Adr(_) => {
                        let mut doc = metis_core::Adr::from_file(&selected_item.file_path).await?;
                        doc.update_content_body(new_content)?;
                        doc.to_file(&selected_item.file_path).await?;
                    }
                }
                
                // Sync database
                self.sync_database().await?;
                
                // Reload documents
                self.load_documents().await?;
            }
        }
        
        Ok(())
    }
}