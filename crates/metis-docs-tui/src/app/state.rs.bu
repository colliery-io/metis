use super::App;
use crate::models::*;
use crossterm::event::KeyEvent;
use tui_input::backend::crossterm::EventHandler;
use tui_textarea::TextArea;
use ratatui::widgets::{Block, Borders};
use metis_core::Document;
use metis_core::domain::documents::types::DocumentType;

impl App {
    pub fn get_current_selection(&self) -> (usize, usize) {
        match self.current_board {
            BoardType::Strategy => self.strategy_selection,
            BoardType::Initiative => self.initiative_selection,
            BoardType::Task => self.task_selection,
        }
    }

    pub fn set_selection(&mut self, col: usize, item: usize) {
        match self.current_board {
            BoardType::Strategy => self.strategy_selection = (col, item),
            BoardType::Initiative => self.initiative_selection = (col, item),
            BoardType::Task => self.task_selection = (col, item),
        }
    }

    pub fn start_document_creation(&mut self) {
        self.app_state = AppState::CreatingDocument;
        self.input_title.reset();
        self.input_description.clear();
    }

    pub fn start_child_document_creation(&mut self) {
        // Only allow creating child documents if we have a selected item
        if let Some(selected_item) = self.get_selected_item() {
            match selected_item.doc_type() {
                DocumentType::Strategy => {
                    // For strategies, we can create initiatives
                    self.app_state = AppState::CreatingChildDocument;
                    self.input_title.reset();
                    self.input_description.clear();
                }
                DocumentType::Initiative => {
                    // For initiatives, we can create tasks
                    self.app_state = AppState::CreatingChildDocument;
                    self.input_title.reset();
                    self.input_description.clear();
                }
                _ => {
                    // Other document types don't have child documents
                }
            }
        }
    }
    
    pub fn cancel_document_creation(&mut self) {
        self.app_state = AppState::Normal;
        self.input_title.reset();
        self.input_description.clear();
    }
    
    pub fn handle_key_event(&mut self, key_event: KeyEvent) {
        match self.app_state {
            AppState::CreatingDocument | AppState::CreatingChildDocument => {
                // Only handle the event if we're under the character limit
                if self.input_title.value().len() < 30 || matches!(key_event.code, crossterm::event::KeyCode::Backspace | crossterm::event::KeyCode::Delete | crossterm::event::KeyCode::Left | crossterm::event::KeyCode::Right | crossterm::event::KeyCode::Home | crossterm::event::KeyCode::End) {
                    self.input_title.handle_event(&crossterm::event::Event::Key(key_event));
                }
            }
            _ => {}
        }
    }

    pub fn view_selected_ticket(&mut self) {
        if self.app_state == AppState::Normal {
            let (col, item_idx) = self.get_current_selection();
            let board = self.get_current_board();
            
            if col < board.columns.len() && item_idx < board.columns[col].items.len() {
                self.viewing_ticket = Some((self.current_board, col, item_idx));
                self.app_state = AppState::ViewingDocument;
            }
        }
    }

    pub fn close_ticket_view(&mut self) {
        self.app_state = AppState::Normal;
        self.viewing_ticket = None;
    }

    pub fn start_editing_ticket(&mut self) {
        if let Some(ticket) = self.get_viewed_ticket() {
            let edit_state = EditState {
                current_field: EditField::Title,
                title: ticket.title().to_string(),
                description: ticket.prelude.clone(),
                original_item_id: ticket.id().to_string(),
                original_item_title: ticket.title().to_string(),
            };
            self.edit_state = Some(edit_state);
            self.app_state = AppState::EditingDocument;
        }
    }

    pub fn cancel_editing(&mut self) {
        self.app_state = AppState::ViewingDocument;
        self.edit_state = None;
    }

    pub fn save_edit(&mut self) {
        // TODO: Implement actual save functionality
        // For now, just update the viewing_ticket with changes
        if let Some(ref edit_state) = self.edit_state {
            // TODO: Need to implement mutable access to the actual KanbanItem
            // through the coordinates in viewing_ticket
            // Currently viewing_ticket is just coordinates, not the actual item
        }
        self.app_state = AppState::ViewingDocument;
        self.edit_state = None;
    }

    pub fn edit_handle_input(&mut self, c: char) {
        if let Some(ref mut edit_state) = self.edit_state {
            match edit_state.current_field {
                EditField::Title => {
                    edit_state.title.push(c);
                }
                EditField::Description => {
                    edit_state.description.push(c);
                }
            }
        }
    }

    pub fn edit_handle_backspace(&mut self) {
        if let Some(ref mut edit_state) = self.edit_state {
            match edit_state.current_field {
                EditField::Title => {
                    edit_state.title.pop();
                }
                EditField::Description => {
                    edit_state.description.pop();
                }
            }
        }
    }

    pub fn edit_next_field(&mut self) {
        if let Some(ref mut edit_state) = self.edit_state {
            edit_state.current_field = match edit_state.current_field {
                EditField::Title => EditField::Description,
                EditField::Description => EditField::Title, // Wrap around
            };
        }
    }

    pub fn edit_previous_field(&mut self) {
        if let Some(ref mut edit_state) = self.edit_state {
            edit_state.current_field = match edit_state.current_field {
                EditField::Title => EditField::Description, // Wrap around
                EditField::Description => EditField::Title,
            };
        }
    }

    pub fn start_delete_confirmation(&mut self) {
        self.app_state = AppState::ConfirmingDelete;
    }

    pub fn cancel_delete_confirmation(&mut self) {
        self.app_state = AppState::Normal;
    }

    pub fn get_selected_item(&self) -> Option<&KanbanItem> {
        let (col, item_idx) = self.get_current_selection();
        let board = self.get_current_board();
        
        if col < board.columns.len() && item_idx < board.columns[col].items.len() {
            Some(&board.columns[col].items[item_idx])
        } else {
            None
        }
    }

    pub fn get_viewed_ticket(&self) -> Option<&KanbanItem> {
        if let Some((board_type, col, item_idx)) = &self.viewing_ticket {
            let board = match board_type {
                BoardType::Strategy => &self.strategy_board,
                BoardType::Initiative => &self.initiative_board,
                BoardType::Task => &self.task_board,
            };
            
            if *col < board.columns.len() && *item_idx < board.columns[*col].items.len() {
                Some(&board.columns[*col].items[*item_idx])
            } else {
                None
            }
        } else {
            None
        }
    }

    pub fn start_content_editing(&mut self) {
        if let Some(selected_item) = self.get_selected_item() {
            let mut textarea = TextArea::default();
            
            // Get content based on document type
            let (content, title) = match &selected_item.document {
                crate::models::DocumentObject::Strategy(ref doc) => {
                    use metis_core::Document;
                    (doc.content().full_content(), "Strategy Content")
                }
                crate::models::DocumentObject::Initiative(ref doc) => {
                    use metis_core::Document;
                    (doc.content().full_content(), "Initiative Content")
                }
                crate::models::DocumentObject::Task(ref doc) => {
                    use metis_core::Document;
                    (doc.content().full_content(), "Task Content")
                }
                crate::models::DocumentObject::Adr(ref doc) => {
                    use metis_core::Document;
                    (doc.content().full_content(), "ADR Content")
                }
            };
            
            // Set the content directly - TextArea will handle line breaks properly
            textarea = TextArea::from(content.lines());
            
            // Configure the textarea with proper styling
            textarea.set_block(
                Block::default()
                    .borders(Borders::ALL)
                    .title(title)
            );
            
            self.strategy_editor = Some(textarea);
            self.app_state = AppState::EditingStrategy;
        }
    }

    pub fn cancel_content_editing(&mut self) {
        self.app_state = AppState::Normal;
        self.strategy_editor = None;
    }
}